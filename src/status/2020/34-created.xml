<item>
   <title>Issue #34 created</title>
   <pubDate>2020-12-19T23:54:07Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/34</link>
   <guid>https://qt4cg.org/@qt4cg/2020/#created-34</guid>
   <description>&lt;div&gt;&lt;p&gt;Proposal to introduce the set datatype in XPath 4&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;&lt;strong&gt;It is high time&lt;/strong&gt; that we come up with a &lt;strong&gt;set&lt;/strong&gt; type in XPath. We actually have to deal all the time with sets (not just node-sets, but sets of any-type values), and it is painful to read in the spec how two maps are compared for equality when explaing &lt;code&gt;fn:deep-equal()&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;"&lt;em&gt;If $i1 and $i2 are both ·maps·, the result is true if and only if all the following conditions apply:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Both maps have the same number of entries.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;For every entry in the first map, there is an entry in the second map that:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;has the ·same key· (note that the collation is not used when comparing keys), and&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;has the same associated value (compared using the fn:deep-equal function, under the collation supplied in the original call to fn:deep-equal).&lt;/em&gt;"&lt;/p&gt;
&lt;p&gt;When if we had the set type the above would simply say:&lt;/p&gt;
&lt;p&gt;"&lt;em&gt;If $i1 and $i2 are both ·maps·, the result is true if and only if the sets of their keys are equal, and the corresponding values for each key in the two maps are deep-equal.&lt;/em&gt;"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I propose that starting with XPath 4.0&lt;/strong&gt; we introduce the &lt;strong&gt;set&lt;/strong&gt; type and define set equality, the union ( &lt;strong&gt;|&lt;/strong&gt; ), intersection (&lt;strong&gt;intersect&lt;/strong&gt;) and set difference (&lt;strong&gt;except&lt;/strong&gt;) not only for node-sets but for sets of any-typed values.&lt;/p&gt;
&lt;p&gt;Then we can have a function: &lt;strong&gt;&lt;code&gt;to-set($collection as item()*) as set&lt;/code&gt;&lt;/strong&gt;, which would produce a set (of the distinct values) of any collection-typed argument supplied to it: sequence(its distinct values) , map (a set of its entries), array (a set of its members).&lt;/p&gt;
&lt;p&gt;This makes &lt;code&gt;fn:distinct-values()&lt;/code&gt; almost unnecessary.&lt;/p&gt;
&lt;p&gt;We will no longer have to explain in a "Remarks" section that the result of a function is "unordered" or that its order is "implementation-defined" -- just by making this function return a &lt;strong&gt;set&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;How can almost all major programming languages (not even speaking of SQL), such as C#, Python and Java have a set data type / interface, but even in XPath version 4 we still have to describe it in a free language narrative?&lt;/p&gt;
&lt;p&gt;Thanks,
Dimitre&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
