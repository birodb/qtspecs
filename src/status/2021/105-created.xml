<item>
   <title>Issue #105 created</title>
   <pubDate>2021-12-26T17:54:17Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/105</link>
   <guid>https://qt4cg.org/@qt4cg/2021/#created-105</guid>
   <description>&lt;div&gt;&lt;p&gt;[XPath] Proposal: Maps with Infinite Number of Keys: Total Maps and Decorated maps&lt;/p&gt;&lt;div class="markup"&gt;&lt;h1&gt;&lt;strong&gt;Maps with Infinite Number of Keys: Total Maps and Decorated maps&lt;/strong&gt;&lt;/h1&gt;
&lt;h3&gt;&lt;strong&gt;1. Total Maps&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Maps have become one of the most useful tools for creating readable, short and efficient XPath code. However, a significant limitation of this datatype is that a &lt;code&gt;map&lt;/code&gt; can have only a finite number of keys. In many cases we might want to implement a map that can have more than a fixed, finite number of arguments.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Here is a typical example&lt;/strong&gt; (&lt;em&gt;Example 1&lt;/em&gt;):&lt;br/&gt;
A hotel charges per night differently, depending on how long the customer has been staying. For the first night the price is $100, for the second $90, for the third $80 and for every night after the third $75. We can immediately try to express this pricing data as a map, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;map {
1 : 100,
2 : 90,
3 : 80
(:  ??? How to express the price for all eventual next nights? :)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could, if we had a special key, something like "TheRest", which means any other key-value, which is not one of the already specified key-values.&lt;/p&gt;
&lt;p&gt;Here comes the first part of this proposal:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;We introduce a special key value, which, when specified in a map means: any possible key, different from the other keys, specified for the map&lt;/em&gt;&lt;/strong&gt;. For this purpose we use the string: &lt;strong&gt;&lt;code&gt;"\"&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Adding such a "&lt;em&gt;discard symbol&lt;/em&gt;" makes the map a &lt;strong&gt;&lt;a href="https://en.wikipedia.org/wiki/Partial_function"&gt;total function&lt;/a&gt;&lt;/strong&gt; on the set of any possible XPath atomic items.&lt;/p&gt;
&lt;p&gt;Now we can easily express the hotel-price data as a map:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;map {
1 : 100,
2 : 90,
3 : 80
'\' : 75
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another useful &lt;em&gt;Example (2)&lt;/em&gt; is that now we can express any XPath item, or sequence of items as a map. Let's do this for a simple constant, like π:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $π := map {
'\' : math:pi()
}
 return $π?*   (: produces 3.141592653589793  :)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the map above is empty (has no regular keys) and specifies that for any other key-value &lt;code&gt;$k&lt;/code&gt; it holds that &lt;code&gt;$π($k) eq math:pi()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Going further, we can express even the empty sequence (&lt;em&gt;Example 3&lt;/em&gt;) as the following map:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $Φ := map {
'\' : ()
}
 return $Φ?*   (: produces the empty sequence :)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this representation of the empty sequence, we can provide a solution for the &lt;strong&gt;&lt;a href="https://xmlcom.slack.com/archives/C011NLXE4DU/p1616167871037100"&gt;"Forgiveness problem"&lt;/a&gt;&lt;/strong&gt; raised by Jarno Jelovirta in the XML.Com &lt;code&gt;#general&lt;/code&gt; channel in &lt;em&gt;March 2021&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;This expression will raise an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;[map {"k0": 1}, map{"k0": [1, 2, 3]}]?*?("k0")?*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;[XPTY0004] Input of lookup operator must be map or array: 1.&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To prevent ("forgive", thus "Forgiveness Problem") the raising of such errors we could accept the rule that in XPath 4.0 any expression that evaluates to something different than a map or an array, could be coerced to the following map, which returns the empty sequence as the corresponding value for any key requested in a lookup:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;map {
'\' : ()
}  (: produces the empty sequence  for any lookup:)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;To summarize, what we have achieved so far&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The map constructed in Example 1 is now a &lt;strong&gt;total function&lt;/strong&gt; over the domain &lt;strong&gt;ℕ&lt;/strong&gt; of all natural numbers. Any map with a &lt;code&gt;"\"&lt;/code&gt; (discard key) is a total function over the value-space of all &lt;code&gt;xs:anyAtomicType&lt;/code&gt; values&lt;/li&gt;
&lt;li&gt;We can represent any XPath 4.0 item or sequence in an easy and intuitive way as a map.&lt;/li&gt;
&lt;li&gt;It is now straight-forward to solve the "Forgiveness Problem" by introducing the natural and intuitive rule for coercing any non-map value to the empty map, and this allows to use anywhere the lookup operator &lt;strong&gt;&lt;code&gt;?&lt;/code&gt;&lt;/strong&gt; without raising an error.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;
&lt;h3&gt;&lt;strong&gt;2. Decorated Maps&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Although we already achieved a lot in the first part, there are still use-cases for which we don't have an adequate map  solution:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In the example (1) of expressing the hotel prices, we probably shouldn't get &lt;code&gt;$75&lt;/code&gt; for a key such as -1 or even &lt;code&gt;"blah-blah-blah"&lt;/code&gt;
But the XPath 4.0 language specification allows any atomic values to be possible keys and thus to be the argument to the &lt;code&gt;map:get()&lt;/code&gt; function. &lt;strong&gt;If we want validation for the actually-allowed key-values for a specific given map, we need to have additional processing/functionality.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;With a discard symbol we can express only one infinite set of possible keys and group them under the same corresponding value. However, &lt;strong&gt;there are problems, the data for which needs several infinite sets of key-values to be projected onto different values&lt;/strong&gt;. Here is one such problem:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Imagine we are the organizers of a very simple lottery, selling many millions of tickets, identified by their number, which is a unique natural number.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We want to grant prizes with this simple strategy.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Any ticket number multiple of &lt;strong&gt;10&lt;/strong&gt; wins &lt;strong&gt;$10&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Any ticket number multiple of &lt;strong&gt;100&lt;/strong&gt; wins &lt;strong&gt;$20&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Any ticket number multiple of &lt;strong&gt;1000&lt;/strong&gt; wins &lt;strong&gt;$100&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Any ticket number multiple of &lt;strong&gt;5000&lt;/strong&gt; wins &lt;strong&gt;$1000&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Any ticket number which is &lt;strong&gt;a prime number&lt;/strong&gt; wins &lt;strong&gt;$25000&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Any other&lt;/strong&gt; ticket number doesn't win a prize (wins &lt;strong&gt;$0&lt;/strong&gt;)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;None of the sets of key-values for each of the 6 categories above can be conveniently expressed with the &lt;code&gt;map&lt;/code&gt; that we have so far, although we have merely 6 different cases!&lt;/p&gt;
&lt;p&gt;How can we solve this kind of problem still using maps?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Decorators to the rescue&lt;/strong&gt;...&lt;/p&gt;
&lt;p&gt;What is decorator, what is the decorator pattern and when it is good to use one? According to &lt;a href="https://en.wikipedia.org/wiki/Decorator_pattern#What_solution_does_it_describe?"&gt;&lt;strong&gt;&lt;em&gt;Wikipedia&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;What solution does it describe?&lt;/strong&gt;
Define Decorator objects that&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;implement the interface of the extended (decorated) object (Component) transparently by forwarding all requests to it&lt;/li&gt;
&lt;li&gt;perform additional functionality before/after forwarding a request.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This allows working with different Decorator objects to extend the functionality of an object dynamically at run-time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The idea is to couple a map with a function (the decorator) which can perform any needed preprocessing, such as validation or projection of a supplied value onto one of a predefined small set of values (that are the actual keys of the map). For simplicity, we are not discussing post-processing here, though this can also be part of a decorator, if needed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Let us see how a decorated-map solution to the lottery problem looks like&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $prize-table := map {
  "ten" : 10,
  "hundred" : 20,
  "thousand" : 100,
  "five-thousand" : 1000,
  "prime" : 25000,
 "\" : 0
},
$isPrime := function($input as  xs:integer) as xs:boolean
{
  exists(index-of((2, 3, 5, 7, 11, 13, 17, 19, 23), $input)) (: simplified primality checker :)
},
$decorated-map := function($base-map as map(*), $input as xs:anyAtomicType) as item()*
{
  let $raw-result :=
         (
          let $key := 
           if(not($input castable as xs:positiveInteger)) then '\'  (: we can call the error() function here :) 
             else if($input mod 5000 eq 0) then 'five-thousand'
             else if($input mod 1000 eq 0) then 'thousand'
             else if($input mod 100 eq 0) then 'hundred'
             else if($input mod 10 eq 0) then 'ten'
             else if($isPrime($input)) then 'prime'
             else "\"
          return $base-map($key)
         ),
      $post-process := function($x) {$x},  (: using identity here for simplicity :)
      $post-processed := $post-process($raw-result)
    return $post-processed
},

$prizeForTicket := $decorated-map($prize-table, ?),       (: Note: this is exactly the lookup operator  ?    :)
$ticketNumbers := (1, 10, 100, 1000, 5000, 19, -3, "blah-blah-blah")

return $ticketNumbers ! $prizeForTicket(.)          (: produces 0, 10, 20, 100, 1000, 25000, 0, 0 :)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In the 2nd part of this proposal, a new type/function -- the &lt;strong&gt;&lt;code&gt;decorated-map&lt;/code&gt;&lt;/strong&gt;  was described.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We defined the signature of a &lt;code&gt;decorated-map&lt;/code&gt; and gave an example how to construct and use one in solving a specific problem. In particular, &lt;strong&gt;the proposal is to have a standard function&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;decorated-map ($base-map as map(*), $input as xs:anyAtomicType) as item()*&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finally, we showed that the lookup operator &lt;strong&gt;&lt;code&gt;?&lt;/code&gt;&lt;/strong&gt; on a decorated map $dm is identical to and should be defined as :&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;$dm($base-map, ?)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;What remains to be done&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;The topic of &lt;strong&gt;&lt;em&gt;decorators&lt;/em&gt;&lt;/strong&gt; is extremely important, as a decorator may and should be possible to be defined on any function, not just on maps. This would be addressed in one or more new proposals. Stay tuned 😊&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
