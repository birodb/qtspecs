<item>
   <title>Issue #74 created</title>
   <pubDate>2021-05-14T15:09:38Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/74</link>
   <guid>https://qt4cg.org/@qt4cg/2021/#created-74</guid>
   <description>&lt;div&gt;&lt;p&gt;[FO] Support parsing HTML&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;It is common for applications that use an XQuery database engine to want to parse HTML documents when adding content from HTML pages into a database, or in other applications like generating epub documents from HTML source files. Vendors like MarkLogic (&lt;code&gt;xdmp:tidy&lt;/code&gt; via HTML Tidy for HTML4), BaseX (&lt;code&gt;html:parse&lt;/code&gt; via TagSoup), Saxon (&lt;code&gt;saxon:parse-html&lt;/code&gt; via TagSoup), and eXist-db (&lt;code&gt;util:parse-html&lt;/code&gt; via Neko) have provided custom methods to support this.&lt;/p&gt;
&lt;p&gt;Q: Should there also be functions to list the supported methods and character encodings?&lt;/p&gt;
&lt;h1&gt;fn:parse-html&lt;/h1&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Parses HTML-based input into an XML document.&lt;/p&gt;
&lt;h2&gt;Signature&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fn:parse-html($input as union(xs:string, xs:hexBinary, xs:base64Binary),
              $options as map(*) := map { "method": "html5" }) as document-node()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Properties&lt;/h2&gt;
&lt;p&gt;This function is ·deterministic·, ·context-independent·, and ·focus-independent·.&lt;/p&gt;
&lt;h2&gt;Rules&lt;/h2&gt;
&lt;p&gt;The $options map conforms to &lt;code&gt;record(method as union(enum("html5"), xs:string), encoding as xs:string?, *)&lt;/code&gt;. A vendor may provide ·implementation-dependent· options that may vary between the different &lt;code&gt;method&lt;/code&gt; values.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;method&lt;/code&gt; property of $options defines the approach used to convert the HTML document to XML. This specification supports &lt;code&gt;html5&lt;/code&gt; for using the HTML5 parsing rules for HTML content. The exact version of HTML5 used is ·implementation-dependent·.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;encoding&lt;/code&gt; property of $options defines the character encoding used to decode binary data. By default, this is an empty sequence. Implementations must support at least &lt;code&gt;utf-8&lt;/code&gt;, &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;ascii&lt;/code&gt;, and &lt;code&gt;latin1&lt;/code&gt;. Other encoding values are ·implementation-dependent·, but it is recommended that the encodings documented in the WHATWG Encoding specification [3] are supported.&lt;/p&gt;
&lt;p&gt;If $input is an &lt;code&gt;xs:string&lt;/code&gt;, no character decoding is performed as the input is already decoded.&lt;/p&gt;
&lt;p&gt;If $input is an &lt;code&gt;xs:hexBinary&lt;/code&gt; or &lt;code&gt;xs:base64Binary&lt;/code&gt;, the character encoding used to decode the binary data is determined as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;if the binary data has a valid Unicode Byte Order Mark (BOM), the character encoding specified by that BOM is used.&lt;/li&gt;
&lt;li&gt;if &lt;code&gt;encoding&lt;/code&gt; is specified in $options, that value is used;&lt;/li&gt;
&lt;li&gt;if prescanning the first 1024 bytes of data contains a character encoding (using the rules from https://html.spec.whatwg.org/multipage/parsing.html#prescan-a-byte-stream-to-determine-its-encoding), the detected encoding is used;&lt;/li&gt;
&lt;li&gt;if ·implementation-dependent· heuristics (in line with the HTML5 rules) detect a character encoding, that encoding is used;&lt;/li&gt;
&lt;li&gt;otherwise, the encoding is "utf-8".&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If the detected character encoding name is not supported, an &lt;code&gt;FO######&lt;/code&gt; error is raised. Otherwise, the character encoding method associated with the character encoding is used.&lt;/p&gt;
&lt;p&gt;If the parsing method is not supported, an &lt;code&gt;FO######&lt;/code&gt; error is raised.&lt;/p&gt;
&lt;p&gt;The $input is then parsed according to the specified parsing method, building an intermediate HTML Document object. The XML &lt;code&gt;document-node&lt;/code&gt; is then constructed by mapping the HTML document, element, attribute, text, and comment nodes to their XML equivalents.&lt;/p&gt;
&lt;p&gt;If a HTML document contains a &lt;code&gt;template&lt;/code&gt; element, the contents of that element are added as children of the &lt;code&gt;template&lt;/code&gt; element. It is ·implementation-dependent· whether or not a processor ignores this content when evaluating path expressions on these &lt;code&gt;template&lt;/code&gt; elements, and how they are represented in any DOM interfaces.&lt;/p&gt;
&lt;h2&gt;Notes&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The character encoding logic follows the https://html.spec.whatwg.org/multipage/parsing.html#encoding-sniffing-algorithm rules.&lt;/p&gt;
&lt;p&gt;HTML does not support processing instructions. They are treated as comments in the HTML5 specification.&lt;/p&gt;
&lt;p&gt;The HTML &lt;code&gt;template&lt;/code&gt; element is complex as the HTML specification defines its content as being part of a separate document that is associated with the template contents property of that element, not its children. The WHATWG specification provides a non-normative guide for XSLT and XPath interacting with these elements (https://html.spec.whatwg.org/#template-XSLT-XPath).&lt;/p&gt;
&lt;p&gt;A conforming implementation may choose to parse and return the HTML into a HTML-based data model (e.g. the HTML DOM) instead of generating an XML infoset or PSVI. This is valid as long as the accessor functions (https://www.w3.org/TR/xpath-datamodel-31/#accessors) and the various syntax that works with XML nodes also works for the HTML nodes. That is, expressions like &lt;code&gt;$html/html/body/p instance of element(p)&lt;/code&gt; are supported.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Examples&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The expression &lt;code&gt;fn:parse-html("&amp;lt;html&amp;gt;")&lt;/code&gt; returns an empty html document constructed using the HTML5 document construction rules.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;fn:parse-html($html, encoding: "latin2")&lt;/code&gt; uses the &lt;code&gt;latin2&lt;/code&gt; character encoding to parse $html, or generates an FO###### error if the processor does not support that encoding.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;fn:parse-html($html, method: "html5", encoding: ())&lt;/code&gt; is equivalent to &lt;code&gt;fn:parse-html($html)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;fn:parse-html($html, method: "tidy")&lt;/code&gt; uses the &lt;code&gt;tidy&lt;/code&gt; method (e.g. from the HTML Tidy application) to parse $html into an XML document if supported by the implementation. Otherwise an &lt;code&gt;FO######&lt;/code&gt; error is raised.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;fn:parse-html($html, method: "tagsoup", nons: true())&lt;/code&gt; uses the &lt;code&gt;tagsoup&lt;/code&gt; method (e.g. from the TagSoup application) to parse $html into an XML document if supported by the implementation, passing the &lt;code&gt;--nons&lt;/code&gt; attribute. Otherwise an &lt;code&gt;FO######&lt;/code&gt; error is raised.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.w3.org/TR/html52/"&gt;HTML 5.2&lt;/a&gt;, W3C.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://html.spec.whatwg.org/multipage/"&gt;HTML Living Standard&lt;/a&gt;, WHATWG.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://encoding.spec.whatwg.org/"&gt;Encoding Living Standard&lt;/a&gt;, WHATWG.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
