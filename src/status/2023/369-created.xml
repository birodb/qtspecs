<item>
   <title>Issue #369 created</title>
   <pubDate>2023-02-21T17:44:13Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/369</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-369</guid>
   <description>&lt;div&gt;&lt;p&gt;Namespaces for Functions&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;What problem are we trying to solve? Essentially, I think "namespace clutter".&lt;/p&gt;
&lt;p&gt;Namespace clutter manifests itself in several different ways.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Firstly, declaration clutter in source code. Here's the start of a module in an XSLT Stylesheet of medium complexity:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;xsl:stylesheet 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    exclude-result-prefixes="#all"
    version="3.0" 
    xmlns="http://ns.saxonica.com/xslt/export" 
    xmlns:doc="http://www.saxonica.com/ns/documentation"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map" 
    xmlns:ex="http://ns.saxonica.com/xslt/export" 
    xmlns:f="MyFunctions" 
    xmlns:t="MyTypes"
    expand-text="true"&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Eight namespace declarations here, of which 3 are concerned with functions; and  Wit can get a lot worse than that.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Secondly, namespace clutter in the static and dynamic context. The namespace bindings shown above don't disappear when the code is compiled; even with exclude-result-prefixes="yes", they have to hang around at run-time just in case someone tries to resolve a QName dynamically. Preserving the namespace context in the expression tree through optimization rewrites is a significant cost that has no user benefit; very rarely are they actually going to use the namespace context at run time.&lt;/li&gt;
&lt;li&gt;Thirdly, prefix clutter in the executable code. Writing &lt;code&gt;math:cos(math:cos($x))&lt;/code&gt; is just so clumsy compared with &lt;code&gt;cos(cos($x))&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I think there are a number of things we can do to reduce this.&lt;/p&gt;
&lt;p&gt;First, separate out the namespace context for static resolution of function names as a separate part of the static context, used only for this purpose. Ensure that there is no functionality that depends on knowing this part of the static context at run time, so it can be discarded by the compiler as soon as function names are resolved. Then provide source syntax for binding function prefixes to function namespaces in XSLT and XQuery to populate this part of the static context; there is no reason this has to be done using XML namespace declarations. There is also no reason for having different bindings in force in different parts of a single module. And once we've separated these declarations from XML namespace declarations, there's no reason why we can't provide default bindings. We could also allow bindings to have cross-module scope to reduce duplicated code. Note: the xsl:function-library proposal in the current XSLT 4.0 draft tries to achieve some of these things.&lt;/p&gt;
&lt;p&gt;Second, allow functions to be referenced by local name alone where the reference is unambiguous; and perhaps provide some aliasing mechanisms to make more existing names unambiguous.&lt;/p&gt;
&lt;p&gt;We've explored a third idea, which is to introduce some kind of polymorphism where function names have local scope and are distinguished by the types of objects to which they are applied. I think that given our type system, this is very hard to achieve and I haven't seen any very satisfactory proposals. We also need to remember that there are considerable costs if we start resolving function names dynamically at run time. I wouldn't rule out making progress in this direction, but I'm not optimistic of coming up with a workable solution. There might be some simple things we could do, like having a single function &lt;code&gt;size()&lt;/code&gt; that performs the work of both &lt;code&gt;map:size()&lt;/code&gt; and &lt;code&gt;array:size()&lt;/code&gt; depending on the argument.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
