<item>
   <title>Issue #357 created</title>
   <pubDate>2023-02-18T16:07:01Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/357</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-357</guid>
   <description>&lt;div&gt;&lt;p&gt;Representing key-value pairs&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;A map can be decomposed into, or composed from, a sequence of key-value pairs (KVPs).&lt;/p&gt;
&lt;p&gt;There are two natural representations of a key-value pair (K, V): it can be represented as a singleton map (&lt;code&gt;map{ K: V }&lt;/code&gt;) or as a "doubleton" map (&lt;code&gt;map{ 'key': K, 'value': V}&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;This issue examines how well either of these representations is currently supported, which of them is preferable, and how this support should be improved.&lt;/p&gt;
&lt;p&gt;I'll consider the following basic operations: constructing a KVP from a key and a value, assembling a map from a set of KVPs, decomposing a map into a sequence of KVPs, extracting the key from a KVP, and extracting the value from a KVP.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Singleton Representation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Constructing a KVP from a key and a value:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map{ $key : $value }
map:entry($key, $value)
&amp;lt;xsl:map:entry key="$key" select="$value"/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assembling a map from a set of KVPs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map:merge($kvps)
&amp;lt;xsl:map&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Decomposing a map into a sequence of KVPs:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map:for-each($map, map:entry#2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Extracting the key from a KVP:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map:keys($kvp)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Extracting the value from a KVP:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$kvp?*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Doubleton Representation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Constructing a KVP from a key and a value:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map{ 'key': $key, 'value': $value }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assembling a map from a set of KVPs&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map:build($kvps, -&amp;gt;{?key}, -&amp;gt;{?value})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Decomposing a map into a sequence of KVPs:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map:for-each($map, -&amp;gt;($K, $V){map{ 'key': $key, 'value': $value })&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Extracting the key from a KVP:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$kvp?key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Extracting the value from a KVP:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$kvp?value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Analysis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The singleton representation is better supported at present, and it makes sense therefore to fill in the gaps that currently make it awkward. The main attraction of the doubleton representation is the ease of extracting the key and the value using &lt;code&gt;$kvp?key&lt;/code&gt; and &lt;code&gt;$kvp?value&lt;/code&gt;. The equivalents for the singleton representation (&lt;code&gt;map:keys($kvp)&lt;/code&gt; and &lt;code&gt;$kvp?*&lt;/code&gt;) feel clumsy and unintuitive; however, it's not at all obvious what would be better, short of introducing new custom syntax, which seems over-the-top. The best idea I can come up with is to have two functions &lt;code&gt;map:key($kvp)&lt;/code&gt; and &lt;code&gt;map:value($kvp)&lt;/code&gt; which require $kvp to be a singleton map. But I hate the namespace prefixes...&lt;/p&gt;
&lt;p&gt;The other thing needed to "fill the gaps" is a function &lt;code&gt;map:entries($map)&lt;/code&gt; equivalent to &lt;code&gt;map:for-each($map, map:entry#2)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What if we chose to go the other way, and improve support for the doubleton representation?&lt;/p&gt;
&lt;p&gt;We could add &lt;code&gt;map:key-value-pair($key, $value)&lt;/code&gt; to create  KVP, and &lt;code&gt;map:of($kvps)&lt;/code&gt; to build a map from a set of KVPs, and &lt;code&gt;map:key-value-pairs($map)&lt;/code&gt; to decompose a map. The trickiest problem is what to do about XSLT, where the 3.0 instructions &lt;code&gt;&amp;lt;xsl:map&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;xsl:map-entry&amp;gt;&lt;/code&gt; use the singleton representation.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
