<item>
   <title>Issue #451 created</title>
   <pubDate>2023-04-20T06:51:32Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/451</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-451</guid>
   <description>&lt;div&gt;&lt;p&gt;Multiple Schemas&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;There are many situations in which a single transformation wants to deal with multiple schemas: for example when transforming from v1 of some industry standard to v2 of the same standard, or when processing a collection of input documents each of which references its own schema using &lt;code&gt;xsi:schemaLocation&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is currently possible only if the schemas are compatible (that is, if the union of the schemas is itself a valid schema). And even where it is possible, validation against the union of S1 and S2 may produce a different outcome from validation against S2, for example because a strict wildcard allows content that S2 would not allow. Substitution groups are a particular problem: if v1 and v2 have elements with different substitution group membership, then validating against the union of v1 and v2 allows the union of the substitution groups, which means that you haven't actually verified that the result document is valid against v2.&lt;/p&gt;
&lt;p&gt;The problem is confounded by considerations that are outside the scope of the spec. What happens when you run two different stylesheets against the same source document? If the source document has been validated against S1, this means that both stylesheets must use schemas that are supersets of S1. The way this requirement is managed in Saxon is to introduce the concept of a Configuration in which transformations run; a Configuration has a single schema, and all source documents and stylesheets within the Configuration must use compatible subsets of this schema. A source document validated using one Configuration cannot be used in a different Configuration, because the type annotations would be meaningless against a different schema.&lt;/p&gt;
&lt;p&gt;My proposal is to introduce the idea of a named schema (that is, a named collection of schema components). When we do &lt;code&gt;xsl:import-schema&lt;/code&gt;, we can give the imported schema a name, and there is no requirement that the components in this schema should be compatible with the components in any other schema. When we refer to a schema type (for example in &lt;code&gt;$s cast as QName&lt;/code&gt;) we should be able to qualify the type name with a schema name (we can postpone discussions of syntax, let's say &lt;code&gt;cast as my:part-numberÂ§v1&lt;/code&gt; for now). When we request validation, we should be able to nominate the schema to be used for validation, for example &lt;code&gt;&amp;lt;xsl:element name="e" validation="strict" schema="v2"&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The trickiest part is handling source documents, mainly because validation of source documents (especially those read using doc() or collection()) is at present almost entirely implementation-defined. I believe that we need explicit options to request validation of source documents against a specific schema. There should also be an option to validate a document against the schema identified in its own &lt;code&gt;xsi:schemaLocation&lt;/code&gt;, in which case there should be no requirement that that schema is compatible with any schema known statically to the stylesheet.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
