<item>
   <title>Issue #350 created</title>
   <pubDate>2023-02-16T00:11:51Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/350</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-350</guid>
   <description>&lt;div&gt;&lt;p&gt;[XPath] CompPath (Composite-objects path) Expressions&lt;/p&gt;&lt;div class="markup"&gt;&lt;h1&gt;CompPath (Composite-objects path) Expressions&lt;/h1&gt;
&lt;p&gt;As initially discussed in issue #341, we were exploring different ways to provide an XPath-like language to traverse in depth composite objects such as maps and arrays and select their members at any depth.
While working on this, the idea of an XPath-like language for composite items started to emerge and here we present this idea in a more or less crystalized form.&lt;/p&gt;
&lt;h2&gt;1. Root Component&lt;/h2&gt;
&lt;p&gt;Any CompPath expression must start off a composite item (of type map or array, or of other future composite item type (maybe set? )  ).
This can be a literal composite item or a reference to a variable whose value is a composite item.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;
(: Literal composite items: :)
[1, 2, 3]

[1, [2,  3]]?2

{"x":1, "y" : map{ "z": 2}}

{"x":1, "y" : map{ "z": 2}} ?y

(: Variables containing composite items: :)
let $comp1 := [1, [2, 3]],
 $comp2 :=$comp1 ?2,
 $comp3 := {"x":1, "y" : map{ "z": 2}},
 $comp4 := $comp3 ?y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above examples all literal expressions and all variables (&lt;strong&gt;&lt;code&gt;$comp1, $comp2, $comp3, $comp4&lt;/code&gt;&lt;/strong&gt;) may serve as the root component for a CompPath expression.&lt;/p&gt;
&lt;h2&gt;2. The component-path operator (\)&lt;/h2&gt;
&lt;p&gt;The component-path operator "\" is used to build expressions for locating members at any depth within component trees. Its left-hand side expression must return a result that is a composite item or else this result is represented as such by wrapping it into an array.&lt;/p&gt;
&lt;p&gt;The operator returns an array, the values of whose members are composite items themselves or any such value may be a non-composite "leaf" in the root-component tree).&lt;/p&gt;
&lt;p&gt;Each operation E1\E2 is evaluated as follows: Expression E1 is evaluated, and the result is wrapped in an array A1. If any member of A1 is not a composite item, a type error is raised.
Each member of A1 serves in turn  to provide an inner "composite-focus" (the member as the "composite-context-item" or &lt;strong&gt;&lt;code&gt;.&lt;/code&gt;&lt;/strong&gt;, its index in A1 as the "composite-context-position" or &lt;strong&gt;&lt;code&gt;index()&lt;/code&gt;&lt;/strong&gt;, the set of keys of the composite-context-item as the "composite-keyset" or &lt;strong&gt;&lt;code&gt;keys()&lt;/code&gt;&lt;/strong&gt; and the size of this member as the "composite-context-size" (specified as one of: &lt;strong&gt;&lt;code&gt;size()&lt;/code&gt;&lt;/strong&gt;, or &lt;strong&gt;&lt;code&gt;array-size()&lt;/code&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;key-size()&lt;/code&gt;&lt;/strong&gt;) ) for the evaluation of E2. The result of each evaluation of  E2, if it isn't a single composite item, is wrapped in a single array. The arrays resulting from all the evaluations of E2 are wrapped  in a single array and this single array is the result of the evaluation.&lt;/p&gt;
&lt;p&gt;E2 is typically a function over the &lt;em&gt;context-focus&lt;/em&gt;  and its results will be the set of the next step composite-context-items (used as the left-hand-side of the next in chain composite-step-expression (see below)), or these results would be the final results of evaluation if this is the last-in chain composite-step-expression.&lt;/p&gt;
&lt;h2&gt;3. Composite-Steps&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;composite-step&lt;/strong&gt; is a part of a composite-path-expression that generates an array and filters its members by zero or more predicates. A &lt;strong&gt;composite-step-expression&lt;/strong&gt; is either a &lt;em&gt;CompositeAxisStep&lt;/em&gt; or a &lt;em&gt;CompositePostfixExpression&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;4. Composite-Axes&lt;/h2&gt;
&lt;p&gt;The following axes are defined for traversing a composite-item tree:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;&lt;code&gt;child-member::&lt;/code&gt;&lt;/strong&gt; axis contains the members of the composite-context-item.&lt;/li&gt;
&lt;li&gt;The  &lt;strong&gt;&lt;code&gt;value-member::&lt;/code&gt;&lt;/strong&gt;  axis contains the members of the composite-context-item that are not composite themselves.&lt;/li&gt;
&lt;li&gt;The  &lt;strong&gt;&lt;code&gt;node-member::&lt;/code&gt;&lt;/strong&gt;  axis contains the members of the composite-context-item that are nodes.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;&lt;code&gt;descendant-member::&lt;/code&gt;&lt;/strong&gt; axis is defined as the transitive closure of the &lt;strong&gt;&lt;code&gt;child-member::&lt;/code&gt;&lt;/strong&gt; axis; it contains the descendent-members of the composite-context-item (the child members of the composite-context-item, and their child-members, ... and so on).&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;&lt;code&gt;self::&lt;/code&gt;&lt;/strong&gt; axis contains just the composite-context-item.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;&lt;code&gt;descendant-member-or-self::&lt;/code&gt;&lt;/strong&gt; contains the composite-context-item and all of its descendent-members.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;&lt;code&gt;following-sibling-member::&lt;/code&gt;&lt;/strong&gt; axis contains the members of the immediate container of the composite-context-item that follow it. For any two members &lt;strong&gt;&lt;em&gt;mem1&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;mem2&lt;/em&gt;&lt;/strong&gt; of a composite item &lt;strong&gt;&lt;em&gt;Comp&lt;/em&gt;&lt;/strong&gt;, by definition &lt;strong&gt;&lt;em&gt;mem2&lt;/em&gt;&lt;/strong&gt; follows &lt;strong&gt;&lt;em&gt;mem1&lt;/em&gt;&lt;/strong&gt; if and only if &lt;strong&gt;&lt;em&gt;Comp&lt;/em&gt;&lt;/strong&gt; is an array and the index of &lt;strong&gt;&lt;em&gt;mem2&lt;/em&gt;&lt;/strong&gt; in &lt;strong&gt;&lt;em&gt;Comp&lt;/em&gt;&lt;/strong&gt; is greater than that of &lt;strong&gt;&lt;em&gt;mem1&lt;/em&gt;&lt;/strong&gt;, or if &lt;strong&gt;&lt;em&gt;Comp&lt;/em&gt;&lt;/strong&gt; is a map, then the key of &lt;strong&gt;&lt;em&gt;mem2&lt;/em&gt;&lt;/strong&gt; is greater than that of &lt;strong&gt;&lt;em&gt;mem1&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;&lt;code&gt;preceding-sibling-member::&lt;/code&gt;&lt;/strong&gt; axis contains the members of the immediate container of the composite-context-item that precede it. For any two members &lt;strong&gt;&lt;em&gt;mem1&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;mem2&lt;/em&gt;&lt;/strong&gt; of a composite item &lt;strong&gt;&lt;em&gt;Comp&lt;/em&gt;&lt;/strong&gt;, by definition &lt;strong&gt;&lt;em&gt;mem1&lt;/em&gt;&lt;/strong&gt; precedes &lt;strong&gt;&lt;em&gt;mem2&lt;/em&gt;&lt;/strong&gt; if and only if &lt;strong&gt;&lt;em&gt;Comp&lt;/em&gt;&lt;/strong&gt; is an array and the index of &lt;strong&gt;&lt;em&gt;mem2&lt;/em&gt;&lt;/strong&gt; in &lt;strong&gt;&lt;em&gt;Comp&lt;/em&gt;&lt;/strong&gt; is greater than that of &lt;strong&gt;&lt;em&gt;mem1&lt;/em&gt;&lt;/strong&gt;, or if &lt;strong&gt;&lt;em&gt;Comp&lt;/em&gt;&lt;/strong&gt; is a map, then the key of &lt;strong&gt;&lt;em&gt;mem2&lt;/em&gt;&lt;/strong&gt; is greater than that of &lt;strong&gt;&lt;em&gt;mem1&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, &lt;strong&gt;&lt;code&gt;following-sibling-member::5&lt;/code&gt;&lt;/strong&gt; means all members of the composite-context-item with index &amp;gt; 5,
and &lt;strong&gt;&lt;code&gt;preceding-sibling-member::5&lt;/code&gt;&lt;/strong&gt; means all members of the composite-context-item with index &amp;lt; 5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: If the immediate container of the composite-context-item is a map whose key-values cannot be ordered, then specifying either of the &lt;strong&gt;&lt;code&gt;following-sibling-member::&lt;/code&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;preceding-sibling-member::&lt;/code&gt;&lt;/strong&gt; axes on this composite-context-item must raise a type error. (Obviously, these two axes are meaningful only for composite items, whose members are ordered, such as the array).&lt;/p&gt;
&lt;p&gt;If the composite-axis name is omitted from a composite-axis step, the default axis is &lt;strong&gt;&lt;code&gt;child-member::&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;5. Composite Axis Steps&lt;/h2&gt;
&lt;p&gt;A composite axis step completely resembles the ordinary axis step in XPath. It consists of three parts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The composite axis  (&lt;strong&gt;&lt;code&gt;child-member::&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;descendant-member::&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;value-member::&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;node-member::&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;following-sibling-member::&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;preceding-sibling-member::&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;self::&lt;/code&gt;&lt;/strong&gt;, or the &lt;strong&gt;&lt;code&gt;descendant-member-or-self::&lt;/code&gt;&lt;/strong&gt; axis)&lt;/li&gt;
&lt;li&gt;The member test&lt;/li&gt;
&lt;li&gt;The composite-predicates&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;6. Member Tests&lt;/h2&gt;
&lt;p&gt;A member test is a condition on the key-name, index, or kind (&lt;em&gt;composite&lt;/em&gt;, &lt;em&gt;map&lt;/em&gt;, &lt;em&gt;array&lt;/em&gt; or &lt;em&gt;value&lt;/em&gt;, &lt;em&gt;node&lt;/em&gt;, or (any) &lt;em&gt;member&lt;/em&gt;). A member test determines which members contained by a copmosite-axis are selected by a composite-step.&lt;/p&gt;
&lt;p&gt;As such, a member test is either an &lt;em&gt;identifier-test&lt;/em&gt; (key-name or index) or a &lt;em&gt;kind-test&lt;/em&gt; (&lt;em&gt;composite&lt;/em&gt;, &lt;em&gt;map&lt;/em&gt;, &lt;em&gt;array&lt;/em&gt;,  &lt;em&gt;value&lt;/em&gt;, or &lt;em&gt;member&lt;/em&gt;)).&lt;/p&gt;
&lt;p&gt;Examples of member identifiers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A string specifies a name of a key, whose value will be selected. For example: &lt;strong&gt;&lt;code&gt;\child-member::X&lt;/code&gt;&lt;/strong&gt; selects from the composite-context-item the value corresponding to its key which has the name "X".&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;\child-member::3&lt;/code&gt;&lt;/strong&gt; selects from the composite-context-item the value of its 3rd member, if it is an array or the value corresponding to its key &lt;strong&gt;&lt;code&gt;3&lt;/code&gt;&lt;/strong&gt;, if it is a map.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;following-sibling-member::3&lt;/code&gt;&lt;/strong&gt; selects from the composite-content-item (which is most-likely an array) all of its members having index greater than 3.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;preceding-sibling-member::3&lt;/code&gt;&lt;/strong&gt; selects from the composite-content-item (which is most-likely an array) all of its members having index less than 3.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;\descendant-member-or-self::X&lt;/code&gt;&lt;/strong&gt; selects from the composite-context-item (that must be a map) and from all its descendant-members, the values corresponding to their key named "X", if these descendents have a key named "X".&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Similarly &lt;strong&gt;&lt;code&gt;\5&lt;/code&gt;&lt;/strong&gt; is equivalent to &lt;strong&gt;&lt;code&gt;\child-member::5&lt;/code&gt;&lt;/strong&gt; and selects from the composite-context-item that is an array the value of its 5th member. This will also select the value corresponding to the key &lt;strong&gt;&lt;code&gt;5&lt;/code&gt;&lt;/strong&gt; from the composite-context-item if it is a map, because on the &lt;strong&gt;&lt;code&gt;child-member::&lt;/code&gt;&lt;/strong&gt; axis both maps and arrays may be selected.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;\X&lt;/code&gt;&lt;/strong&gt; is equivalent to &lt;strong&gt;&lt;code&gt;\child-member::X&lt;/code&gt;&lt;/strong&gt; and selects from the composite-context-item (that must be a map), the value corresponding to its key which has the name "X".&lt;/p&gt;
&lt;p&gt;There is also the pseudo-operator &lt;code&gt;\\&lt;/code&gt; . This is an abbreviation for:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;\descendant-member-or-self::member()\&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Thus, &lt;strong&gt;&lt;code&gt;\\X&lt;/code&gt;&lt;/strong&gt; means: "(Deep) Select all members of the root-component that are the corresponding values of keys equal to 'X' "&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We may use a &lt;strong&gt;&lt;em&gt;kind test&lt;/em&gt;&lt;/strong&gt; as part of the previous example, if we want to select only a specific kind of members of the composite-context-item.
&lt;strong&gt;&lt;code&gt;\array()&lt;/code&gt;&lt;/strong&gt;  In this example, although we are on the &lt;strong&gt;&lt;code&gt;child-member::&lt;/code&gt;&lt;/strong&gt; axis, we want to select only members of the composite-context-item that are arrays.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;\map()&lt;/code&gt;&lt;/strong&gt;  In this example, although we are on the &lt;strong&gt;&lt;code&gt;child-member::&lt;/code&gt;&lt;/strong&gt; axis, we want to select only members of the composite-context-item that are maps.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;\value()&lt;/code&gt;&lt;/strong&gt;  In this example we want to select only members of the composite-context-item that are not composite items themselves.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;\node()&lt;/code&gt;&lt;/strong&gt;  In this example we want to select only members of the composite-context-item that are nodes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;\member()&lt;/code&gt;&lt;/strong&gt;  In this example we want to select all members of the composite-context-item, regardless whether they are maps, arrays, or values.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6.1 Wildcards&lt;/h3&gt;
&lt;p&gt;The &lt;strong&gt;&lt;code&gt;*&lt;/code&gt;&lt;/strong&gt; wildcard can be used instead of a member identifier. Its meaning is to select all existing members of the composite-context-item, that is possibly selected by a specific axis and limited by a specific member kind-test.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\*&lt;/code&gt;&lt;/strong&gt;  (: (Shallow) Selects all members of the composite-context-item :)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\map()\*&lt;/code&gt;&lt;/strong&gt;  (: Selects from the composite-context-item all values that correspond to a key of any map-member of the composite-context item :)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\array()\*&lt;/code&gt;&lt;/strong&gt;  (: Selects from the composite-context-item all members of all its members that are arrays :)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\\*&lt;/code&gt;&lt;/strong&gt;  (: (Deep) Select all members of the composite tree rooted by the root-component :)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;7. Predicates&lt;/h2&gt;
&lt;p&gt;As defined above, a &lt;strong&gt;composite-step&lt;/strong&gt; has three parts: &lt;em&gt;composite-axis&lt;/em&gt; (can be omitted and then a default axis is used), &lt;em&gt;member test&lt;/em&gt;, and an optional &lt;em&gt;list of composite-predicates&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;&lt;em&gt;composite-predicate&lt;/em&gt;&lt;/strong&gt; in a composite-step is an expression used as a &lt;em&gt;filter&lt;/em&gt; applied on the members of the composite-context-item that are already selected by the axis and member tests of the axis step, and not filtered out by any preceding composite-predicates in the &lt;em&gt;composite-predicates-list&lt;/em&gt;. The composite-predicate may be any XPath expression and is written within double square brackets.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\*[[3]]&lt;/code&gt;&lt;/strong&gt;  (: Selects any member of the composite-context-item, that is an array and has a 3rd member or any member of the composite-context-item, that is a map and has a key &lt;strong&gt;3&lt;/strong&gt; :)
This is a shorthand for: &lt;strong&gt;&lt;code&gt;\*[[array-size() ge 3 or 3 = keys()]]&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\array()[[3]]&lt;/code&gt;&lt;/strong&gt; (: Selects those array members of the composite-context-item that have a 3rd member :)
This is a shorthand for: &lt;strong&gt;&lt;code&gt;\*[[size() ge 3]]&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\*[[size() eq 7]]&lt;/code&gt;&lt;/strong&gt;  (: Selects those members whose array-size() or key-size() is exactly 7:)
This is a shorthand for: &lt;strong&gt;&lt;code&gt;\composite::*[[self::map() and key-size() eq 7 or self::array() and array-size() eq 7]]&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\*[[X]]&lt;/code&gt;&lt;/strong&gt;  (: Selects any member of the composite-context-item, that is a map and has a key &lt;strong&gt;X&lt;/strong&gt;  :)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\map()[[X]]&lt;/code&gt;&lt;/strong&gt; (: Selects any map member of the composite-context-item, that has a key &lt;strong&gt;X&lt;/strong&gt;  :)
The above two expressions are a shorthand for: &lt;strong&gt;&lt;code&gt;\*[['X' = keys()]]&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\value()[[. gt 0]]&lt;/code&gt;&lt;/strong&gt; (: Selects any value (non-composite member) of the composite-context-item, that is a positive number :)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;8. Mixing CompPath and XPath expressions&lt;/h2&gt;
&lt;p&gt;CompPath and XPath expressions can be used as parts of a single expression:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A CompPath expression may be appended at the end of any XPath expression that produces a composite-object .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An XPath expression may be appended at the end of any CompPath expression. When doing this,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CompPathExpr / XPathExpr&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;is equivalent to:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CompPathExpr\node::* / XPathExpr&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;And this:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CompPathExpr ! XPathExpr&lt;/code&gt;&lt;/strong&gt;  (:  Note: also causes ordering and deduplication of the nodes! :)&lt;/p&gt;
&lt;p&gt;is equivalent to:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CompPathExpr\value::* !  XPathExpr&lt;/code&gt;&lt;/strong&gt;  (: Note: No ordering or deduplication, can be applied on any item, not just on nodes :)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A CompPath expression may be substituted for the expected argument of any XPath expression, for example:
&lt;strong&gt;&lt;code&gt;count(MyCompPathExpr)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Any XPath expression that produces a composite item can be used as the composite-root for any CompPath expression&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $myBooks := 
&amp;lt;books&amp;gt;
 &amp;lt;book name="Tom Sawyer"&amp;gt;
   &amp;lt;author&amp;gt;Mark Twain&amp;lt;/author&amp;gt;
 &amp;lt;/book&amp;gt;
 &amp;lt;book name="Wuthering Heights"&amp;gt;
   &amp;lt;author&amp;gt;Emily Brontë&amp;lt;/author&amp;gt;
 &amp;lt;/book&amp;gt;
 &amp;lt;book name="Jane Eyre"&amp;gt;
   &amp;lt;author&amp;gt;Charlotte Brontë&amp;lt;/author&amp;gt;
 &amp;lt;/book&amp;gt;
 &amp;lt;book name="Adventures of Huckleberry Finn"&amp;gt;
   &amp;lt;author&amp;gt;Mark Twain&amp;lt;/author&amp;gt;
 &amp;lt;/book&amp;gt;
&amp;lt;/books&amp;gt;,
$map1 := map {"science-works": map{"Einstein": "Special Theory of relativity",
                                  "Darwin" : "On the Origin of Species"
                                 },
             "literature" : map{"19the Century": $myBooks}
            }
return
  $map1\literature\\*/book[author eq 'Mark Twain']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Evaluating this mixed CompPath and XPath expression produces the correct result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;&amp;lt;book name="Tom Sawyer"&amp;gt;
  &amp;lt;author&amp;gt;Mark Twain&amp;lt;/author&amp;gt;
&amp;lt;/book&amp;gt;
&amp;lt;book name="Adventures of Huckleberry Finn"&amp;gt;
  &amp;lt;author&amp;gt;Mark Twain&amp;lt;/author&amp;gt;
&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
