<item>
   <title>Issue #503 created</title>
   <pubDate>2023-05-16T23:09:58Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/503</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-503</guid>
   <description>&lt;div&gt;&lt;p&gt;Reinstate focus functions&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;As a result of accepting PR #447, we have lost the ability to write simple "focus functions" that take the context item as an implicit argument, for example &lt;code&gt;sort(//emp, (), -&amp;gt;{@salary})&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The new status quo is that people have to write &lt;code&gt;sort(//emp, (), $e-&amp;gt;{$e/@salary})&lt;/code&gt; which feels clumsy in comparison.&lt;/p&gt;
&lt;p&gt;This issue examines options for reinstating such a capability, and perhaps making it more powerful.&lt;/p&gt;
&lt;p&gt;A reason for dropping the syntax was that it didn't play well with the "thin arrow" operator in pipelines, but we have now changed the symbol for that to &lt;code&gt;=!&amp;gt;&lt;/code&gt; so the objection no longer applies so strongly.&lt;/p&gt;
&lt;p&gt;Ideally we want something that not only replaces focus functions (arity one arguments accepting an argument of type item()), but also meets some or all of the following additional requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Works well on the RHS of the &lt;code&gt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;=!&amp;gt;&lt;/code&gt; operators, in a construct that we might write as &lt;code&gt;$list =!&amp;gt; {.+1}()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Also allows arity-one functions whose argument is a sequence (&lt;code&gt;item()*&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This becomes a lot easier if we can solve issue #129 which generalises the context item to a context value. Let's assume we do that, and keep an open mind for the moment as to whether the generalized context value is referenced as &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;. I'll use &lt;code&gt;~&lt;/code&gt; for now. So we want a compact notation for functions of arity one in which the function body refers to the argument value as &lt;code&gt;~&lt;/code&gt;. For aesthetic reasons, because it's going to be used on the RHS of an arrow operator, we really don't want to introduce it with a leading arrow like the previous syntax &lt;code&gt;-&amp;gt;{.+1}&lt;/code&gt;. Use of "bare braces" (simply &lt;code&gt;{~+1}&lt;/code&gt;) is very tempting, but I think there is a good argument for leaving that part of the syntactic space unused, for extensibility and for diagnostics. I think my preference is for &lt;code&gt;fn{~+1}&lt;/code&gt;. Using a keyword (such as map, array, validate) before a braced expression is a uniform device and keeps the grammar coherent.&lt;/p&gt;
&lt;p&gt;So in a callback such as fn:sort, we can write &lt;code&gt;sort(//emp, (), fn{@salary})&lt;/code&gt;, and in a pipeline we can write &lt;code&gt;$list =!&amp;gt; fn{.+1}()&lt;/code&gt;. (To allow this, all we need to do is to generalise what's allowed as an &lt;code&gt;ArrowDynamicFunction&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;A separate question is whether we can (and should) allow the empty argument list to be omitted. I think I'm persuaded by the arguments that it's better to keep it, as a visual signal that the function is being applied, not just returned.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
