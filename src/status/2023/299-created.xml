<item>
   <title>Issue #299 created</title>
   <pubDate>2023-01-02T18:08:24Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/299</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-299</guid>
   <description>&lt;div&gt;&lt;p&gt;Short-circuiting functions, function-arity guards and lazy hints&lt;/p&gt;&lt;div class="markup"&gt;&lt;h1&gt;&lt;strong&gt;I. Shortcutting and lazy hints&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;Let us have this expression:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $f := function($arg1 as item()*, $arg2 as item()*) as function(item()*) as item()*
             {  (: Some code here :) }
  return
    $f($x) ($y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Evaluating &lt;strong&gt;&lt;code&gt;$f($x)&lt;/code&gt;&lt;/strong&gt; produces a function. The &lt;strong&gt;actual arity&lt;/strong&gt; of this resulting function can be any number &lt;strong&gt;&lt;code&gt;N &amp;gt;= 0&lt;/code&gt;&lt;/strong&gt; :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If &lt;strong&gt;&lt;code&gt;N &amp;gt; 1&lt;/code&gt;&lt;/strong&gt; there would be arity mismatch error, as only one argument &lt;code&gt;$y&lt;/code&gt; is provided in the expression.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;strong&gt;&lt;code&gt;N = 1&lt;/code&gt;&lt;/strong&gt; the final function call can be evaluated, and the argument &lt;code&gt;$y&lt;/code&gt;   must be evaluated,  or&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;If &lt;code&gt;N = 0&lt;/code&gt;, then  &lt;code&gt;$y&lt;/code&gt; is unneeded and can safely be ignored&lt;/strong&gt; according to the updated &lt;strong&gt;“&lt;a href="https://qt4cg.org/pr/279/xquery-40/xpath-40.html#id-coercion-rules"&gt;Coercion Rules / Function Coercion&lt;/a&gt;”&lt;/strong&gt; in Xpath 4.0.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Because a possibility exists to be able to ignore the evaluation of &lt;code&gt;$y&lt;/code&gt;, it is logical to delay the evaluation of &lt;code&gt;$y&lt;/code&gt; until the actual arity of &lt;code&gt;$f($x)&lt;/code&gt; is known&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The current XPath 4.0 evaluation rules do not require an implementation to base its decision whether or not to evaluate &lt;code&gt;$y&lt;/code&gt; on the actual arity of the function produced by &lt;code&gt;$f($x)&lt;/code&gt;, thus at present an implementation could decide to evaluate &lt;code&gt;$y&lt;/code&gt; regardless of the actual arity of the function produced by &lt;code&gt;$f($x)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This is where a &lt;em&gt;lazy&lt;/em&gt; hint comes&lt;/strong&gt;: it indicates to the XPath processor that &lt;em&gt;&lt;strong&gt;it is logical to make the decision about evaluation of &lt;code&gt;$y&lt;/code&gt; based on the actual arity of the function returned by &lt;code&gt;$f($x)&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A rewrite of the above expression using a &lt;strong&gt;&lt;em&gt;&lt;em&gt;lazy&lt;/em&gt;&lt;/em&gt;&lt;/strong&gt; hint looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $f := function($arg1 as item()*, $arg2 as item()*) as function(item()*) as item()*
             {  (: Some code here :) }  
  return
    $f($x) (lazy $y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is one example of a function with short-cutting and calling it with a &lt;strong&gt;&lt;em&gt;lazy&lt;/em&gt;&lt;/strong&gt; hint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $fAnd := function($x as xs:boolean, $y as xs:boolean) as xs:boolean
             {
                let $partial := function($x as xs:boolean) as function(xs:boolean) as  xs:boolean
                                {
                                  if(not($x)) then -&amp;gt;(){false()}
                                              else -&amp;gt;($t) {$t}
                                }
                 return $partial($x)($y)
             }
  return
     $fAnd($x (: possibly false() :), lazy $SomeVeryComplexAndSlowComputedExpression)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Without the &lt;strong&gt;&lt;em&gt;lazy&lt;/em&gt;&lt;/strong&gt; hint in the above example, it is perfectly possible that an XPath implementation, unrestricted by the current rules, would evaluate &lt;em&gt;&lt;code&gt;$SomeVeryComplexAndSlowComputedExpression&lt;/code&gt;&lt;/em&gt; - something that is unneeded and could be avoided completely&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Formal syntax and semantics&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The &lt;strong&gt;&lt;em&gt;lazy&lt;/em&gt;&lt;/strong&gt; keyword should immediately precede any argument in a function call. If specified, it means that &lt;strong&gt;&lt;em&gt;it is logical to make the decision about evaluation of this argument based on the actual arity of the function in this function call&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Based on this definition, it follows that &lt;strong&gt;&lt;em&gt;&lt;code&gt;lazy $argK&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; implies &lt;strong&gt;&lt;em&gt;lazy&lt;/em&gt;&lt;/strong&gt; for all arguments following &lt;code&gt;$argK&lt;/code&gt; in the function call. Thus specifying more than one &lt;strong&gt;&lt;em&gt;lazy&lt;/em&gt;&lt;/strong&gt; hint within a given function call is redundant and an implementation may report this redundancy to the user.&lt;/p&gt;
&lt;p&gt;The scope of a &lt;strong&gt;&lt;em&gt;lazy&lt;/em&gt;&lt;/strong&gt; keyword specified on an argument is this and all following arguments of (only) the current function call.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It is possible to specify a &lt;strong&gt;&lt;em&gt;lazy&lt;/em&gt;&lt;/strong&gt; keyword that is in force for the respective argument(s) of all function calls of the given function. To do this, the &lt;strong&gt;&lt;em&gt;lazy&lt;/em&gt;&lt;/strong&gt; keyword must  be  specified immediately preceding a parameter name in the function definition of that function.&lt;/p&gt;
&lt;p&gt;For example, if the function &lt;strong&gt;&lt;code&gt;$f&lt;/code&gt;&lt;/strong&gt; is specified as:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $f := function($arg1 as item()*, lazy $arg2 as item()*, $arg3 as item()*, $arg4 as item()* ) 
          { (: some code here:) }
  return
     $someExpression
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then any call of &lt;strong&gt;&lt;code&gt;$f&lt;/code&gt;&lt;/strong&gt; in its definition scope that has the form:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;$f($x, $y, $z, $t)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is equivalent to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;$f($x, lazy $y, $z, $t)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;&lt;strong&gt;II. A function's arity is a guard for its arguments&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;Let us have a  function &lt;strong&gt;&lt;code&gt;$f&lt;/code&gt;&lt;/strong&gt; defined as below:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $f := function($arg1 as item()*, $arg2 as item()*, …, $argN as item()*)
   as function(item()*, item()*, …, item()*) as item()*
     {
       if($cond0($arg1))       then -&amp;gt; () { 123 }
        else if($cond1($arg1)) then -&amp;gt; ($Z1 as item()*) {$Z1}
        else if($cond2($arg1)) then -&amp;gt; ($Z1 as item()*, $Z2 as item()*) {$Z1 + $Z2}
        (:    .        .        .        .         .        .        .         .  :)
        else if($condK($arg1)) then -&amp;gt; ($Z1 as item()*, $Z2 as item()*, …, $Zk as item()*)
                                       {$Z1 + $Z2 + … + $Zk}
        else ()
     }
  return
     $f($y1, $y2, …, $yN) ($z1, $z2, …, $zk)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A call to &lt;strong&gt;&lt;code&gt;$f&lt;/code&gt;&lt;/strong&gt; returns a function whose arity may be any of the numbers: 0, 1, …, K.&lt;/p&gt;
&lt;p&gt;Depending on the arity of the returned function (0, 1, …, K), the last (K, K-1,  K-2, …, 2, 1, 0) arguments of the function call:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;$f($y1, $y2,  .  .  . , $yN) ($z1, $z2, .  .  . , $zk)&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;are unneeded and it is logical that they would not need to be evaluated&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;So, the actual arity of the result of calling &lt;strong&gt;&lt;code&gt;$f&lt;/code&gt;&lt;/strong&gt; is a guard for the arguments of a call to this function-result&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Thus, one more bullet needs to be added to [2.4.5 Guarded Expressions] https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-guarded-expressions), specifying an additional guard-type:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In an expression of the type &lt;code&gt;E(A1, A2, ..., AN)&lt;/code&gt; any of the arguments &lt;code&gt;A&lt;/code&gt;&lt;sub&gt;K&lt;/sub&gt; is guarded by the condition 
&lt;code&gt;actual-arity(E) ge K&lt;/code&gt;. This rule has the consequence that if the actual arity of &lt;code&gt;E()&lt;/code&gt; is less than &lt;code&gt;K&lt;/code&gt; then if any argument &lt;code&gt;Am&lt;/code&gt; (where &lt;code&gt;m &amp;gt;= K&lt;/code&gt;) is evaluated, this must not raise a dynamic error. An implementation may base on the actual arity of &lt;code&gt;E()&lt;/code&gt; its decision for the evaluation of the arguments.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
