<item>
   <title>Issue #314 created</title>
   <pubDate>2023-01-18T09:24:52Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/314</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-314</guid>
   <description>&lt;div&gt;&lt;p&gt;Basic Operations on Maps and Arrays&lt;/p&gt;&lt;div class="markup"&gt;&lt;h1&gt;Manipulating Arrays and Maps&lt;/h1&gt;
&lt;p&gt;This is an outline of proposed new facilities designed to make processing of maps and arrays easier. The basic facilities needed for transformation of maps and arrays are the ability to decompose them into their parts, manipulate the parts, and the compose new arrays and maps from these parts.&lt;/p&gt;
&lt;p&gt;Further background is in my 2022 Balisage paper, https://balisage.net/Proceedings/vol27/html/Kay01/BalisageVol27-Kay01.html&lt;/p&gt;
&lt;p&gt;This proposal considers only the "shallow" operations on maps and arrays. Further proposals for deep search and update of nested structures are to be expected.&lt;/p&gt;
&lt;h2&gt;Basics&lt;/h2&gt;
&lt;p&gt;A map entry is an item used to represent a key-value pair in a map; it is an item of type &lt;code&gt;record(key as xs:anyAtomicType, value as item()*)&lt;/code&gt;, aliased in this proposal as &lt;code&gt;type(map-entry)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note: &lt;em&gt;an alternative representation for key-value pairs is as a singleton map, and that's the representation used by the existing map:entry() function and by the xsl:map-entry instruction. A representation as &lt;code&gt;record(key, value)&lt;/code&gt; is rather more convenient to enable extraction of the key and value, but does create some compatibility issues...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;An array entry is an item used to represent a member of an array; it is an item of type &lt;code&gt;record(value as item()*)&lt;/code&gt;, aliased in this proposal as &lt;code&gt;type(array-entry)&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Decomposing Maps and Arrays&lt;/h2&gt;
&lt;p&gt;The function &lt;code&gt;map:entries($map)&lt;/code&gt; returns a sequence of map entries, in unpredictable order, representing the contents of the supplied map. It is equivalent to &lt;code&gt;map:for-each($map, -&amp;gt;($k, $v){map:entry($k, $v)})&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;array:entries($array)&lt;/code&gt; returns a sequence of array entries, in array order, representing the members of the supplied array. It is equivalent to &lt;code&gt;array:for-each($array, -&amp;gt;($v){array:entry($v)})&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Constructing Maps and Arrays&lt;/h2&gt;
&lt;p&gt;The function &lt;code&gt;map:of($entries as type(map-entry)*) as map(*)&lt;/code&gt; constructs a map from a sequence of map entries. A second parameter, &lt;code&gt;$options&lt;/code&gt;, is available to control handling of duplicates, as with &lt;code&gt;map:merge()&lt;/code&gt;. The function is equivalent to &lt;code&gt;map:merge($entries!map{'key':?key, 'value':?value})&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;array:of($entries as type(array-entry)*) as array(*)&lt;/code&gt; constructs an array from a sequence of array entries. It is equivalent to &lt;code&gt;array:fold-left($entries, [], array:append#2)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;map:entry($key, $value) as type(map-entry)&lt;/code&gt; is equivalent to &lt;code&gt;map{'key':$key, 'value':$value}&lt;/code&gt;. &lt;em&gt;Problem: we already have a function map:entry() in 3.1 that does something different. Need to change the terminology...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;array:entry($value) as type(array-entry)&lt;/code&gt; is equivalent to &lt;code&gt;map{'value':$value}&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Filtering Maps and Arrays&lt;/h2&gt;
&lt;p&gt;The construct &lt;code&gt;$map?[PREDICATE]&lt;/code&gt; is equivalent to &lt;code&gt;map:of(map:entries($map)[PREDICATE])&lt;/code&gt;. For example, given a map in which the keys are dates, &lt;code&gt;$map?[year-from-date(?key)=2023]&lt;/code&gt; returns a map containing those entries in which the key is a date in 2023.&lt;/p&gt;
&lt;p&gt;The construct &lt;code&gt;$array?[PREDICATE]&lt;/code&gt; is equivalent to &lt;code&gt;array:of(array:entries($array)[PREDICATE])&lt;/code&gt;. For example, &lt;code&gt;$array?[1]&lt;/code&gt; selects the first item in the array (as a single-member array), while &lt;code&gt;$array?[exists(?value)]&lt;/code&gt; returns an array containing all those entries in the input array that are not empty. If &lt;code&gt;$array&lt;/code&gt; is an array of maps, then &lt;code&gt;$array?[?value?name='John']&lt;/code&gt; selects those members of the array that are maps having &lt;code&gt;?name='John'&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Mapping Maps and Arrays&lt;/h2&gt;
&lt;p&gt;The construct &lt;code&gt;$map!!EXPR&lt;/code&gt; evaluates &lt;code&gt;EXPR&lt;/code&gt; once for each entry in &lt;code&gt;$map&lt;/code&gt; and returns the result as a flattened sequence. For example &lt;code&gt;map:of($map!!map:entry(?key, ?value+1))&lt;/code&gt; returns a map in which each value has been incremented by one.&lt;/p&gt;
&lt;p&gt;The construct &lt;code&gt;$array!!EXPR&lt;/code&gt; evaluates &lt;code&gt;EXPR&lt;/code&gt; once for each entry in &lt;code&gt;$array&lt;/code&gt;, and returns the result as a flattened sequence. For example, &lt;code&gt;array:of($array!!array:entry(?value+1))&lt;/code&gt; returns an array in which every value has been incremented by one.&lt;/p&gt;
&lt;h2&gt;FLWOR Expressions&lt;/h2&gt;
&lt;p&gt;The for-member clause &lt;code&gt;for member $m in $array&lt;/code&gt; is equivalent to &lt;code&gt;for $sys:var in array:entries($array) let $m := $sys:var?value&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The for-entry clause &lt;code&gt;for entry ($k, $v) in $map&lt;/code&gt; is equivalent to &lt;code&gt;for $sys:var in map:entries($map) let $k := $sys:var?key, $v := $sys:var?value&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;XSLT&lt;/h2&gt;
&lt;p&gt;Iteration over maps and arrays is achieved using &lt;code&gt;&amp;lt;xsl:for-each select="array:entries()"&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;xsl:for-each select="map:entries()"&amp;gt;&lt;/code&gt; directly.&lt;/p&gt;
&lt;p&gt;Construction of maps uses the existing instructions &lt;code&gt;&amp;lt;xsl:map&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;xsl:map-entry&amp;gt;&lt;/code&gt;. There is an inconvenience here in that the &lt;code&gt;&amp;lt;xsl:map-entry&amp;gt;&lt;/code&gt; instruction returns a singleton map (&lt;code&gt;map{key:value}&lt;/code&gt;) rather than a map entry as defined in this proposal (&lt;code&gt;map{'key':key, 'value':value}&lt;/code&gt;)..&lt;/p&gt;
&lt;p&gt;Construction of arrays uses the new instructions &lt;code&gt;&amp;lt;xsl:array&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;xsl:array-entry&amp;gt;&lt;/code&gt;. The &lt;code&gt;xsl:array-entry&lt;/code&gt; instruction is defined to construct an array entry as defined in this proposal.&lt;/p&gt;
&lt;h2&gt;Use Cases&lt;/h2&gt;
&lt;p&gt;To be supplied.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
