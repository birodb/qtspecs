<item>
   <title>Issue #397 created</title>
   <pubDate>2023-03-14T21:46:13Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/397</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-397</guid>
   <description>&lt;div&gt;&lt;p&gt;Type names&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;The draft specifications propose the introduction of item type declarations that can associate a name with an item type. The feature probably still needs some work, which this issue aims to explore.&lt;/p&gt;
&lt;p&gt;The main purpose of introducing named item types is that the ItemType for a record structure or a function signature can become quite complex and lengthy, and you don't want to have to repeat them every time they are used because it means you have to make the same change everywhere when a change occurs. Another motivation is to allow type definitions (for example, of records or functions) to be recursive.&lt;/p&gt;
&lt;p&gt;I considered allowing named sequence types rather than just item types, but the rules for where you can and can't have an occurrence indicator get complicated, so I pulled back from that.&lt;/p&gt;
&lt;p&gt;It seems natural to say:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Item type names are QNames&lt;/li&gt;
&lt;li&gt;In XPath, type names (and their mapping to item types) appear in the static context&lt;/li&gt;
&lt;li&gt;In XQuery, type names follow the conventions for global variables and function declarations. That suggests they can appear either in the main module or a library module; in a library module they must be in the namespace of the module; they can be annotated as %public or %private; an &lt;code&gt;import module&lt;/code&gt; declaration makes the name visible in the importing module.&lt;/li&gt;
&lt;li&gt;In XSLT, a name declared in a module is automatically available throughout the stylesheet package, and can be exposed to other packages using the same visibility mechanisms as other stylesheet components. However, I don't think it makes sense to allow a type name to be overridden, either using import precedence or using xsl:override.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The question then arises, should item type names be in the same "symbol space" as named atomic and union types? There seem to be several options here:&lt;/p&gt;
&lt;p&gt;(a) Item type names are in a different symbol space from atomic types; the are no rules barring the same name being used for a named item type and an atomic type, and they are disambiguated by requiring item type names to be distinguished using some kind of marker syntax such as &lt;code&gt;type(name)&lt;/code&gt;, rather than just a bare name.
(b) Item type names are in the same symbol space as atomic types, which means there must be a rule that an item type name must not be the same as an atomic type name that is visible in the same place. We could try and define this rule for individual names, or at the level of namespaces (if there are any atomic/union types in a particular namespace in the static context of any module, then there must be no declared type names in that namespace in that module, either declared in that module or imported from another module).
(c) Atomic type names "shadow" item type names, or vice versa: if the same name is used for both, then one of them takes precedence. Probably not a good idea.&lt;/p&gt;
&lt;p&gt;I'm inclined to go for (b). Note that a simple rule that item type names can't be in a reserved namespace will prevent conflict for all non-schema-aware applications, since those applications only access atomic types in the &lt;code&gt;xs&lt;/code&gt; namespace.&lt;/p&gt;
&lt;p&gt;Now, what about circular definitions?&lt;/p&gt;
&lt;p&gt;There are legitimate circular definitions, like &lt;code&gt;declare item type LIST = record(payload as item()*, next? as LIST)&lt;/code&gt;, and there are "impossible" definitions, like &lt;code&gt;declare item type THING = THING&lt;/code&gt;. Do we have to define the rules needed to ban "impossible" definitions, or can we just leave it that the determination of whether something is an instance of THING is non-terminating? I think we probably need to define the rules, which will require careful thought.&lt;/p&gt;
&lt;p&gt;Where can item type names be used? The simple answer is: anywhere an ItemType is allowed. But what about contexts that only allow some ItemTypes and not others? For example, (a) "cast as", (b) as arguments of a LocalUnionType, (c) as the key type in a map type. (The solution in the current draft is that the syntax allows any ItemType to be used in these contexts, and there are semantic rules to constrain what kind of item types are allowed).&lt;/p&gt;
&lt;p&gt;If we allow &lt;code&gt;$v cast as my:X&lt;/code&gt; where &lt;code&gt;my:X&lt;/code&gt; is a declared item type name, should we also allow the constructor function  &lt;code&gt;my:X($v)&lt;/code&gt;? That would presumably also mean that item type names and function names cannot overlap.&lt;/p&gt;
&lt;p&gt;Should we define any "built-in" item type names? We've been defining built-in functions (such as build-uri and parse-uri) whose signatures use record type definitions. Should we define built-in names for these record definitions?&lt;/p&gt;
&lt;p&gt;An editorial issue: I think it's becoming increasingly difficult to get away with overloading the word &lt;code&gt;ItemType&lt;/code&gt; to mean both the abstract concept of an item type, and the specific BNF construct used to define it. Same for &lt;code&gt;SequenceType&lt;/code&gt;. I think we should probably move to having a defined term "item type" and a BNF construct such as &lt;code&gt;ItemTypeDesignator&lt;/code&gt; to represent the two separate meanings.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
