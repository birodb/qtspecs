<item>
   <title>Issue #467 created</title>
   <pubDate>2023-05-03T11:09:26Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/467</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-467</guid>
   <description>&lt;div&gt;&lt;p&gt;map:keys-where: Return Keys That Match a Predicate&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;&lt;strong&gt;Edit, 23/05/17:&lt;/strong&gt; Reopened to discuss &lt;code&gt;map:keys($map, $predicate)&lt;/code&gt; as an alternative.&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;Motivation&lt;/h3&gt;
&lt;p&gt;We have &lt;code&gt;fn:index-where&lt;/code&gt; and &lt;code&gt;array:index-where&lt;/code&gt; to locate items/members in a sequence/an array that match a specific predicate, and we could introduce an equivalent function for maps. A recent use case can be found in https://github.com/qt4cg/qtspecs/issues/413#issuecomment-1531288167d.&lt;/p&gt;
&lt;h3&gt;Proposal&lt;/h3&gt;
&lt;h4&gt;Summary&lt;/h4&gt;
&lt;p&gt;Returns keys of map entries for which the value matches a supplied predicate.&lt;/p&gt;
&lt;h4&gt;Signature&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;map:keys-where(
  $map        as map(*),
  $predicate  as function(item()*) as xs:boolean
) as xs:anyAtomicValue*
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Properties&lt;/h4&gt;
&lt;p&gt;This function is ·deterministic·, ·context-independent·, and ·focus-independent·.&lt;/p&gt;
&lt;h4&gt;Rules&lt;/h4&gt;
&lt;p&gt;The function takes any ·map· as its &lt;code&gt;$map&lt;/code&gt; argument and applies the supplied function to the value of each map entry. The function supplied as &lt;code&gt;$predicate&lt;/code&gt; takes the value of the corresponding map entry as an argument, and the result is a sequence containing the keys of those entries for which the function returns true.&lt;/p&gt;
&lt;p&gt;More formally, the function returns the result of the expression:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;map:for-each(
  $map,
  function($key, $value) {
    if($predicate($value)) then $key else ()
  }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Examples&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;let $numbers := map { 0: 'zero', 1: 'one', 2: 'two', 3: 'three' }
return map:keys-where($numbers, function($string) { $string = 'two' })
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Comments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Edit (2023-05-04):&lt;/strong&gt; Renamed from &lt;code&gt;map:key-where&lt;/code&gt; to &lt;code&gt;map:keys-where&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Similar functions (&lt;code&gt;index-of&lt;/code&gt;, &lt;code&gt;index-where&lt;/code&gt;) use the singular form.&lt;/li&gt;
&lt;li&gt;An alternative would be to add an optional &lt;code&gt;$predicate&lt;/code&gt; function argument to &lt;code&gt;map:keys&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If we decide to introduce a shorter syntax (see &lt;a href="https://github.com/qt4cg/qtspecs/issues/129"&gt;#129&lt;/a&gt; and &lt;a href="https://github.com/qt4cg/qtspecs/issues/129"&gt;#436&lt;/a&gt;), we could have:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;map:keys-where($numbers, { . = 'two ' })
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
