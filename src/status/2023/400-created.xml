<item>
   <title>Issue #400 created</title>
   <pubDate>2023-03-15T08:13:04Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/400</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-400</guid>
   <description>&lt;div&gt;&lt;p&gt;Priorities for type-based patterns&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;XSLT ยง6.6 currently has a big TODO:&lt;/p&gt;
&lt;p&gt;TODO: define default priorities for type patterns, as suggested in https://www.saxonica.com/papers/xmlprague-2020mhk.pdf section 6.5.1&lt;/p&gt;
&lt;p&gt;We need to plug this gap. [Note: it's worth reading that cited section as it points out some of the difficulties].&lt;/p&gt;
&lt;p&gt;I'm going to suggest an alternative approach. Rather than allocating a numeric priority to patterns such as &lt;code&gt;record(lat, long)&lt;/code&gt;, we allocate them a relative priority -- called their &lt;code&gt;selectivity&lt;/code&gt; -- based on the subtype relationship among types. This is a partial ordering. So we extend the rule that currently orders patterns by (1) import precedence, (2) priority, (3) declaration order, to become instead (1) import precedence, (2) selectivity, (3) priority, (4) declaration order.&lt;/p&gt;
&lt;p&gt;Type-based patterns (such as &lt;code&gt;type(xs:integer)&lt;/code&gt;, &lt;code&gt;record(lat, long)&lt;/code&gt;) are defined to have higher selectivity than any non-type-based pattern; all the latter (that is, all XSLT 3.1 patterns) are defined to have equal selectivity, which means the rules for discriminating among 3.1 patterns are unchanged.&lt;/p&gt;
&lt;p&gt;For type-based patterns, we define that a pattern based on type T has higher selectivity than a pattern based on type U if T is a subtype of U. If neither is a subtype of the other, then they have equal selectivity.&lt;/p&gt;
&lt;p&gt;The type pattern &lt;code&gt;type(T)&lt;/code&gt; followed by one or more predicates is deemed to have higher selectivity than type(T) with no predicates, but apart from this, the predicates are ignored. Explicit numeric priorities can be used to define an ordering among type patterns that have the same selectivity.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
