<item>
   <title>Issue #274 created</title>
   <pubDate>2022-11-26T10:47:08Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/274</link>
   <guid>https://qt4cg.org/@qt4cg/2022/#created-274</guid>
   <description>&lt;div&gt;&lt;p&gt;What would it take/would it be possible to build a module repository for QT?&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;We have an ever growing list of proposed convienence functions. I am not opposed, in principle, to adding convenience functions, but we don’t have any principled criteria (AFAICT) for which ones to add and which ones to reject. That’s not surprising, and I’m also not opposed to that. But I’m sure there are hundreds, perhaps thousands, of such functions. At some point, we’re going to start to resist adding more simply because we’ve added so many. Some of us may already be nearing that point.&lt;/p&gt;
&lt;p&gt;It seems to me that the alternative is to do what TeX, Perl, Python, Node, etc. do: make it easy for users to download, install, and use libraries. (I’m carefully using the term “library” here where I might prefer to use “package” or “module” because we already have “package” and “module” which mean other things.)&lt;/p&gt;
&lt;p&gt;What would it take to make that possible?&lt;/p&gt;
&lt;p&gt;One problem we have is that there are two (perhaps three, or more, depending on how you count) different QT languages and they aren’t all mutually interoperable. My XSLT implementation of &lt;code&gt;fn:parse-uri&lt;/code&gt; for example, isn’t directly usable by an XQuery product that doesn’t implement XSLT or some other product that only uses XPath.&lt;/p&gt;
&lt;p&gt;Suppose we added an &lt;code&gt;import library&lt;/code&gt; declaration to XPath, similar to the &lt;code&gt;import module&lt;/code&gt; declaration in XQuery&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LibraryImport := "import" "library"
                   ("namespace" NCName "=")?
                   "at" URILiteral
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and a corresponding &lt;code&gt;&amp;lt;xsl:library&amp;gt;&lt;/code&gt; instruction to XSLT.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;xsl:library
  namespace = uri
  href = uri /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The semantics of each is that it searches an implementation-defined set of locations for a module that matches the URI. If it finds one, it loads the functions declared in that library. If a namespace is given, it loads only the functions in the namespace provided.&lt;/p&gt;
&lt;p&gt;We’d expect all implementations to be able to load libraries that only used XPath constructions. An XSLT processor might also be able to load XSLT constructions. An XQuery processor might also be able to load XQuery constructions.&lt;/p&gt;
&lt;p&gt;We could define a library file format that allowed an implementor to provide several different implementations of a function, where the processor could choose the best one (in some implementation-dependent way). This would also give us a place to hang version numbers and other relevant metadata.&lt;/p&gt;
&lt;p&gt;With that much in place, would it be more practical to use XPath extension modules?&lt;/p&gt;
&lt;p&gt;Consider the following scenario. I want to use a URI relativization function (as requested in #269). Dimitre provided a pure XPath implementation, so we don’t actually &lt;em&gt;have&lt;/em&gt; to implement it as a native function, we just have to make it easy to use. Imagine that EXPath.org (for example) provided a machine readable list of of libraries.&lt;/p&gt;
&lt;p&gt;I run a hypothetical “expath” command to search the machine readlabe directory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ expath search relative
xpath uri-relativize -- returns the relative location between two URIs
xslt  doc-relative -- convenience functions for accessing “uncles”, “aunts”, etc.
xpath relative-rank -- funtions to score XML documents
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It found three libraries that matched “relative”. That first one sounds promising.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ expath show uri-relativize
The uri-relativize library provides uri-relativize(), an XPath
function that resolves one absolute URI relative to another.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That sounds like what I want, so I install it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ expath install uri-relativize
Downloading uri-relativize … installing … done.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then in my stylesheet I simply add&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;xsl:library href="uri-relativize"/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or in a language that only uses XPath, I add&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import library at "uri-relativize"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and I can use the &lt;code&gt;uri-relativize()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;I think the important parts are that the implementation searches for libraries so that I don’t have to identify precisly where they were installed and that we somehow make it practical to use them without, though it pains me to say this, explicit namespace bindings.&lt;/p&gt;
&lt;p&gt;Perhaps we could allow libraries to “inject” functions into the default function namespace, or we could have a function namespace search list and maybe libraries could extend that.&lt;/p&gt;
&lt;p&gt;The format of the library might be something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;library xmlns="xpath-library" name="uri-relativize" version="1.0.3"
         namespace="http://example.com/my/namespace"&amp;gt;
&amp;lt;provides&amp;gt;
function uri-relativize($path1 as xs:anyURI, $path2 as xs:anyURI) as xs:anyURI
&amp;lt;/provides&amp;gt;
&amp;lt;xpath version="3.0"&amp;gt;
…xpath implementation…
&amp;lt;/xpath&amp;gt;
&amp;lt;xslt version="4.0"&amp;gt;
…xslt 4.0 implementation…
&amp;lt;/xslt&amp;gt;
&amp;lt;xslt version="3.0"&amp;gt;
…xslt 3.0 implementation…
&amp;lt;/xslt&amp;gt;
&amp;lt;library&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But I’m sure if we looked closely at the metadata provided in other system’s packages, we’d see I’ve left a bunch of stuff out. You’d probably, for example, want some way of saying one package depends on another and having the processor load those automatically.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
