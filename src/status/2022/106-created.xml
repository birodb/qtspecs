<item>
   <title>Issue #106 created</title>
   <pubDate>2022-01-02T02:25:38Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/106</link>
   <guid>https://qt4cg.org/@qt4cg/2022/#created-106</guid>
   <description>&lt;div&gt;&lt;p&gt;Decorators' support&lt;/p&gt;&lt;div class="markup"&gt;&lt;h3&gt;Decorators&lt;/h3&gt;
&lt;p&gt;A &lt;strong&gt;Decorator&lt;/strong&gt; is a tool to wrap (extend/change/modify) the behavior of one or more existing functions without modifying their code.&lt;/p&gt;
&lt;p&gt;There are many cases when &lt;em&gt;&lt;strong&gt;we want to handle a call to a specific function &lt;code&gt;f()&lt;/code&gt; and do some or all of the following&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Perform some initial action based on the context and on the arguments in the call to &lt;code&gt;f()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Transform the set of the actual arguments on the call to some other set of argument values -- substituted arguments.&lt;/li&gt;
&lt;li&gt;Decide whether or not to invoke &lt;code&gt;f()&lt;/code&gt;, passing to it the actual arguments or the substituted ones, created in the previous step.&lt;/li&gt;
&lt;li&gt;If we invoked the function in the previous step, we could do something with its result.&lt;/li&gt;
&lt;li&gt;Perform some final processing that may (but does not have to) depend on the result of the invocation of &lt;code&gt;f()&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Here is a small, typical problem&lt;/strong&gt; that is well handled with decorators:&lt;/p&gt;
&lt;p&gt;We want to have a tool to help us with debugging &lt;em&gt;any&lt;/em&gt; function. When a function is called (and if we are in &lt;em&gt;Debug&lt;/em&gt; mode), this tool will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tell us that a call to the function was performed and will list  the function name and the parameters, passed to the function&lt;/li&gt;
&lt;li&gt;Tell us what the result of the call to the function was&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will be able to do such tracing with not just one but with all functions, whose behavior we want to observe.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $trace-decorator := function($debug as xs:boolean, $f as function(*))
    {
      let $theDecorator := function($args as array(*), $kw-args as map(*))
      {
        if($debug)
        then 
          let $func-name := (function-name($f), $kw-args("$funcName"))[1],
            $pre-msg := "Calling function " || $func-name || " with params: " || array:flatten(($args))
            || "," || map:for-each( $kw-args, function($key as xs:anyAtomicType, $val)
                                          {if($key ne "$funcName")
                                            then (" "|| string($key)||": " || string($val))
                                            else ()
                                          }),
            
            $result := $f($args, $kw-args),
            $post-msg := "Got result: " || string($result) || "&amp;amp;#xA;"
           return
             ($pre-msg, $post-msg)
         else $f($args, $kw-args)
      }
      return $theDecorator
    },
    
    $upper := function($args as array(*), $kw-args as map(*))
    {
      let $txt := $args[1]
        return upper-case($txt)
    }
    
    return 
      (
        $trace-decorator(true(), $upper)(["hello"], map{"$funcName" : "$upper"}),
        $trace-decorator(true(), $upper)(["reader"], map{"$funcName" : "$upper"}),
        "=======================================================================",
        $trace-decorator(false(), $upper)(["hello"], map{"$funcName" : "$upper"}),
        $trace-decorator(false(), $upper)(["reader"], map{"$funcName" : "$upper"})
       )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result of evaluating the above XPath 3.1 expression is exactly what we wanted to get:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Calling function $upper with params: hello,
Got result: HELLO&lt;/p&gt;
&lt;p&gt;Calling function $upper with params: reader,
Got result: READER&lt;/p&gt;
&lt;p&gt;=======================================================================
HELLO
READER&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, it is possible to write and use decorators even in XPath 3.1 as above. &lt;strong&gt;Then why XPath decorators are as rare as the white peacock&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/10605892/147841450-5a8f5e94-db6a-4030-80b9-af17c0966763.jpg" alt="peacock"/&gt;
Photo Via: aboutpetlife.com&lt;/p&gt;
&lt;p&gt;The answer is simple: just try to write even the simplest decorator in XPath 3.1 and you'll know how difficult and error-prone this is.
This is why &lt;strong&gt;several programming languages provide special support for decorators&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators"&gt;&lt;strong&gt;Python&lt;/strong&gt;&lt;/a&gt;: &lt;a href="https://www.datacamp.com/community/tutorials/decorators-python"&gt;&lt;strong&gt;&lt;em&gt;decorators&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; are a standard feature of the language.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A standard syntax is provided to declare that a function is being decorated by another function. Composition of multiple decorators is supported.&lt;/li&gt;
&lt;li&gt;There is a standard Python way of getting "&lt;em&gt;any actual arguments&lt;/em&gt;" with which the unknown in advance function (to be decorated) is called.&lt;/li&gt;
&lt;li&gt;There is a standard Python way to call any function passing to it just an array (for its positional arguments) and a map (for its keyword arguments).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/"&gt;&lt;strong&gt;Typescript&lt;/strong&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A standard syntax is provided to declare that a function is being decorated by another function. Composition of multiple decorators is supported.&lt;/li&gt;
&lt;li&gt;Decorators can be applied not only to methods but also to their parameters (and to classes, constructors, static and instance properties, accessors).&lt;/li&gt;
&lt;li&gt;The actual parameters in calling the manipulated method are accessed in a standard way as a &lt;strong&gt;&lt;em&gt;spread&lt;/em&gt;&lt;/strong&gt; (the opposite of &lt;strong&gt;&lt;em&gt;destructuring&lt;/em&gt;&lt;/strong&gt;). The spread syntax is used both for getting the parameters and in providing them in the call to the manipulated method.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.geeksforgeeks.org/what-are-decorators-and-how-are-they-used-in-javascript/"&gt;&lt;strong&gt;Javascript&lt;/strong&gt;&lt;/a&gt; : Almost the same as in Typescript (above)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;.NET/C#&lt;/strong&gt;: &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/"&gt;&lt;strong&gt;C# Attributes&lt;/strong&gt;&lt;/a&gt;, and in particular &lt;a href="http://www.castleproject.org/projects/dynamicproxy/"&gt;&lt;strong&gt;Dynamic Proxies on the Fly in the Castle project&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt;: &lt;strong&gt;&lt;a href="http://perfectjpattern.sourceforge.net/dp-decorator.html"&gt;A PerfectJpattern implementation&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Goal of this proposal&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;To provide standard XPath support for decorators, as seen in other languages&lt;/em&gt; (above):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Provide syntax for specifying the decoration of a function:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Update rule&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;[&lt;a href="https://www.saxonica.com/qt4specs/XP/xpath-40-diff.html#doc-xpath40-FullSignature"&gt;&lt;strong&gt;72&lt;/strong&gt;&lt;/a&gt;] | FullSignature | ::= | "function" "(" ParamList? ")" TypeDeclaration?
-- | -- | -- | --&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;To&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;[72] | FullSignature | ::= | ("^"  DecoratorReference)* "function" "(" ParamList? ")" TypeDeclaration?
-- | -- | -- | --&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;And add this new rule&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;[NN] | DecoratorReference | ::= |  VarRef ArgumentList? |  FunctionCall
-- | -- | -- | --&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;
&lt;p&gt;When a decorated function is called, the XPath processor should create from the actual arguments of the call &lt;strong&gt;an array &lt;em&gt;&lt;code&gt;$args&lt;/code&gt;&lt;/em&gt; that holds all positionally-specified arguments&lt;/strong&gt; in the call, and &lt;strong&gt;a map &lt;em&gt;&lt;code&gt;$kw-args&lt;/code&gt;&lt;/em&gt; that will hold the name - value pairs of all keyword-arguments&lt;/strong&gt; in the call. Then the decorator will be called with these two arguments: &lt;strong&gt;&lt;code&gt;($args, $kw-args)&lt;/code&gt;&lt;/strong&gt; in addition to any of its own positional arguments (if it has any).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;^decorator-name $funcName&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;is converted behind the scenes by the XPath engine to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $funcName := decorator-name($funcName)
  return
  ...remaining code in the same scope
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This redefining of the inline-function name allows us to reference the result of the decoration using the same function item name (&lt;code&gt;$funcName&lt;/code&gt;) in the remainder of the current scope.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When any function is called just with two arguments: &lt;strong&gt;&lt;code&gt;($args, $kw-args)&lt;/code&gt;&lt;/strong&gt; (such as from a decorator), the XPath processor must perform everything necessary in order to call the function in the way it expects to be called. For this purpose, &lt;strong&gt;a new overload of  &lt;a href="https://www.saxonica.com/qt4specs/FO/Overview-diff.html#func-apply"&gt;&lt;code&gt;fn:apply()&lt;/code&gt;&lt;/a&gt; is defined&lt;/strong&gt; (&lt;a href="https://github.com/qt4cg/qtspecs/issues/146"&gt;proposed separately here&lt;/a&gt;):&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fn:apply&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;($function as function(*), $array as array(*), $map as map(*)) as item()*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The result&lt;/strong&gt; of the function is obtained by creating and invoking the same dynamic call that would be the result of  a  function-call to &lt;code&gt;$function&lt;/code&gt; with (positional) arguments taken from the members of the supplied array &lt;code&gt;$array&lt;/code&gt; and (keyword arguments) taken from &lt;code&gt;$map&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The effect of calling&lt;/strong&gt; &lt;code&gt;fn:apply($f, [$a, $b, $c, ...], map{"k1" : v1, "k2" : v2, ...})&lt;/code&gt; is the same as the effect of the dynamic function call resulting from &lt;code&gt;$function($a, $b, $c, ...., $k1 = v1, $k2 = v2, ...)&lt;/code&gt;. The function conversion rules are applied to the supplied arguments in the usual way.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;With this support added to the language, we simply write:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $f := $trace-decorator(true()) ( upper-case#1 )
  return
    ("hello", "reader") ! $f()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which produces the same correct result:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Calling function upper-case with params: hello,
Got result: HELLO&lt;/p&gt;
&lt;p&gt;Calling function upper-case with params: reader,
Got result: READER&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $f := $trace-decorator(false())  ( upper-case#1 )
  return
    ("hello", "reader") ! $f()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Produces just the normal result of executing the original function &lt;code&gt;$f()&lt;/code&gt;, as the $debug argument is &lt;code&gt;false()&lt;/code&gt; here&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HELLO
READER&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;When we decorate an inline-function&lt;/strong&gt; (say the $upper from the initial example), we can even simply write:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;^$trace-decorator(true())  $upper,
.   .   .   .   .
  return
    ("hello", "reader") ! $upper()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to get again the the correct result:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Calling function $upper with params: hello,
Got result: HELLO&lt;/p&gt;
&lt;p&gt;Calling function $upper with params: reader,
Got result: READER&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Do note&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The decorator and the manipulated function are completely independent of each other and may be written long before / after each other and by different people who may not be aware of each other.&lt;/li&gt;
&lt;li&gt;They can reside in different code files.&lt;/li&gt;
&lt;li&gt;We can have a library of useful decorator functions and can append them to decorate any wanted function.&lt;/li&gt;
&lt;li&gt;As the updated &lt;strong&gt;&lt;em&gt;&lt;code&gt;Rule 72&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; above suggests, &lt;strong&gt;one can specify a chain of decorators&lt;/strong&gt; manipulating a specific function. The inner-most decorator is passed to the next-inner-most-decorator, and so on..., which is passed ... to the outer-most decorator. &lt;strong&gt;Decorating is right-associative&lt;/strong&gt;.
The different decorators specified don't know about each other, are completely independent and may be written by different authors at any times and reside in different, unrelated function libraries.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
