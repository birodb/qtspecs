<item>
   <title>Issue #220 created</title>
   <pubDate>2022-10-25T09:09:57Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/220</link>
   <guid>https://qt4cg.org/@qt4cg/2022/#created-220</guid>
   <description>&lt;div&gt;&lt;p&gt;Encapsulation&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;Let's suppose that I want to provide a library to do complex number arithmetic, and I want to hide how complex numbers are actually implemented (it could be an array of two doubles, or a map containing two doubles, it could be in polar coordinates, etc).&lt;/p&gt;
&lt;p&gt;How might I go about doing this? One approach is like this (please be patient):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module namespace complex...;

declare %public type alias complex:number as function(*);

declare %private variable SECRET := &amp;lt;e/&amp;gt;;

declare $private function complex:wrap($content as record(re as xs:double, im as xs:double)) as complex:number {
    function($key as node()) {if ($key is $SECRET then $content else error());
};

declare $private function complex:unwrap($cx as complex:number) as record(re as xs:double, im as xs:double) {
   $cx($SECRET);
};

declare %public function complex:new($re as xs:double, $im as xs:double) as complex:number {
  complex:wrap(map{'re':$re, 'im':$im})
}

declare %public function complex:real($x as complex:number) as xs:double {
  complex:unwrap($x)?re
}

declare %public function complex:add($x as complex:number, $y as complex:number) {
  etc;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What's going on here? We're representing a complex number as an arity-1 function; the function "unlocks" the complex number to reveal its internal implementation, but it can only be called if you know the secret argument to pass, and this is encapsulated within the library module that implements the functionality. So we've successfully encapsulated the implementation, and we've done it without any data model changes. Within the provider module, the functions wrap() and unwrap() are available to convert from the internal representation to the external representation; these functions are not available to the caller.&lt;/p&gt;
&lt;p&gt;It works, but it's hardly elegant.&lt;/p&gt;
&lt;p&gt;From the point of view of the user of the library, it's quite usable: they just import the library and call the functions. They probably don't care that the type complex:number is actually a function, and if they do care, there's not much they can do with the knowledge.&lt;/p&gt;
&lt;p&gt;From the point of view of the author of the library, there's a lot of boilerplate. One thing we could do to improve matters would be to provide some syntactic sugar. Instead of a module declaration, use a class declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class complex:number wraps record(re as xs:double, im as xs:double);

declare %public function complex:real($x as complex:number) as xs:double {
  complex:unwrap($x)?re
}

declare %public function complex:add($x as complex:number, $y as complex:number) {
  etc;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The boilerplate, especially the wrap and unwrap functions, is now implicitly declared.&lt;/p&gt;
&lt;p&gt;And we could provide "import class" for the caller as an alternative to "import module".&lt;/p&gt;
&lt;p&gt;We could go further and give the magic function used to represent an encapsulated value some kind of special status in the data model. But do we need to?&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
