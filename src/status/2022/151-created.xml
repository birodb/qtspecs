<item>
   <title>Issue #151 created</title>
   <pubDate>2022-09-21T17:34:06Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/151</link>
   <guid>https://qt4cg.org/@qt4cg/2022/#created-151</guid>
   <description>&lt;div&gt;&lt;p&gt;map:build() function&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;This proposal replaces https://github.com/qt4cg/qtspecs/issues/110&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map:build($input as item()*, 
                  $makeKey as function(item()) as xs:anyAtomicValue, 
                  $makeValue as function(item()) as item()*.
                  $duplicates as function(item()*, item()*) as item()*) as map(*)

The fourth argument is optional and defaults to fn:op(",").

The third argument is optional and defaults to fn:identity#1

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map:build(//employee, -&amp;gt;{@ssn}, identity#1, -&amp;gt;($x,$y){error()})&lt;/code&gt;
Constructs an index of employees with the atomised @ssn attribute as key, and the employee element as the associated value, failing if there are any duplicates&lt;/p&gt;
&lt;p&gt;This can be abbreviated to &lt;code&gt;map:build(//employee, -&amp;gt;{@ssn})&lt;/code&gt; if it is known that there are no duplicates, or if the default action on duplicates is acceptable.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map:build(//employee, -&amp;gt;{location/city}, -&amp;gt;{xs:decimal(salary)}, op(","))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Constructs a map whose keys are the locations of employees and whose associated values are the salaries of employees at that location. The effect of the $duplicates argument is that if there are several employees at the same location, their salaries are combined into a sequence (using the "," operator). If the last argument were &lt;code&gt;op("+")&lt;/code&gt;, the map would contain the sum of the salaries for each location.&lt;/p&gt;
&lt;p&gt;Rules&lt;/p&gt;
&lt;p&gt;The function creates a map.&lt;/p&gt;
&lt;p&gt;Informally, the function processes each item in the input sequence in turn in sequence order. It calls the $makeKey function on that item to obtain a key value, and the $makeValue function to obtain an associated value. If the key is not already present in the map, it creates a new key-value pair with that key and that value. If the key is already present, it combines the existing value for the key with the new value using the $duplicates function, and replaces the entry with this combined value.&lt;/p&gt;
&lt;p&gt;More formally, the result of the function is the result of the following expression:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fold-left($input, map{}, -&amp;gt;($old, $next){
    let $key := $makeKey($next)
    let $value := $makeValue($next)
    return 
       if (map:contains($old, $key))
       then map:put($old, $key, $duplicates($map:get($key), $value))
       else map:put($old, $key, $value)
   })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NOTE: although defined to process the input sequence in order, the implementation may be optimised (for example to work in parallel) if it is known that the $duplicates function is symmetric, that is, if $duplicates($a, $b) produces the same result as $duplicates($b, $a).&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
