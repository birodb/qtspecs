<item>
   <title>Issue #218 created</title>
   <pubDate>2022-10-19T09:11:13Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/218</link>
   <guid>https://qt4cg.org/@qt4cg/2022/#created-218</guid>
   <description>&lt;div&gt;&lt;p&gt;Function library for maps with composite keys: and thoughts on encapsulation&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;I propose creating a function library that handles maps with composite keys. I'll start by defining a set of functions, then we'll consider how to package these, in particular issues of encapsulation and types. Even it we don't want to implement this particular feature, it might help to generate infrastructure that makes it easier to create such function libraries.&lt;/p&gt;
&lt;p&gt;For the sake of a name, I'll call the data structure we are manipulating an &lt;strong&gt;atlas&lt;/strong&gt;. (Like a map, but generalized.) An atlas is a mapping from sequences of atomic values to values. Two sequences of atomic values are equal if they are the same length and their constituent atoms are pairwise equal according to op:same-key(). Note that keys are variable length and it's permitted to have both ("a") and ("a, b") as entries in the atlas.&lt;/p&gt;
&lt;p&gt;We'll start by defining the API we want to offer. The semantics for these functions are essentially the same as the corresponding functions for maps. The type of $key is always xs:anyAtomicType*. We'll discuss the type of $atlas later.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;atlas:build($input, $keyFunction, $valueFunction, $onDuplicates) =&amp;gt; atlas&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;atlas:get($atlas, $key) =&amp;gt; value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;atlas:contains($atlas, $key) =&amp;gt; value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;atlas:put($atlas, $key, $value) =&amp;gt; atlas&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;atlas:keys($atlas) =&amp;gt; array(key)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;atlas:for-each($atlas, function(key, value)) =&amp;gt; value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;atlas:size($atlas) =&amp;gt; integer&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;plus some more specific functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;atlas:get-branch($atlas, $partial-key) =&amp;gt; atlas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;returns an atlas containing all those entries in the supplied atlas whose keys start with the supplied partial-key; the returned atlas contains the remaining parts of the keys.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;atlas:put-branch($atlas, $partial-key, $atlas branch) =&amp;gt; atlas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similarly, grafts one atlas as a subtree into another.&lt;/p&gt;
&lt;p&gt;It's not too hard to come up with an implementation of this API that uses nested maps. For example: An atlas-node is a map from atomic-values to &lt;code&gt;record(leaf? as value, branch? as atlas-node)&lt;/code&gt;, where leaf contains the value if the atlas contains the relevant key in full, while branch contains a nested atlas if the atlas contains nodes starting with the relevant prefix; either or both may be present.&lt;/p&gt;
&lt;p&gt;Now the tricky part: how to handle encapsulation. There are two parts to this: (a) defining a type that can be used to represent an "atlas" in the API, and (b) preventing users subverting the API by accessing the implementation objects (atlas-nodes) directly.&lt;/p&gt;
&lt;p&gt;There are features we can build on: the proposal for named item type aliases, and the sketchy definition of "external objects" in XSLT.&lt;/p&gt;
&lt;p&gt;We could handle the first part by allowing the declaration of a named item type (or alias) to specify something like visibility=closed. So the function library comes with an item type whose name is atlas:atlas, and this type name is available for use by anyone who imports the function library, but they never get to know exactly what an atlas:atlas is other than the fact that it's an item, so they can never know what other functions they might be able to call on it.&lt;/p&gt;
&lt;p&gt;But that doesn't stop them guessing (or asking, using &lt;code&gt;if ($atlas instance of map(*)&lt;/code&gt; interrogatives).&lt;/p&gt;
&lt;p&gt;To deal with that, we could consider expanding the existing half-defined concept of an "external object". XSLT 3.0 ยง24.1.3 sketches out the idea:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An implementation may allow an extension function to return an object that does not have any natural representation in the XDM data model, whether as an atomic value, a node, or a function item. For example, an extension function sql:connect might return an object that represents a connection to a relational database; the resulting connection object might be passed as an argument to calls on other extension functions such as sql:insert and sql:select.&lt;/p&gt;
&lt;p&gt;The way in which such objects are represented in the type system is &lt;a href="https://www.w3.org/TR/xslt-30/#dt-implementation-defined"&gt;implementation-defined&lt;/a&gt;. They might be represented by a completely new datatype, or they might be mapped to existing datatypes such as integer, string, or anyURI.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So &lt;code&gt;atlas&lt;/code&gt; could be an external object type. The module that implements the function library could contain private methods that wrap a map as an atlas, or that unwrap an atlas to reveal the underlying map. I think the only additional support needed is a construct to wrap a value as an encapsulated object of a given type, and to unwrap an encapsulated object to return the original value.&lt;/p&gt;
&lt;p&gt;Note: I can imagine the same mechanism being useful to handle "parcels", and no doubt we will find many other applications for it.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
