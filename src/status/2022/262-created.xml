<item>
   <title>Issue #262 created</title>
   <pubDate>2022-11-20T23:10:00Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/262</link>
   <guid>https://qt4cg.org/@qt4cg/2022/#created-262</guid>
   <description>&lt;div&gt;&lt;p&gt;[XPath 4.0] Navigation in deep-structured arrays&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;At present there is no convenient way to navigate down a deep-structured array (whose members are themselves arrays and maybe even (recursively) deep-structured arrays themselves).&lt;/p&gt;
&lt;p&gt;For example, given the array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt; [1, [2, 3], [4, [5, 6]], (7, 8, 9) ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we cannot navigate to &lt;code&gt;6&lt;/code&gt; with a single function call, nor do we have a convenient search mechanism that will give us all index(es)-paths that navigate to &lt;code&gt;6&lt;/code&gt;, in this case just the single index-path (3, 2, 2).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This proposal is to extend the &lt;strong&gt;&lt;em&gt;&lt;a href="https://qt4cg.org/pr/258/xpath-functions-40/autodiff.html#func-array-get"&gt;&lt;code&gt;array:get()&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; function and the &lt;a href="https://qt4cg.org/specifications/xquery-40/xpath-40-diff.html#id-array-lookup"&gt;&lt;strong&gt;&lt;em&gt;array lookup using function call syntax&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; to accept as their last argument not just a single integer position, but a sequence of integers.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The sequence of integer position is called &lt;strong&gt;"item-navigation-path"&lt;/strong&gt;, or simply: &lt;strong&gt;"navigation-path"&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;For the array defined above, the navigation path to the contained item &lt;code&gt;6&lt;/code&gt; is:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;(3, 2, 2)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XPath implementation&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $ar := [1, [2, 3], [4, [5, 6]], (7, 8, 9) ],
    $get := -&amp;gt; ($input as array(*), $indices as xs:integer*)
            {
              let $getHelper := -&amp;gt; ($input as array(*), $indices as xs:integer*, $self as function(*))
              {
                let $headIndex := head($indices), $restindices := tail($indices)
                  return
                    if(exists($restindices))
                      then $self($input($headIndex),$restindices, $self)
                      else if(exists($headIndex))
                             then $input($headIndex)
                             else $input
               }
              return $getHelper($input, $indices, $getHelper)
            }
  return
    $ar =&amp;gt; $get((3, 2, 2))
     (: (: Or alternatively : :) $get($ar, (3, 2, 2)) :)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the above expression is evaluated, the expected, correct result is produced:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;6&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Goals&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To allow a simple and intuitive deep-indexing navigation with a single function call.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To allow for sophisticated deep-searching functionality (like the current &lt;code&gt;array:index-where()&lt;/code&gt; and &lt;code&gt;array:index-of()&lt;/code&gt;, but not just scratching the surface) to return the navigation paths to wanted items of interest, which then could be stored, passed to other functions and easily retrieved.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Other examples&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;let $ar := [1, [2, 3], [4, [5, 6]], (7, 8, 9) ],
    $get := -&amp;gt; ($input as array(*), $indices as xs:integer*)
            {
              let $getHelper := -&amp;gt; ($input as array(*), $indices as xs:integer*, $self as function(*))
              {
                let $headIndex := head($indices), $restindices := tail($indices)
                  return
                    if(exists($restindices))
                      then $self($input($headIndex),$restindices, $self)
                      else if(exists($headIndex))
                             then $input($headIndex)
                             else $input
               }
              return $getHelper($input, $indices, $getHelper)
            }
  return
     ( $get($ar, (3, 2, 2)), $get($ar, 2), $get($ar, (3,1)),   $get($ar, (3,2)), $get($ar, ())  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the above expression is evaluated, all the expected, correct results are produced:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;6
[2,3]
4
[5,6]
[1,[2,3],[4,[5,6]],(7,8,9)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/10605892/202931815-9fd429f4-55e1-4a79-bd0a-fc6c98990393.png" alt="image"/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
