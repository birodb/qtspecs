<item>
   <title>Issue #187 created</title>
   <pubDate>2022-10-07T11:34:13Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/187</link>
   <guid>https://qt4cg.org/@qt4cg/2022/#created-187</guid>
   <description>&lt;div&gt;&lt;p&gt;Add a 'while' clause to FLWOR expressions&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;This proposal adds a new clause, the &lt;strong&gt;while&lt;/strong&gt; clause, to FLWOR expressions. I'll start with the proposal, and then give some rationale.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We add a new WhileClause which can appear anywhere a WhereClause can appear. The semantics are deliberately almost identical to the WhereClause.&lt;/p&gt;
&lt;p&gt;3.12.x While Clause&lt;/p&gt;
&lt;p&gt;[60]   	WhileClause	   ::=   	"while" ExprSingle	
A while clause serves as a filter for the tuples in its input tuple stream. The expression in the while clause, called the while-expression, is evaluated once for each of these tuples. If the effective boolean value of the while-expression is true, the tuple is retained in the output tuple stream; otherwise the tuple &lt;strong&gt;and all subsequent tuples in the stream&lt;/strong&gt; are discarded.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;p&gt;This example illustrates the effect of a while clause on a tuple stream:
Input tuple stream:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;($a = 13, $b = 11)
($a = 91, $b = 42)
($a = 17, $b = 30)
($a = 85, $b = 63)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;while clause:
&lt;code&gt;while $a &amp;gt; $b&lt;/code&gt;
Output tuple stream:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;($a = 13, $b = 11)
($a = 91, $b = 42)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following query illustrates how a while clause might be used to extract all items in an input sequence before the first one that fails to satisfy some condition. In this case it selects the leading &lt;code&gt;para&lt;/code&gt; elements in the input sequence, stopping before the first element that is not a &lt;code&gt;para&lt;/code&gt; element.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for $x in $section/*
while $x[self::para]
return $x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note:
Although the semantics are described in terms of discarding all the tuples following the first one that fails to match the condition, a practical implementation is likely to avoid evaluating those tuples, thus giving an "early exit" from the iteration performed by the FLWOR expression.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Justification&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FLWOR expressions remain the primary control construct in XQuery, despite the introduction of higher-order functions. The inability to process input selectively until some condition is true remains one of their biggest limitations. The window clause provides a workaround for some use cases, but it is very complex, and although it can partition an input sequence based on conditions found in the data, it has no direct way of stopping processing when a condition is found. Also, it only operates on input sequences, not on the tuple stream, so it isn't able to handle a composite condition involving multiple variables, for example &lt;code&gt;for $i at $p in //emp while ($i/location = 'x' and $p &amp;lt; 50) return $i&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That particular example could be written with a &lt;code&gt;where&lt;/code&gt; clause. But if a &lt;code&gt;where&lt;/code&gt; clause is used, both the human reader and the query optimiser need to do some thinking to work out that early exit is possible (once $p reaches 50, no further tuples are going to have values less than 50).&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
