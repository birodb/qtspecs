<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses in 2023</title></head><body><main><article><h1>@qt4cg statuses in 2023</h1><p>This page displays status
              updates
              about the QT4 CG project from 2023.</p><p>See also <a href="../">recent statuses</a>.</p><div class="toots">
<div class="toot" id="minutes-01-31"><h2>QT4 CG meeting 020 draft minutes<span class="toot-id"> #minutes-01-31</span></h2><div class="pubdate">31 Jan at 17:12:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/01-31">https://qt4cg.org/meeting/minutes/2023/01-31</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-330"><h2>Pull request #330 created<span class="toot-id"> #created-330</span></h2><div class="pubdate">31 Jan at 12:56:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/330">https://github.com/qt4cg/qtspecs/pull/330</a></div><details><summary>Update fn:parse-html to apply review feedback.</summary><div class="markup"><p>This is still a work in progress:</p>
<ul>
<li>[x] QT4CG-016-03: RD to add a note clarifying “known character encoding”</li>
<li>[x] QT4CG-016-04: RD to add a note clarifying the “<em>”/”</em>” html/version combination</li>
<li>[x] QT4CG-016-05: RD to add a “todo” noting the dependency on keyword arguments</li>
<li>[ ] QT4CG-016-06: RD to reword the introduction to mapping to clarify who’s doing the mapping</li>
<li>[ ] QT4CG-016-08: RD to clarify how namespace comparisons are performed.</li>
<li>[ ] QT4CG-016-09: RD to add a note stating that the local name should always be lowercase</li>
<li>[ ] QT4CG-016-10: RD to consider how to clarify parsed entity parsing.</li>
</ul>
</div></details></div>
<div class="toot" id="created-329"><h2>Issue #329 created<span class="toot-id"> #created-329</span></h2><div class="pubdate">30 Jan at 11:45:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/329">https://github.com/qt4cg/qtspecs/issues/329</a></div><details><summary>Keyword parameters: Error codes</summary><div class="markup"><p>I’ve read the current specification twice, and I have checked the existing qt4 tests, but I’m still confused by the exact meaning of the new error codes for keyword arguments, <code>XPST0141</code> and <code>XPST0142</code>. Things are getting particularly tricky if we consider partial function applications.</p>
<p>My proposal would be to simplify the current approach and:</p>
<ol>
<li>use the existing error code <code>XPST0017</code> for all cases in which a function cannot be chosen as the available arguments (both positional and keyword-based) don’t match the function definition, and</li>
<li>only raise a new error code (<code>XPST0141</code>, possibly) if a keyword argument has been specified more than once (as this can be done without checking the function definitions).</li>
</ol>
</div></details></div>
<div class="toot" id="created-328"><h2>Issue #328 created<span class="toot-id"> #created-328</span></h2><div class="pubdate">30 Jan at 10:05:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/328">https://github.com/qt4cg/qtspecs/issues/328</a></div><details><summary>Switch Cases: Lift single-item restriction on operands</summary><div class="markup"><h2>Motivation</h2>
<p><a href="https://www.w3.org/TR/xquery-31/#id-switch">XQuery switch cases</a> have a peculiar restriction: The operand of a single case must yield an empty sequence or a single item. There seem to be no (obvious) reasons why this restriction exists, so I believe we should lift it and allow arbitrary sequences.</p>
<p>A similar extension is planned for Java 12 (<a href="http://openjdk.java.net/jeps/325">JEP 325: Switch Expressions</a>). The required changes in XQuery are simpler, though, as the 3.1 grammar already supports arbitrary expressions as operands.</p>
<h2>Examples</h2>
<pre><code class="language-xquery">switch($value)
  case 1
  case 2
  case 3
  case 4
  case 5
    return 'small'
  default
    return 'big'
</code></pre>
<p>Proposed syntax:</p>
<pre><code class="language-xquery">switch($value)
  case 1 to 5
    return 'small'
  default
    return 'big'
</code></pre>
<h2>Required Changes</h2>
<p>The <a href="https://www.w3.org/TR/xquery-31/#id-switch">current matching rules</a> could be rephrased as follows:</p>
<ol>
<li>The SwitchCaseOperand is evaluated.</li>
<li>The resulting value is atomized.</li>
<li>The case matches if the value is empty and if the value of the switch expression is empty as well.</li>
<li>Otherwise, the atomized value of the switch operand expression is compared with each item of the atomized value of the SwitchCaseOperand using <code>fn:deep-equal</code>, with the default collation from the static context.</li>
</ol>
<h2>References</h2>
<ul>
<li>Original Proposal: https://github.com/expath/xpath-ng/pull/12</li>
<li>Discussion on Slack: https://xmlcom.slack.com/archives/C011NLXE4DU/p1675006336963479</li>
</ul>
</div></details></div>
<div class="toot" id="agenda-01-31"><h2>QT4 CG meeting 020 draft agenda<span class="toot-id"> #agenda-01-31</span></h2><div class="pubdate">30 Jan at 08:47:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/01-31">https://qt4cg.org/meeting/agenda/2023/01-31</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-327"><h2>Issue #327 created<span class="toot-id"> #created-327</span></h2><div class="pubdate">30 Jan at 08:42:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/327">https://github.com/qt4cg/qtspecs/issues/327</a></div><details><summary>Tokenisation</summary><div class="markup"><p>The rule in A.2</p>
<blockquote>
<p>When tokenizing, the longest possible match that is consistent with the EBNF is used.</p>
</blockquote>
<p>needs clarifying. It could be read as suggesting that if taking the longest match turns out to lead to a syntax error, the tokenisation should be re-attempted using a shorter match. I don't think that has ever been intended. So what exactly does the qualifier "that is consistent with the EBNF" actually mean?</p>
<p>Possibly related, A.2.2 Terminal Delimitation states:</p>
<blockquote>
<p>Terminal symbols that are not used exclusively in [/* ws: explicit */] productions are of two kinds: delimiting and non-delimiting.</p>
</blockquote>
<p>But (at least in the XQuery version) the list of delimiting tokens includes a number that are indeed used exclusively in ws:explicit productions, for example a number of tokens containing back-ticks, and <code>]]&gt;</code>.</p>
<p>I think we need to be clearer that tokens used in ws:explicit productions are recognised only when parsing the production that uses them. For example given the expression <code>A[B[C]]&gt;3</code>, we should not recognise <code>]]&gt;</code> as a token under the longest-token rule. I think that's probably what the "consistent with the EBNF" rule is intended to convey.</p>
</div></details></div>
<div class="toot" id="created-326"><h2>Pull request #326 created<span class="toot-id"> #created-326</span></h2><div class="pubdate">29 Jan at 22:45:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/326">https://github.com/qt4cg/qtspecs/pull/326</a></div><p>Issue 205: make support for higher-order functions mandatory</p></div>
<div class="toot" id="created-325"><h2>Issue #325 created<span class="toot-id"> #created-325</span></h2><div class="pubdate">29 Jan at 22:03:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/325">https://github.com/qt4cg/qtspecs/issues/325</a></div><details><summary>Operator precedence table needs updating</summary><div class="markup"><p>The <code>otherwise</code> and <code>-&gt;</code> operators (and maybe others) are missing from the non-normative precedence table in Appendix A.4.</p>
</div></details></div>
<div class="toot" id="created-324"><h2>Pull request #324 created<span class="toot-id"> #created-324</span></h2><div class="pubdate">29 Jan at 18:23:31 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/324">https://github.com/qt4cg/qtspecs/pull/324</a></div><details><summary>Proposed syntax and semantics for string templates</summary><div class="markup"><p>See issue #58.</p>
<p>I would recommend reviewing the XQuery version of the spec first, since it contains additional notes contrasting string templates and the existing string constructors. The section on string constructors has moved, but is unchanged except for the addition of this note.</p>
</div></details></div>
<div class="toot" id="created-323"><h2>Issue #323 created<span class="toot-id"> #created-323</span></h2><div class="pubdate">27 Jan at 21:56:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/323">https://github.com/qt4cg/qtspecs/issues/323</a></div><details><summary>add select attribute to xsl:text</summary><div class="markup"><p>Although xsl:text select="socks" would be the same as xsl:value-of select="socks" in implementation terms, users of XSLT 2 and later, even people who have been using XSLT 2 or 3 for some time, are often surprised to learn that xsl:value-of makes a text node, and that they need to use xsl:sequence to return something else.</p>
<p>So it'd be great to have them use xsl:text instead of xsl:value-of, where text nodes are wanted, because then introducing xsl:sequence is a small step.</p>
<p>Of course, beginners also often use value-of where they should be using apply-templates, e.g. to handle mixed content! But again, using xsl:text reduces that temptation.</p>
<p>We do have value templates now, <a href="xsl:text">xsl:text</a>{ .... }&lt;/xsl:text&gt;, which mitigates the need slightly, but i think only slightly, because the select= analogy is very compelling.</p>
</div></details></div>
<div class="toot" id="created-322"><h2>Issue #322 created<span class="toot-id"> #created-322</span></h2><div class="pubdate">26 Jan at 10:10:12 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/322">https://github.com/qt4cg/qtspecs/issues/322</a></div><details><summary>Map construction in XSLT: xsl:record instruction</summary><div class="markup"><p>Constructing maps in XSLT often involves code rather like this:</p>
<pre><code>            &lt;xsl:map&gt;
               &lt;xsl:map-entry key="'author'" select="string(AUTHOR)"/&gt;
               &lt;xsl:map-entry key="'title'" select="string(TITLE)"/&gt;
               &lt;xsl:map-entry key="'price'" select="xs:decimal(PRICE)"/&gt;
               &lt;xsl:map-entry key="'publisher'" select="string(../@name)"/&gt;
           &lt;/xsl:map&gt;
</code></pre>
<p>The alternative using XPath is also rather ugly:</p>
<pre><code>&lt;xsl:sequence select="map{'author': string(AUTHOR),
                                                 'title':string(TITLE), 
                                                 'price': xs:decimal(PRICE), 
                                                 'publisher':string(../@name)}"/&gt;
</code></pre>
<p>(the fact  that it is creating a map doesn't stand out; the <code>xsl:sequence</code> is a distraction because there's no sequence involved; and many users dislike long multi-line XPath expressions because of formatting problems in their editing tools)</p>
<p>I propose a new instruction xsl:record which allows:</p>
<pre><code>            &lt;xsl:record author="string(AUTHOR)"
                                title="string(TITLE)" 
                                price="xs:decimal(PRICE)" 
                                publisher="string(../@name)"/&gt;
</code></pre>
<p>This is rather like literal result elements in that the attributes are user-defined rather than system-defined. Unlike LREs, the values are general expressions rather than AVTs, because the values are not necessarily strings. The instruction can only be used where the keys (field names) take the form of NCNames.</p>
<p>If variable entries are required, or entries whose keys are not NCNames, they can appear as child instructions:</p>
<pre><code>            &lt;xsl:record author="string(AUTHOR)"
                                title="string(TITLE)" 
                                price="xs:decimal(PRICE)" 
                                publisher="string(../@name)"&gt;
              &lt;xsl:if test="@private"&gt;
                  &lt;xsl:map-entry name="'private entry'" select="true()"/&gt;
              &lt;/xsl:if&gt;
          &lt;/xsl:record&gt;
</code></pre>
<p>Follow the tradition of LREs, duplicates are resolved as "last one wins".</p>
<p>If "standard attributes" such as <code>[xsl:]version</code> are required, they must be in the XSLT namespace, as with LREs.</p>
</div></details></div>
<div class="toot" id="created-321"><h2>Issue #321 created<span class="toot-id"> #created-321</span></h2><div class="pubdate">26 Jan at 04:12:06 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/321">https://github.com/qt4cg/qtspecs/issues/321</a></div><details><summary>relax $input in fn:serialize</summary><div class="markup"><p>Relevant specifications:
https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-serialize</p>
<p>Would it be possible to relax the strictures on <code>$input</code> (first parameter) of <code>fn:serialize()</code>?</p>
<ol>
<li>The specifications do not explicitly forbid <code>map(*)</code> or <code>array(*)</code> as input, but in practice, when these are supplied, Saxon rejects them. Developers (or at least this one) who work with arrays and maps often need to render them in string output or messages, if only for diagnostics. If there is something really prohibitively wrong with those two items as input to <code>fn:serialize()</code>, then the specifications should say so.</li>
<li>Attributes are forbidden, but it is unclear why. They get serialized fine in the context of a parent, why not alone?</li>
<li>Namespace nodes are forbidden; see previous point.</li>
</ol>
<p>(No doubt there must have been discussion on points 2-3, but the rationale is not clear from the specs.)</p>
<p>Perhaps the question is that the details of what the serialization should look like is contestable. I think the answer there is simply, pick one. I think we'll happily live with whatever is chosen.</p>
<p>For the serialization of maps and arrays, I'll point as one possible model my <a href="https://github.com/textalign/TAN-2021/blob/9d2215e36da1f64bddad9daddfc5aa2242e17c81/functions/maps/TAN-fn-maps-extended.xsl#L58">tan:map-to-xml()</a> and <a href="https://github.com/textalign/TAN-2021/blob/9d2215e36da1f64bddad9daddfc5aa2242e17c81/functions/arrays/TAN-fn-arrays-extended.xsl#L66">tan:array-to-xml()</a>, which have been indispensable for daily troubleshooting.</p>
</div></details></div>
<div class="toot" id="created-320"><h2>Pull request #320 created<span class="toot-id"> #created-320</span></h2><div class="pubdate">25 Jan at 18:58:47 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/320">https://github.com/qt4cg/qtspecs/pull/320</a></div><details><summary>Issue 98 - add options parameter to fn:deep-equal</summary><div class="markup"><p>This proposal adds an options parameter to fn:deep-equal, giving much more detailed control over how the comparison is performed (while remaining backwards compatible by default).</p>
<p>This proposal is a first draft and I would request careful review, it's not one to pass through "on the nod".</p>
</div></details></div>
<div class="toot" id="created-319"><h2>Pull request #319 created<span class="toot-id"> #created-319</span></h2><div class="pubdate">25 Jan at 16:20:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/319">https://github.com/qt4cg/qtspecs/pull/319</a></div><details><summary>Issue 221: op:same-key becomes fn:atomic-equal</summary><div class="markup"><p>The proposal renames op:same-key as fn:atomic-equal, thus making it directly available to applications.</p>
</div></details></div>
<div class="toot" id="created-318"><h2>Issue #318 created<span class="toot-id"> #created-318</span></h2><div class="pubdate">25 Jan at 11:36:27 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/318">https://github.com/qt4cg/qtspecs/issues/318</a></div><details><summary>Serialization HTML/XHTML output methods: meta elements and the charset attribute</summary><div class="markup"><p>HTML5 introduces the ability to write</p>
<p><code>&lt;meta charset="utf-8"/&gt;</code></p>
<p>in place of</p>
<p><code>&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/&gt;</code></p>
<p>The serialization spec (for HTML and XHTML output methods) ignores this.</p>
<p>(a) it requires the serializer to add a <code>meta</code> element in the second form rather than the first.</p>
<p>(b) when removing existing <code>meta</code> elements, it requires the second form to be deleted, but not the first. This may result in invalid (X)HTML in which both elements are present.</p>
</div></details></div>
<div class="toot" id="closed-309"><h2>Issue #309 closed<span class="toot-id"> #closed-309</span></h2><div class="pubdate">24 Jan at 17:20:48 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/309">https://github.com/qt4cg/qtspecs/pull/309</a></div><p>Drop ternary conditionals, as agreed on 2023-01-17</p></div>
<div class="toot" id="closed-310"><h2>Issue #310 closed<span class="toot-id"> #closed-310</span></h2><div class="pubdate">24 Jan at 17:20:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/310">https://github.com/qt4cg/qtspecs/pull/310</a></div><p>Fix outstanding issues from PR 304</p></div>
<div class="toot" id="closed-312"><h2>Issue #312 closed<span class="toot-id"> #closed-312</span></h2><div class="pubdate">24 Jan at 17:20:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/312">https://github.com/qt4cg/qtspecs/pull/312</a></div><p>Minor editorial improvements</p></div>
<div class="toot" id="closed-313"><h2>Issue #313 closed<span class="toot-id"> #closed-313</span></h2><div class="pubdate">24 Jan at 17:19:16 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/313">https://github.com/qt4cg/qtspecs/pull/313</a></div><p>Issue 294: fn:remove()</p></div>
<div class="toot" id="created-317"><h2>Issue #317 created<span class="toot-id"> #created-317</span></h2><div class="pubdate">24 Jan at 17:16:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/317">https://github.com/qt4cg/qtspecs/issues/317</a></div><details><summary>fn:format-integer: $lang → $language ?</summary><div class="markup"><p>A minor inconsistency in the XQFO specification: The third parameter of <code>fn:format-integer</code> is named <code>$lang</code>…</p>
<p>https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-format-integer</p>
<p>…whereas all other language parameters are named <code>$language</code>.</p>
</div></details></div>
<div class="toot" id="minutes-01-24"><h2>QT4 CG meeting 019 draft minutes<span class="toot-id"> #minutes-01-24</span></h2><div class="pubdate">24 Jan at 17:11:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/01-24">https://qt4cg.org/meeting/minutes/2023/01-24</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-316"><h2>Issue #316 created<span class="toot-id"> #created-316</span></h2><div class="pubdate">23 Jan at 16:23:37 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/316">https://github.com/qt4cg/qtspecs/issues/316</a></div><details><summary>Function fn:differences</summary><div class="markup"><p>I didn't see any issues thread devoted <code>fn:differences()</code>, so am opening this one. Please respond with xrefs to anything relevant.</p>
<p>Draft here:
https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-differences</p>
<p>IMO, this function seems overly complicated for both users and implementors. The specs provide difficult reading. But it is the first function to try to address the desideratum for differencing. Something like it is needed methinks.</p>
<p>My suggestion would be to simplify the function as a straightforward string comparison, i.e., change the signature to something like <code>fn:differences($input1 as xs:string, $input2 as xs:string) as OUTPUT</code> where <code>OUTPUT</code> is either a tree structure (like the output of <code>fn:analyze-string()</code>) or a sequence of records (e.g., <code>(is-in-1 as xs:boolean, is-in-2 as xs:boolean, fragment as xs:string)</code>).</p>
<p>Such a change would make the function more tractable for both users and implementers. The user, would need to cast each sequence to a string, and in so doing will be able to (be compelled to) make fine-grained decisions on things such as normalization. Processor implementers have far simpler input, and they can choose the difference algorithm that makes best sense at the moment.</p>
<p>One counterargument might be that the resultant output would be difficult to correlate to the original sequences. Ostensibly, one wants to do things such as decide whether to drop certain items in sequence 1 or sequence 2. My response is that the current draft results in output that suffers from the same problem. Navigating the map to correlate it to the original sequence sounds daunting. With my suggestion, there are ways around this, through auxiliary functions or arity expansions that normalize the output.</p>
<p>But I don't want to get postprocessing output here, which would be tangential to the main question, i.e., how <code>fn:differences()</code> should be constructed in a way conducive to both users and implementers.</p>
</div></details></div>
<div class="toot" id="closed-311"><h2>Issue #311 closed<span class="toot-id"> #closed-311</span></h2><div class="pubdate">23 Jan at 11:46:17 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/311">https://github.com/qt4cg/qtspecs/pull/311</a></div><p>Stylesheet fix to mark optional fields in record definitions</p></div>
<div class="toot" id="created-315"><h2>Issue #315 created<span class="toot-id"> #created-315</span></h2><div class="pubdate">18 Jan at 14:58:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/315">https://github.com/qt4cg/qtspecs/issues/315</a></div><details><summary>fn:transform inconsistency: initial-mode</summary><div class="markup"><p>The <code>fn:transform</code> specification in F+O says that if no initial-mode is supplied, the unnamed mode is used.</p>
<p>The XSLT 3.0 specification says that if no initial mode is supplied, then the default mode is used if one has been specified, or the unnamed mode is used if not.</p>
<p>I think the XSLT 3.0 spec should win here: it makes more sense if a default has been declared that it should actually be used.</p>
<p>(Thanks to Amanda Galtman for pointing this out.)</p>
</div></details></div>
<div class="toot" id="created-314"><h2>Issue #314 created<span class="toot-id"> #created-314</span></h2><div class="pubdate">18 Jan at 09:24:52 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/314">https://github.com/qt4cg/qtspecs/issues/314</a></div><details><summary>Basic Operations on Maps and Arrays</summary><div class="markup"><h1>Manipulating Arrays and Maps</h1>
<p>This is an outline of proposed new facilities designed to make processing of maps and arrays easier. The basic facilities needed for transformation of maps and arrays are the ability to decompose them into their parts, manipulate the parts, and the compose new arrays and maps from these parts.</p>
<p>Further background is in my 2022 Balisage paper, https://balisage.net/Proceedings/vol27/html/Kay01/BalisageVol27-Kay01.html</p>
<p>This proposal considers only the "shallow" operations on maps and arrays. Further proposals for deep search and update of nested structures are to be expected.</p>
<h2>Basics</h2>
<p>A map entry is an item used to represent a key-value pair in a map; it is an item of type <code>record(key as xs:anyAtomicType, value as item()*)</code>, aliased in this proposal as <code>type(map-entry)</code>.</p>
<p>Note: <em>an alternative representation for key-value pairs is as a singleton map, and that's the representation used by the existing map:entry() function and by the xsl:map-entry instruction. A representation as <code>record(key, value)</code> is rather more convenient to enable extraction of the key and value, but does create some compatibility issues...</em></p>
<p>An array entry is an item used to represent a member of an array; it is an item of type <code>record(value as item()*)</code>, aliased in this proposal as <code>type(array-entry)</code>.</p>
<h2>Decomposing Maps and Arrays</h2>
<p>The function <code>map:entries($map)</code> returns a sequence of map entries, in unpredictable order, representing the contents of the supplied map. It is equivalent to <code>map:for-each($map, -&gt;($k, $v){map:entry($k, $v)})</code>.</p>
<p>The function <code>array:entries($array)</code> returns a sequence of array entries, in array order, representing the members of the supplied array. It is equivalent to <code>array:for-each($array, -&gt;($v){array:entry($v)})</code>.</p>
<h2>Constructing Maps and Arrays</h2>
<p>The function <code>map:of($entries as type(map-entry)*) as map(*)</code> constructs a map from a sequence of map entries. A second parameter, <code>$options</code>, is available to control handling of duplicates, as with <code>map:merge()</code>. The function is equivalent to <code>map:merge($entries!map{'key':?key, 'value':?value})</code>.</p>
<p>The function <code>array:of($entries as type(array-entry)*) as array(*)</code> constructs an array from a sequence of array entries. It is equivalent to <code>array:fold-left($entries, [], array:append#2)</code>.</p>
<p>The function <code>map:entry($key, $value) as type(map-entry)</code> is equivalent to <code>map{'key':$key, 'value':$value}</code>. <em>Problem: we already have a function map:entry() in 3.1 that does something different. Need to change the terminology...</em></p>
<p>The function <code>array:entry($value) as type(array-entry)</code> is equivalent to <code>map{'value':$value}</code>.</p>
<h2>Filtering Maps and Arrays</h2>
<p>The construct <code>$map?[PREDICATE]</code> is equivalent to <code>map:of(map:entries($map)[PREDICATE])</code>. For example, given a map in which the keys are dates, <code>$map?[year-from-date(?key)=2023]</code> returns a map containing those entries in which the key is a date in 2023.</p>
<p>The construct <code>$array?[PREDICATE]</code> is equivalent to <code>array:of(array:entries($array)[PREDICATE])</code>. For example, <code>$array?[1]</code> selects the first item in the array (as a single-member array), while <code>$array?[exists(?value)]</code> returns an array containing all those entries in the input array that are not empty. If <code>$array</code> is an array of maps, then <code>$array?[?value?name='John']</code> selects those members of the array that are maps having <code>?name='John'</code>.</p>
<h2>Mapping Maps and Arrays</h2>
<p>The construct <code>$map!!EXPR</code> evaluates <code>EXPR</code> once for each entry in <code>$map</code> and returns the result as a flattened sequence. For example <code>map:of($map!!map:entry(?key, ?value+1))</code> returns a map in which each value has been incremented by one.</p>
<p>The construct <code>$array!!EXPR</code> evaluates <code>EXPR</code> once for each entry in <code>$array</code>, and returns the result as a flattened sequence. For example, <code>array:of($array!!array:entry(?value+1))</code> returns an array in which every value has been incremented by one.</p>
<h2>FLWOR Expressions</h2>
<p>The for-member clause <code>for member $m in $array</code> is equivalent to <code>for $sys:var in array:entries($array) let $m := $sys:var?value</code>.</p>
<p>The for-entry clause <code>for entry ($k, $v) in $map</code> is equivalent to <code>for $sys:var in map:entries($map) let $k := $sys:var?key, $v := $sys:var?value</code>.</p>
<h2>XSLT</h2>
<p>Iteration over maps and arrays is achieved using <code>&lt;xsl:for-each select="array:entries()"&gt;</code> and <code>&lt;xsl:for-each select="map:entries()"&gt;</code> directly.</p>
<p>Construction of maps uses the existing instructions <code>&lt;xsl:map&gt;</code> and <code>&lt;xsl:map-entry&gt;</code>. There is an inconvenience here in that the <code>&lt;xsl:map-entry&gt;</code> instruction returns a singleton map (<code>map{key:value}</code>) rather than a map entry as defined in this proposal (<code>map{'key':key, 'value':value}</code>)..</p>
<p>Construction of arrays uses the new instructions <code>&lt;xsl:array&gt;</code> and <code>&lt;xsl:array-entry&gt;</code>. The <code>xsl:array-entry</code> instruction is defined to construct an array entry as defined in this proposal.</p>
<h2>Use Cases</h2>
<p>To be supplied.</p>
</div></details></div>
<div class="toot" id="created-313"><h2>Pull request #313 created<span class="toot-id"> #created-313</span></h2><div class="pubdate">17 Jan at 22:53:06 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/313">https://github.com/qt4cg/qtspecs/pull/313</a></div><details><summary>Issue 294: fn:remove()</summary><div class="markup"><p>Allow remove() to remove several items, aligning it with array:remove() and map:remove()</p>
</div></details></div>
<div class="toot" id="created-312"><h2>Pull request #312 created<span class="toot-id"> #created-312</span></h2><div class="pubdate">17 Jan at 22:25:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/312">https://github.com/qt4cg/qtspecs/pull/312</a></div><details><summary>Minor editorial improvements</summary><div class="markup"><ul>
<li>Issue 300 (clarification about results being normalized)</li>
<li>Action QT4CG-018-02 (explaining signature notation)</li>
<li>Action QT4CG-018-04 (explaining numeric predicates on ancestor unions)</li>
</ul>
</div></details></div>
<div class="toot" id="created-311"><h2>Pull request #311 created<span class="toot-id"> #created-311</span></h2><div class="pubdate">17 Jan at 21:39:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/311">https://github.com/qt4cg/qtspecs/pull/311</a></div><p>Stylesheet fix to mark optional fields in record definitions</p></div>
<div class="toot" id="created-310"><h2>Pull request #310 created<span class="toot-id"> #created-310</span></h2><div class="pubdate">17 Jan at 21:27:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/310">https://github.com/qt4cg/qtspecs/pull/310</a></div><details><summary>Fix outstanding issues from PR 304</summary><div class="markup"><p>See https://github.com/qt4cg/qtsp…ecs/pull/304#issuecomment-1378532583 - but excluding item 3 because that's a stylesheet change.</p>
</div></details></div>
<div class="toot" id="created-309"><h2>Pull request #309 created<span class="toot-id"> #created-309</span></h2><div class="pubdate">17 Jan at 19:20:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/309">https://github.com/qt4cg/qtspecs/pull/309</a></div><details><summary>Drop ternary conditionals, as agreed on 2023-01-17</summary><div class="markup"><p>We agreed today to drop ternary conditional expressions from the proposal; this PR implements that change.</p>
</div></details></div>
<div class="toot" id="minutes-01-17"><h2>QT4 CG meeting 018 draft minutes<span class="toot-id"> #minutes-01-17</span></h2><div class="pubdate">17 Jan at 16:15:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/01-17">https://qt4cg.org/meeting/minutes/2023/01-17</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-286"><h2>Issue #286 closed<span class="toot-id"> #closed-286</span></h2><div class="pubdate">17 Jan at 17:14:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/286">https://github.com/qt4cg/qtspecs/pull/286</a></div><p>Spec changes to allow child::(a|b|c) - Issue 107</p></div>
<div class="toot" id="closed-290"><h2>Issue #290 closed<span class="toot-id"> #closed-290</span></h2><div class="pubdate">17 Jan at 17:14:01 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/290">https://github.com/qt4cg/qtspecs/pull/290</a></div><p>Fix issue #18 (function type hierarchy)</p></div>
<div class="toot" id="closed-288"><h2>Issue #288 closed<span class="toot-id"> #closed-288</span></h2><div class="pubdate">17 Jan at 17:13:36 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/288">https://github.com/qt4cg/qtspecs/issues/288</a></div><p>Error in fn:path specification</p></div>
<div class="toot" id="closed-291"><h2>Issue #291 closed<span class="toot-id"> #closed-291</span></h2><div class="pubdate">17 Jan at 17:13:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/291">https://github.com/qt4cg/qtspecs/issues/291</a></div><p>DTD validity of F&amp;O spec</p></div>
<div class="toot" id="closed-304"><h2>Issue #304 closed<span class="toot-id"> #closed-304</span></h2><div class="pubdate">17 Jan at 17:13:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/304">https://github.com/qt4cg/qtspecs/pull/304</a></div><p>Mike's content changes from PR 292</p></div>
<div class="toot" id="closed-284"><h2>Issue #284 closed<span class="toot-id"> #closed-284</span></h2><div class="pubdate">17 Jan at 17:12:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/284">https://github.com/qt4cg/qtspecs/pull/284</a></div><p>Add grammar for "if (test) then {expr}" with no else</p></div>
<div class="toot" id="created-308"><h2>Pull request #308 created<span class="toot-id"> #created-308</span></h2><div class="pubdate">15 Jan at 17:05:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/308">https://github.com/qt4cg/qtspecs/pull/308</a></div><details><summary>Improve the legends in the diagrams</summary><div class="markup"><p>This PR completes my action QT4CG-015-03: NW to make sure the direction of the arrow is in the legends</p>
<p>I also made sure the legends aren't too wide. I still have more work to do for the other actions.</p>
</div></details></div>
<div class="toot" id="agenda-01-17"><h2>QT4 CG meeting 018 draft agenda<span class="toot-id"> #agenda-01-17</span></h2><div class="pubdate">15 Jan at 15:30:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/01-17">https://qt4cg.org/meeting/agenda/2023/01-17</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="closed-306"><h2>Issue #306 closed<span class="toot-id"> #closed-306</span></h2><div class="pubdate">15 Jan at 16:17:10 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/306">https://github.com/qt4cg/qtspecs/pull/306</a></div><p>fn:char - editors actions from 2023-01-10</p></div>
<div class="toot" id="created-307"><h2>Issue #307 created<span class="toot-id"> #created-307</span></h2><div class="pubdate">15 Jan at 15:42:30 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/307">https://github.com/qt4cg/qtspecs/issues/307</a></div><details><summary>Parsing and building URIs comments and queries</summary><div class="markup"><ol>
<li>fn:build-uri states:</li>
</ol>
<blockquote>
<p>If the scheme key is present in the map, the URI begins with the value of that key concatenated with //, otherwise it begins //.</p>
</blockquote>
<p>a. Shouldn't the concatenation be <code>://</code> so e.g. <code>http</code> becomes <code>http://</code>?
b. How are non-heirarchical schemes handled like <code>urn</code>, and <code>mailto</code>?</p>
<ol start="2">
<li>RFC 3986 allows IPv6 and IPvFuture addresses that contain <code>:</code> characters, e.g. <code>http://[::1]:80</code>.</li>
</ol>
<p>My understanding of fn:parse-uri is that this will fail to parse.</p>
<ol start="3">
<li>RFC 3986 states that for userinfo, the <code>user:password</code> form is deprecated.</li>
</ol>
<p>Browsers will reject this due to the security risk, and the RFC suggests that applications should not render the password (the part after the <code>:</code>) in clear text. -- Should fn:build-uri follow suite, or (along with fn:parse-uri) have an option to control the behaviour (keep, remove, invalid), where if the option is invalid, it will throw an fn:error?</p>
<ol start="4">
<li>RFC 3986 suggests that the port should be omitted if it matches the default for the scheme</li>
</ol>
<p>Should fn:build-uri have this behaviour?</p>
</div></details></div>
<div class="toot" id="created-306"><h2>Pull request #306 created<span class="toot-id"> #created-306</span></h2><div class="pubdate">10 Jan at 21:23:26 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/306">https://github.com/qt4cg/qtspecs/pull/306</a></div><details><summary>fn:char - editors actions from 2023-01-10</summary><div class="markup"><p>Changes to the new fn:char function (issue #121) as follows:</p>
<ul>
<li>Action QT4CG-017-01 clarifies the definition of formats #nnn and #xnnn.</li>
<li>Action QT4CG-017-02 changes the order of the rules</li>
<li>In discussion it was asked whether any HTML5 entity names refer to strings comprising more than one character. On investigation it appears that they do, and the spec has been revised to allow for this.</li>
<li>added history/status information</li>
</ul>
</div></details></div>
<div class="toot" id="minutes-01-10"><h2>QT4 CG meeting 017 draft minutes<span class="toot-id"> #minutes-01-10</span></h2><div class="pubdate">10 Jan at 16:20:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/01-10">https://qt4cg.org/meeting/minutes/2023/01-10</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-305"><h2>Issue #305 created<span class="toot-id"> #created-305</span></h2><div class="pubdate">09 Jan at 17:50:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/305">https://github.com/qt4cg/qtspecs/issues/305</a></div><details><summary>parse-xml() and whitespace stripping</summary><div class="markup"><p>There seems to be nothing in either the XSLT spec or in F+O that says explicitly whether stylesheet-defined space stripping rules (xsl:strip-space and xsl:preserve-space) apply to documents loaded using <code>fn:parse-xml</code> (or, by extension, <code>parse-html</code>).</p>
<p>The spec says that these rules apply to "source trees" defined as "any tree provided as input to the transformation. This includes the document containing the [global context item] if any, documents containing nodes present in the [initial match selection], documents containing nodes supplied as the values of [stylesheet parameters], documents obtained from the results of functions such as [document], [doc], and [collection]...".</p>
<p>I guess one reasonable interpretation is that the "such as" includes <code>parse-xml()</code>. But it goes rather against the grain that the behaviour of parse-xml() should be affected by the containing stylesheet declarations, when there is no mention of such a context-dependency in the function specification; in this, parse-xml() is rather different from doc() which deliberately says very little about how the XDM instance returned relates to the URI supplied as input.</p>
</div></details></div>
<div class="toot" id="closed-292"><h2>Issue #292 closed<span class="toot-id"> #closed-292</span></h2><div class="pubdate">09 Jan at 09:43:27 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/292">https://github.com/qt4cg/qtspecs/pull/292</a></div><p>Merge signatures with optional params</p></div>
<div class="toot" id="created-304"><h2>Pull request #304 created<span class="toot-id"> #created-304</span></h2><div class="pubdate">09 Jan at 09:32:41 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/304">https://github.com/qt4cg/qtspecs/pull/304</a></div><details><summary>Mike's content changes from PR 292</summary><div class="markup"><p>I teased apart some of the omnibus PR #292. I've commited the schema and stylesheet changes. This PR covers the remaining prose changes.</p>
<p>Mike writes:</p>
<blockquote>
<p>I regret that this has turned into a bit of an omnibus PR. The main changes are:</p>
<ul>
<li>Fix validity issues with the function catalog and its schema (Issue 291)</li>
<li>Convert all functions to use a single signature with optional parameters (Issue 70)</li>
<li>Extend the function catalog to handle record definitions (Issue 257)</li>
<li>Fix the (trivial) bug with properties of fn:path (Issue 288)</li>
<li>Add introductory text concerning the handling of operators (Issue 35)</li>
</ul>
</blockquote>
<p>Fix #291
Fix #70
Fix #257
Fix #288
Fix #35</p>
</div></details></div>
<div class="toot" id="closed-303"><h2>Issue #303 closed<span class="toot-id"> #closed-303</span></h2><div class="pubdate">09 Jan at 07:38:47 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/303">https://github.com/qt4cg/qtspecs/pull/303</a></div><p>Mike's proposed schema and stylesheet changes</p></div>
<div class="toot" id="created-303"><h2>Pull request #303 created<span class="toot-id"> #created-303</span></h2><div class="pubdate">09 Jan at 07:32:02 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/303">https://github.com/qt4cg/qtspecs/pull/303</a></div><details><summary>Mike's proposed schema and stylesheet changes</summary><div class="markup"><p>These are the schema and stylesheet changes from PR #292. They don't break the build and on casual inspection they seem fine, so I'm just going to accept them.</p>
</div></details></div>
<div class="toot" id="agenda-01-10"><h2>QT4 CG meeting 017 draft agenda<span class="toot-id"> #agenda-01-10</span></h2><div class="pubdate">06 Jan at 16:02:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/01-10">https://qt4cg.org/meeting/agenda/2023/01-10</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-300"><h2>Issue #300 created<span class="toot-id"> #created-300</span></h2><div class="pubdate">06 Jan at 16:19:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/300">https://github.com/qt4cg/qtspecs/issues/300</a></div><details><summary>[F+O] Ambiguity regarding Unicode normalization (editorial)</summary><div class="markup"><p>In §1.7.1 the paragraph</p>
<blockquote>
<p>Unless explicitly stated, the xs:string values returned by the
functions in this document are not normalized in the sense of
[Character Model for the World Wide Web 1.0: Fundamentals].</p>
</blockquote>
<p>is a little bit ambiguous for my taste. By "are not normalized" it means "no action is taken to normalize the strings", it doesn't mean "the strings will not be in normalized form".</p>
<p>I suggest: "Unless explicitly stated, the functions in this document operate on strings as sequences of codepoints and do not attempt to convert input strings, or produce output strings, in Unicode normalized form. Unicode normalization occurs only when explicitly requested, for example by use of the <code>fn:normalize-unicode</code> function."</p>
<p>At the same time we might update the reference to point to "Character Model for the World Wide Web: String Matching", revised in 2021, though it is still only a Working Group Note. See https://www.w3.org/TR/charmod-norm/#unicodeNormalization</p>
</div></details></div>
<div class="toot" id="closed-281"><h2>Issue #281 closed<span class="toot-id"> #closed-281</span></h2><div class="pubdate">02 Jan at 18:12:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/281">https://github.com/qt4cg/qtspecs/issues/281</a></div><p>XPath: Short-circuiting Functions and Lazy Evaluation Hints</p></div>
<div class="toot" id="created-299"><h2>Issue #299 created<span class="toot-id"> #created-299</span></h2><div class="pubdate">02 Jan at 18:08:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/299">https://github.com/qt4cg/qtspecs/issues/299</a></div><details><summary>Short-circuiting functions, function-arity guards and lazy hints</summary><div class="markup"><h1><strong>I. Shortcutting and lazy hints</strong></h1>
<p>Let us have this expression:</p>
<pre><code class="language-xq">let $f := function($arg1 as item()*, $arg2 as item()*) as function(item()*) as item()*
             {  (: Some code here :) }
  return
    $f($x) ($y)
</code></pre>
<p>Evaluating&nbsp;<strong><code>$f($x)</code></strong>&nbsp;produces a function. The&nbsp;<strong>actual arity</strong>&nbsp;of this resulting function can be any number&nbsp;<strong><code>N &gt;= 0</code></strong> :</p>
<ul>
<li>
<p>If&nbsp;<strong><code>N &gt; 1</code></strong>&nbsp;there would be arity mismatch error, as only one argument&nbsp;<code>$y</code>&nbsp;is provided in the expression.</p>
</li>
<li>
<p>If&nbsp;<strong><code>N = 1</code></strong>&nbsp;the final function call can be evaluated, and the argument&nbsp;<code>$y</code>   must be evaluated,  or</p>
</li>
<li>
<p><strong>If <code>N = 0</code>, then  <code>$y</code> is unneeded and can safely be ignored</strong> according to the updated <strong>“<a href="https://qt4cg.org/pr/279/xquery-40/xpath-40.html#id-coercion-rules">Coercion Rules / Function Coercion</a>”</strong> in Xpath 4.0.</p>
</li>
</ul>
<p><strong>Because a possibility exists to be able to ignore the evaluation of&nbsp;<code>$y</code>, it is logical to delay the evaluation of&nbsp;<code>$y</code>&nbsp;until the actual arity of&nbsp;<code>$f($x)</code>&nbsp;is known</strong>.</p>
<p>The current XPath 4.0 evaluation rules do not require an implementation to base its decision whether or not to evaluate&nbsp;<code>$y</code> on the actual arity of the function produced by <code>$f($x)</code>, thus at present an implementation could decide to evaluate <code>$y</code> regardless of the actual arity of the function produced by <code>$f($x)</code>.</p>
<p><strong>This is where a&nbsp;<em>lazy</em>&nbsp;hint comes</strong>: it indicates to the XPath processor that <em><strong>it is logical to make the decision about evaluation of&nbsp;<code>$y</code>&nbsp;based on the actual arity of the function returned by&nbsp;<code>$f($x)</code></strong></em>.</p>
<p>A rewrite of the above expression using a <strong><em><em>lazy</em></em></strong>&nbsp;hint looks like this:</p>
<pre><code class="language-xq">let $f := function($arg1 as item()*, $arg2 as item()*) as function(item()*) as item()*
             {  (: Some code here :) }  
  return
    $f($x) (lazy $y)
</code></pre>
<p>Here is one example of a function with short-cutting and calling it with a <strong><em>lazy</em></strong> hint:</p>
<pre><code class="language-xq">let $fAnd := function($x as xs:boolean, $y as xs:boolean) as xs:boolean
             {
                let $partial := function($x as xs:boolean) as function(xs:boolean) as  xs:boolean
                                {
                                  if(not($x)) then -&gt;(){false()}
                                              else -&gt;($t) {$t}
                                }
                 return $partial($x)($y)
             }
  return
     $fAnd($x (: possibly false() :), lazy&nbsp;$SomeVeryComplexAndSlowComputedExpression)
</code></pre>
<p><strong>Without the <strong><em>lazy</em></strong>&nbsp;hint in the above example, it is perfectly possible that an XPath implementation, unrestricted by the current rules, would evaluate <em><code>$SomeVeryComplexAndSlowComputedExpression</code></em> - something that is unneeded and could be avoided completely</strong>.</p>
<h2>Formal syntax and semantics</h2>
<ol>
<li>
<p>The <strong><em>lazy</em></strong> keyword should immediately precede any argument in a function call. If specified, it means that <strong><em>it is logical to make the decision about evaluation of this argument based on the actual arity of the function in this function call</em></strong>.</p>
<p>Based on this definition, it follows that <strong><em><code>lazy $argK</code></em></strong> implies <strong><em>lazy</em></strong> for all arguments following <code>$argK</code> in the function call. Thus specifying more than one <strong><em>lazy</em></strong> hint within a given function call is redundant and an implementation may report this redundancy to the user.</p>
<p>The scope of a <strong><em>lazy</em></strong> keyword specified on an argument is this and all following arguments of (only) the current function call.</p>
</li>
<li>
<p>It is possible to specify a <strong><em>lazy</em></strong> keyword that is in force for the respective argument(s) of all function calls of the given function. To do this, the <strong><em>lazy</em></strong> keyword must  be  specified immediately preceding a parameter name in the function definition of that function.</p>
<p>For example, if the function <strong><code>$f</code></strong> is specified as:</p>
<pre><code class="language-xq">let $f := function($arg1 as item()*, lazy $arg2 as item()*, $arg3 as item()*, $arg4 as item()* ) 
          { (: some code here:) }
  return
     $someExpression
</code></pre>
<p>Then any call of <strong><code>$f</code></strong> in its definition scope that has the form:</p>
<pre><code class="language-xq">$f($x, $y, $z, $t)
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-xq">$f($x, lazy $y, $z, $t)
</code></pre>
</li>
<li>
<p>It is possible to specify the <strong><em>lazy</em></strong> keyword immediately preceding a function definition. This instructs the XPath processor that any call of this function is only necessary to be evaluated if the function is actually called during the evaluation of the expression that contains this function call.</p>
<p>For example:</p>
<pre><code class="language-xq">let $complexComputation := lazy function($x, $y) {$x + $y}, (: Make it as complex as you want ... :)
     $someCondition := function()
        {
            let $date := current-date()
              return
                  month-from-date($date) eq 2
                and 
                 day-from-date($date) eq 29 
       }
  return if($someCondition()) 
           then $complexComputation(2, 3)
           else 0
</code></pre>
<p>Specifying the <strong><em>lazy</em></strong> keyword in the function definition for <code>$complexComputation</code> can save significant computing resources, because the programmer knows that <code>$someCondition()</code> is true during only a single day in any 4-years period.</p>
</li>
</ol>
<h1><strong>II.fn:lazy</strong></h1>
<h2>Summary</h2>
<p>Applied on a single argument that can be any <em>expression</em>. Lazily returns its argument <em>expression</em>.</p>
<h2>Signature</h2>
<pre><code class="language-xq">lazy fn:lazy( 
        $expression as item()*
) as item()*
</code></pre>
<h2>Properties</h2>
<p>This function is <strong><em><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#dt-deterministic">deterministic</a></em></strong>, <strong><em><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#dt-context-independent">context-independent</a></em></strong>, <strong><em><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#dt-focus-independent">focus-independent</a></em></strong></p>
<h2>Rules</h2>
<p>The semantics of the function is strictly defined below:</p>
<pre><code class="language-xq">let $lazyFunction := lazy fn:identity#1
   return
      (: AnyExpression here :)
</code></pre>
<p>Any expression <strong><code>Q</code></strong> of the form:</p>
<p><strong><em><code>Q(E1, lazy(E2))</code></em></strong></p>
<p>where <strong><code>E1</code></strong> and <strong><code>E2</code></strong> are subexpressions of <strong><code>Q</code></strong>, must be evaluated by the Processor in two steps:</p>
<ol>
<li>
<p>Substitute the expression</p>
<p><strong><em><code>Q(E1, lazy(E2))</code></em></strong></p>
<p>with:</p>
<p><strong><em><code>Q(E1, ?) (lazy E2)</code></em></strong></p>
</li>
<li>
<p>Evaluate the latter according to the rules for a <strong><em>lazy</em></strong> argument</p>
</li>
</ol>
<h2>Example</h2>
<p>We can use almost the same example as above, but here <code>$complexComputation</code> is defined without the <strong><em>lazy</em></strong> keyword and thus is not a <strong><em>lazy</em></strong> function. To have <code>$complexComputation</code> evaluated lazily, we call the <code>lazy()</code> function, passing <code>$complexComputation</code>  to it:</p>
<pre><code class="language-xq">let $complexComputation := (: no lazy here :) function($x, $y) {$x + $y}, (: Make it as complex as you want ... :)
     $someCondition := function()
        {
            let $date := current-date()
              return
                  month-from-date($date) eq 2
                and 
                 day-from-date($date) eq 29 
       }
  return 
        $someCondition() and lazy( $complexComputation(2, 3))
</code></pre>
<p>Here the expression <strong><code>Q</code></strong> is:</p>
<p><strong><em><code>$someCondition() and lazy( $complexComputation(2, 3))</code></em></strong></p>
<p>This  is the same as:</p>
<p><strong><em><code>fn:op("and")($someCondition(), lazy( $complexComputation(2, 3))</code></em></strong></p>
<p>According to the Rules above, the processor converts this to:</p>
<p><strong><em><code>fn:op("and")($someCondition(), ?) (lazy( $complexComputation(2, 3)) )</code></em></strong></p>
<p><code>$someCondition()</code> is evaluated and if its value is <code>false()</code>,   then the expression to be evaluated is:</p>
<p><strong><em><code>fn:op("and")(false(), ?) (lazy( $complexComputation(2, 3)) )</code></em></strong></p>
<p>As <strong><em><code>fn:op("and")(false(), ?)</code></em></strong> by definition is <strong><em><code>function() {false()}</code></em></strong>. then the final result <strong><code>false()</code></strong> is produced and the unnecessary argument <strong><em><code>$complexComputation(2, 3)</code></em></strong> is not evaluated at all.</p>
<h1><strong>III. A function's arity is a guard for its arguments</strong></h1>
<p>Let us have a  function <strong><code>$f</code></strong> defined as below:</p>
<pre><code class="language-xq">let $f := function($arg1 as item()*, $arg2 as item()*, …, $argN as item()*)
   as function(item()*, item()*, …, item()*) as item()*
     {
       if($cond0($arg1))       then -&gt; () { 123 }
        else if($cond1($arg1)) then -&gt; ($Z1 as item()*) {$Z1}
        else if($cond2($arg1)) then -&gt; ($Z1 as item()*, $Z2 as item()*) {$Z1 + $Z2}
        (:    .        .        .        .         .        .        .         .  :)
        else if($condK($arg1)) then -&gt; ($Z1 as item()*, $Z2 as item()*, …, $Zk as item()*)
                                       {$Z1 + $Z2 + … + $Zk}
        else ()
     }
  return
     $f($y1, $y2, …, $yN) ($z1, $z2, …, $zk)
</code></pre>
<p>A call to <strong><code>$f</code></strong> returns a function whose arity may be any of the numbers: 0, 1, …, K.</p>
<p>Depending on the arity of the returned function (0, 1, …, K), the last (K, K-1,  K-2, …, 2, 1, 0) arguments of the function call:</p>
<p><strong><em><code>$f($y1, $y2,  .  .  . , $yN) ($z1, $z2, .  .  . , $zk)</code></em></strong></p>
<p><strong>are unneeded and it is logical that they would not need to be evaluated</strong>.</p>
<p><strong>So, the actual arity of the result of calling <strong><code>$f</code></strong> is a guard for the arguments of a call to this function-result</strong>.</p>
<p>Thus, one more bullet needs to be added to [2.4.5 Guarded Expressions] https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-guarded-expressions), specifying an additional guard-type:</p>
<ul>
<li>In an expression of the type <code>E(A1, A2, ..., AN)</code> any of the arguments <code>A</code><sub>K</sub> is guarded by the condition
<code>actual-arity(E) ge K</code>. This rule has the consequence that if the actual arity of <code>E()</code> is less than <code>K</code> then if any argument <code>Am</code> (where <code>m &gt;= K</code>) is evaluated, this must not raise a dynamic error. An implementation may base on the actual arity of <code>E()</code> its decision for the evaluation of the arguments.</li>
</ul>
</div></details></div>
<div class="toot" id="created-298"><h2>Issue #298 created<span class="toot-id"> #created-298</span></h2><div class="pubdate">02 Jan at 15:36:58 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/298">https://github.com/qt4cg/qtspecs/issues/298</a></div><details><summary>Abstract supertype for map and array</summary><div class="markup"><p>I've been wondering whether there would be any mileage in introducing an abstract super type for map() and array(), perhaps called lookup(). This would basically treat an array as a map with integer keys.</p>
<p>This would allow a cleaner type signature for map:find() and any future functions such as xx:search() that work both on maps and arrays. It might simplify the description of the lookup operator "?". For functions that already exist in both the map and array namespaces, such as get(), we could introduce a unified function in the fn namespace with the cosmetic benefit of reducing the need for namespace prefixes and namespace declarations.</p>
<p>I'm still keen to find a better way of doing iteration, filtering, mapping, and construction of maps and arrays, and I think this might be a useful stepping stone.</p>
</div></details></div></div></article></main></body></html>