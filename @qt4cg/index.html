<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a></p><div class="toots">
<div class="toot" id="agenda-02-28"><h2>QT4 CG meeting 024 draft agenda<span class="toot-id"> #agenda-02-28</span></h2><div class="pubdate">24 Feb at 08:25:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/02-28">https://qt4cg.org/meeting/agenda/2023/02-28</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="closed-352"><h2>Issue #352 closed<span class="toot-id"> #closed-352</span></h2><div class="pubdate">22 Feb at 21:24:40 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/352">https://github.com/qt4cg/qtspecs/issues/352</a></div><p>The @array attribute of xsl:for-each-group is no more</p></div>
<div class="toot" id="closed-354"><h2>Issue #354 closed<span class="toot-id"> #closed-354</span></h2><div class="pubdate">22 Feb at 10:08:23 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/354">https://github.com/qt4cg/qtspecs/pull/354</a></div><p>Combine multiple signatures of XSLT functions to use defaults</p></div>
<div class="toot" id="closed-353"><h2>Issue #353 closed<span class="toot-id"> #closed-353</span></h2><div class="pubdate">22 Feb at 10:07:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/353">https://github.com/qt4cg/qtspecs/pull/353</a></div><p>Issue109 xsl note</p></div>
<div class="toot" id="closed-362"><h2>Issue #362 closed<span class="toot-id"> #closed-362</span></h2><div class="pubdate">22 Feb at 10:06:31 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/362">https://github.com/qt4cg/qtspecs/pull/362</a></div><p>Drop obsolete note in XSLT regarding for-each-group/@array</p></div>
<div class="toot" id="minutes-02-21"><h2>QT4 CG meeting 023 draft minutes<span class="toot-id"> #minutes-02-21</span></h2><div class="pubdate">22 Feb at 09:53:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/02-21">https://qt4cg.org/meeting/minutes/2023/02-21</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-369"><h2>Issue #369 created<span class="toot-id"> #created-369</span></h2><div class="pubdate">21 Feb at 17:44:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/369">https://github.com/qt4cg/qtspecs/issues/369</a></div><details><summary>Namespaces for Functions</summary><div class="markup"><p>What problem are we trying to solve? Essentially, I think "namespace clutter".</p>
<p>Namespace clutter manifests itself in several different ways.</p>
<ul>
<li>Firstly, declaration clutter in source code. Here's the start of a module in an XSLT Stylesheet of medium complexity:</li>
</ul>
<pre><code>&lt;xsl:stylesheet 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    exclude-result-prefixes="#all"
    version="3.0" 
    xmlns="http://ns.saxonica.com/xslt/export" 
    xmlns:doc="http://www.saxonica.com/ns/documentation"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map" 
    xmlns:ex="http://ns.saxonica.com/xslt/export" 
    xmlns:f="MyFunctions" 
    xmlns:t="MyTypes"
    expand-text="true"&gt;
</code></pre>
<p>Eight namespace declarations here, of which 3 are concerned with functions; and  Wit can get a lot worse than that.</p>
<ul>
<li>Secondly, namespace clutter in the static and dynamic context. The namespace bindings shown above don't disappear when the code is compiled; even with exclude-result-prefixes="yes", they have to hang around at run-time just in case someone tries to resolve a QName dynamically. Preserving the namespace context in the expression tree through optimization rewrites is a significant cost that has no user benefit; very rarely are they actually going to use the namespace context at run time.</li>
<li>Thirdly, prefix clutter in the executable code. Writing <code>math:cos(math:cos($x))</code> is just so clumsy compared with <code>cos(cos($x))</code>.</li>
</ul>
<p>I think there are a number of things we can do to reduce this.</p>
<p>First, separate out the namespace context for static resolution of function names as a separate part of the static context, used only for this purpose. Ensure that there is no functionality that depends on knowing this part of the static context at run time, so it can be discarded by the compiler as soon as function names are resolved. Then provide source syntax for binding function prefixes to function namespaces in XSLT and XQuery to populate this part of the static context; there is no reason this has to be done using XML namespace declarations. There is also no reason for having different bindings in force in different parts of a single module. And once we've separated these declarations from XML namespace declarations, there's no reason why we can't provide default bindings. We could also allow bindings to have cross-module scope to reduce duplicated code. Note: the xsl:function-library proposal in the current XSLT 4.0 draft tries to achieve some of these things.</p>
<p>Second, allow functions to be referenced by local name alone where the reference is unambiguous; and perhaps provide some aliasing mechanisms to make more existing names unambiguous.</p>
<p>We've explored a third idea, which is to introduce some kind of polymorphism where function names have local scope and are distinguished by the types of objects to which they are applied. I think that given our type system, this is very hard to achieve and I haven't seen any very satisfactory proposals. We also need to remember that there are considerable costs if we start resolving function names dynamically at run time. I wouldn't rule out making progress in this direction, but I'm not optimistic of coming up with a workable solution. There might be some simple things we could do, like having a single function <code>size()</code> that performs the work of both <code>map:size()</code> and <code>array:size()</code> depending on the argument.</p>
</div></details></div>
<div class="toot" id="created-368"><h2>Pull request #368 created<span class="toot-id"> #created-368</span></h2><div class="pubdate">21 Feb at 10:34:36 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/368">https://github.com/qt4cg/qtspecs/pull/368</a></div><details><summary>Issue 129 - Context item generalized to context value</summary><div class="markup"><p>This is a first cut proposal to generalize the context item to a context value, allowing (for example) array predicates.</p>
<p>The proposal covers XPath and XQuery only at this stage; it doesn't address the consequences for XSLT.</p>
<p>Careful review requested!</p>
<p>Addresses issue #129 and issue #367.</p>
</div></details></div>
<div class="toot" id="created-367"><h2>Issue #367 created<span class="toot-id"> #created-367</span></h2><div class="pubdate">21 Feb at 00:06:18 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/367">https://github.com/qt4cg/qtspecs/issues/367</a></div><details><summary>Focus for RHS of thin arrow expressions</summary><div class="markup"><p>We define <code>A -&gt; F(B, C)</code> as being equivalent to <code>A ! F(., B, C)</code> which means that B and C are evaluated with a focus based on the current item in A, not with the outer focus. This is different from the <code>=&gt;</code> operator. For example if the $E is an element E, with several children called F, then</p>
<p><code>namespace-uri(.) -&gt; fn:QName(name())</code></p>
<p>has a different effect from</p>
<p><code>namespace-uri(.) =&gt; fn:QName(name())</code></p>
<p>whereas it might reasonably be expected that in the case where the LHS produces a single value, the two operators are equivalent. We can't change the meaning of <code>=&gt;</code> because it's defined in 3.1. So should we change the meaning of <code>-&gt;</code> to fall into line?</p>
<p>We could do this easily enough by defining <code>A -&gt; F(B, C)</code> as equivalent to <code>for $a in A return F($a, B, C)</code>.  I think that as well as being more consistent with <code>=&gt;</code>, the result is probably more intuitive. (We could also define it as equivalent to <code>let $f := F(?, B, C) return A ! $f(.)</code>)</p>
<p>For the expression <code>A -&gt; {B}</code>, and for the proposed <code>A =&gt; {B}</code>, I don't think we have any choice other than evaluating B with an inner focus based on A. But at least we can do it consistently for both operators.</p>
</div></details></div>
<div class="toot" id="created-366"><h2>Issue #366 created<span class="toot-id"> #created-366</span></h2><div class="pubdate">20 Feb at 18:43:25 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/366">https://github.com/qt4cg/qtspecs/issues/366</a></div><details><summary>Support xsl:use-package with xsl:package-location</summary><div class="markup"><p>Unless I am misreading the specs (which I do commonly enough), there is currently no way for an XSLT writer using <code>xsl:use-package</code> to indicate where the package is to be found, except outside the XSLT environment. I propose to allow <code>xsl:use-package</code> to contain zero or more <code>xsl:package-location</code> children. I propose the addition of an element and not an attribute, because a package may be in multiple locations, and need nuance, as noted below.</p>
<p>Attributes:</p>
<ul>
<li><code>@href</code>, on the model of <code>xsl:import</code> and <code>xsl:include</code>, would specify by relative or absolute URI where the package is.</li>
<li><code>@priority</code> (default 0) would provide a mechanism to indicate whether the specified <code>xsl:package-location</code> should override (value greater than 0), or simply provide a fallback for (less than or equal to 0), the preconfigured place the package should be retrieved from.</li>
<li><code>@use-when</code> would allow a developer to manage different versions of a package for different cases.</li>
</ul>
<p>Other attributes given to <code>xsl:package-location</code> would need discussion.</p>
</div></details></div>
<div class="toot" id="created-365"><h2>Issue #365 created<span class="toot-id"> #created-365</span></h2><div class="pubdate">20 Feb at 16:41:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/365">https://github.com/qt4cg/qtspecs/issues/365</a></div><details><summary>switch, typeswitch: Optional braces</summary><div class="markup"><p>The indentation of switch expressions is often a mess. Now that we allow curly braces for <code>if</code>, it would be nice to also allow optional braces for <code>switch</code> and <code>typeswitch</code>:</p>
<pre><code class="language-xquery">typeswitch($item) {
  case xs:numeric return 'number'
  default return '...'
},
switch($item) {
  case 0 to 9 return 'single digit'
  default return '...'
}
</code></pre>
<p>The current syntax is:</p>
<pre><code class="language-xquery">typeswitch($item)
  case xs:numeric return 'number'
  default return '...',

switch($item)
  case 0 to 9 return 'single digit'
  default return '...'
</code></pre>
</div></details></div>
<div class="toot" id="created-364"><h2>Pull request #364 created<span class="toot-id"> #created-364</span></h2><div class="pubdate">20 Feb at 15:43:59 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/364">https://github.com/qt4cg/qtspecs/pull/364</a></div><p>Generalize switch expressions in XQuery (issue #328)</p></div>
<div class="toot" id="created-363"><h2>Pull request #363 created<span class="toot-id"> #created-363</span></h2><div class="pubdate">20 Feb at 13:07:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/363">https://github.com/qt4cg/qtspecs/pull/363</a></div><p>Fix issue #345 - missing rules for type matching</p></div>
<div class="toot" id="created-362"><h2>Pull request #362 created<span class="toot-id"> #created-362</span></h2><div class="pubdate">20 Feb at 12:12:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/362">https://github.com/qt4cg/qtspecs/pull/362</a></div><details><summary>Drop obsolete note in XSLT regarding for-each-group/@array</summary><div class="markup"><p>Fixes issue #352</p>
</div></details></div>
<div class="toot" id="created-361"><h2>Issue #361 created<span class="toot-id"> #created-361</span></h2><div class="pubdate">20 Feb at 11:38:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/361">https://github.com/qt4cg/qtspecs/issues/361</a></div><details><summary>Named arguments: $input vs. $value</summary><div class="markup"><p>Great effort has been made in unifying the parameter names of the XQFO standard; thanks for that!</p>
<p>I believe to remember that:</p>
<ul>
<li><code>$value</code>, <code>$values</code>, <code>$value1</code>, etc. is used for atomic/atomized arguments, whereas</li>
<li><code>$input</code>, <code>$input1</code>, etc. is used for input, mostly of type <code>item()</code>, that is processed unchanged.</li>
<li><code>$uri</code> is used for arguments that could have been defined as items of type <code>xs:anyURI</code>.</li>
</ul>
<p>I believe the following argument names need to be double-checked (if not, It may be that I haven’t fully grasped how the naming rules are supposed to work):</p>
<p>Function | Currently | Presumably | Justification
--- | --- | --- | ---
<code>array:slice</code> | <code>$input</code> | <code>$array</code> | Alignment with <code>array:size</code> et al.
<code>trace</code> | <code>$value</code> | <code>$input</code> | Argument is not atomized
<code>json</code> | <code>$input</code> | <code>$value</code> | Argument is atomized
<code>string</code> | <code>$item</code> | <code>$value</code>  | <code>$item</code> is used nowhere else
<code>expanded-QName</code> | <code>$qname</code> | <code>$value</code> | Alignment with <code>prefix-from-QName</code> et al.
<code>resolve-QName</code> | <code>$qname</code> | <code>$value</code> | Alignment with <code>prefix-from-QName</code> et al.
<code>parse-QName</code> | <code>$eqname</code> | <code>$value</code> | Alignment with <code>parse-xml</code> et al.
<code>parse-json</code> | <code>$json</code> | <code>$value</code> | Alignment with <code>parse-xml</code> et al.
<code>json-to-xml</code> | <code>$json</code> | <code>$value</code> | Alignment with <code>parse-xml</code> et al.
<code>char</code> | <code>$name</code> | <code>$value</code> | Input may also be codepoint values, etc.
<code>namespace-uri-for-prefix</code> | <code>$prefix</code> | <code>$value</code> | <code>$prefix</code> is used nowhere else
<code>resolve-uri</code> | <code>$relative</code> | <code>$uri</code> | Absolute URIs are legal as well</p>
<p>And we should probably pay particular attention to the naming conventions when adding new functions.</p>
</div></details></div>
<div class="toot" id="created-360"><h2>Pull request #360 created<span class="toot-id"> #created-360</span></h2><div class="pubdate">20 Feb at 11:24:36 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/360">https://github.com/qt4cg/qtspecs/pull/360</a></div><details><summary>Issue 314 array composition and decomposition</summary><div class="markup"><p>This PR addresses parts of issue 29, issue 113, and issue 314 relating to the composition and decomposition of arrays.</p>
<p>It introduces two functions <code>array:of</code> for array composition, and <code>array:members</code> for decomposition, and defines all other array functions in terms of these two primitives (replacing the internal functions <code>op:A2S</code> and <code>op:S2A</code>). The items in the decomposed form of an array are called "value records", singleton maps of the form <code>map{'value': $value}</code></p>
<p>The function <code>array:from-sequence</code> is renamed <code>array:build</code> to reflect its symmetry with <code>map:build</code>.</p>
<p>Question for the group: should we have a new function for constructing a "value record", or is the syntax <code>map{'value': $value}</code> adequate for the purpose?</p>
</div></details></div>
<div class="toot" id="created-359"><h2>Issue #359 created<span class="toot-id"> #created-359</span></h2><div class="pubdate">20 Feb at 09:53:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/359">https://github.com/qt4cg/qtspecs/issues/359</a></div><details><summary>fn:void: Absorb result of evaluated argument</summary><div class="markup"><h3>Summary</h3>
<p>Absorb the result of the evaluated argument.</p>
<h3>Signature</h3>
<pre><code class="language-xquery">fn:void(
  $input as item()*
) as empty-sequence()
</code></pre>
<h3>Motivation</h3>
<p>Developers tend to get creative if they want to suppress the result of an expression. The reason is that there is no simply solution to do this properly. Some constructs I have seen in practice:</p>
<pre><code class="language-xquery">let $unused := EXPRESSION
return 'ok'

EXPRESSION[position() = 10000], 'ok'

let $result := 'ok'
return if(exists(EXPRESSION)) then $result else $result
</code></pre>
<p>Cases like this are frequent in nondeterministic code. Think e.g. of side-effecting functions of the EXPath HTTP-Client and File Modules: The function results are not always relevant for the invoking application, or already known.</p>
<p>The function is also helpful during development and for testing code. <code>fn:void#1</code> and <code>fn:identity#1</code> can both be passed on to functions to either return or ignore the result of their arguments. The function can potentially be used to measure the runtime performance of an expression (but an implementation should not be prevented from discarding the function call if the argument expression is deterministic).</p>
</div></details></div>
<div class="toot" id="created-358"><h2>Issue #358 created<span class="toot-id"> #created-358</span></h2><div class="pubdate">19 Feb at 23:55:31 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/358">https://github.com/qt4cg/qtspecs/issues/358</a></div><details><summary>serialization indent whitespace</summary><div class="markup"><p>There could be an option to control whether the serialization indents with space or tabs, and how many of them (e.g.  2 or 4 spaces )</p>
<p>Related: https://github.com/qt4cg/qtspecs/issues/101</p>
<p>A user request: https://github.com/benibela/xidel/issues/100</p>
</div></details></div>
<div class="toot" id="created-357"><h2>Issue #357 created<span class="toot-id"> #created-357</span></h2><div class="pubdate">18 Feb at 16:07:01 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/357">https://github.com/qt4cg/qtspecs/issues/357</a></div><details><summary>Representing key-value pairs</summary><div class="markup"><p>A map can be decomposed into, or composed from, a sequence of key-value pairs (KVPs).</p>
<p>There are two natural representations of a key-value pair (K, V): it can be represented as a singleton map (<code>map{ K: V }</code>) or as a "doubleton" map (<code>map{ 'key': K, 'value': V}</code>).</p>
<p>This issue examines how well either of these representations is currently supported, which of them is preferable, and how this support should be improved.</p>
<p>I'll consider the following basic operations: constructing a KVP from a key and a value, assembling a map from a set of KVPs, decomposing a map into a sequence of KVPs, extracting the key from a KVP, and extracting the value from a KVP.</p>
<p><strong>Singleton Representation</strong></p>
<p>Constructing a KVP from a key and a value:</p>
<pre><code>map{ $key : $value }
map:entry($key, $value)
&lt;xsl:map:entry key="$key" select="$value"/&gt;
</code></pre>
<p>Assembling a map from a set of KVPs</p>
<pre><code>map:merge($kvps)
&lt;xsl:map&gt;
</code></pre>
<p>Decomposing a map into a sequence of KVPs:</p>
<p><code>map:for-each($map, map:entry#2)</code></p>
<p>Extracting the key from a KVP:</p>
<p><code>map:keys($kvp)</code></p>
<p>Extracting the value from a KVP:</p>
<p><code>$kvp?*</code></p>
<p><strong>Doubleton Representation</strong></p>
<p>Constructing a KVP from a key and a value:</p>
<pre><code>map{ 'key': $key, 'value': $value }
</code></pre>
<p>Assembling a map from a set of KVPs</p>
<p><code>map:build($kvps, -&gt;{?key}, -&gt;{?value})</code></p>
<p>Decomposing a map into a sequence of KVPs:</p>
<p><code>map:for-each($map, -&gt;($K, $V){map{ 'key': $key, 'value': $value })</code></p>
<p>Extracting the key from a KVP:</p>
<p><code>$kvp?key</code></p>
<p>Extracting the value from a KVP:</p>
<p><code>$kvp?value</code></p>
<p><strong>Analysis</strong></p>
<p>The singleton representation is better supported at present, and it makes sense therefore to fill in the gaps that currently make it awkward. The main attraction of the doubleton representation is the ease of extracting the key and the value using <code>$kvp?key</code> and <code>$kvp?value</code>. The equivalents for the singleton representation (<code>map:keys($kvp)</code> and <code>$kvp?*</code>) feel clumsy and unintuitive; however, it's not at all obvious what would be better, short of introducing new custom syntax, which seems over-the-top. The best idea I can come up with is to have two functions <code>map:key($kvp)</code> and <code>map:value($kvp)</code> which require $kvp to be a singleton map. But I hate the namespace prefixes...</p>
<p>The other thing needed to "fill the gaps" is a function <code>map:entries($map)</code> equivalent to <code>map:for-each($map, map:entry#2)</code>.</p>
<p>What if we chose to go the other way, and improve support for the doubleton representation?</p>
<p>We could add <code>map:key-value-pair($key, $value)</code> to create  KVP, and <code>map:of($kvps)</code> to build a map from a set of KVPs, and <code>map:key-value-pairs($map)</code> to decompose a map. The trickiest problem is what to do about XSLT, where the 3.0 instructions <code>&lt;xsl:map&gt;</code> and <code>&lt;xsl:map-entry&gt;</code> use the singleton representation.</p>
</div></details></div>
<div class="toot" id="created-356"><h2>Issue #356 created<span class="toot-id"> #created-356</span></h2><div class="pubdate">18 Feb at 00:21:40 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/356">https://github.com/qt4cg/qtspecs/issues/356</a></div><details><summary>[FO] Issues with array:flatten</summary><div class="markup"><h1>1. Issues</h1>
<p>There are at least two issues with the definition of the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-flatten"><strong><code>array:flatten</code></strong></a>:</p>
<ol>
<li>
<p>Unlike most other functions on arrays (such as <strong><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-put">array:put</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-replace">array:replace</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-append">array:append</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-slice">array:slice</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-subarray">array:subarray</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-remove">array:remove</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-insert-before">array:insert-before</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-tail">array:tail</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-trunk">array:trunk</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-reverse">array:reverse</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-join">array:join</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-for-each">array:for-each</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-filter">array:filter</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-for-each-pair">array:for-each-pair</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-sort">array:sort</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-partition">array:partition</a></strong>) , which produce an array as their result, <strong>this function produces only a sequence</strong></p>
</li>
<li>
<p><strong>This function is not lossless</strong> -- any members that are the empty sequence or the empty array are not represented in the returned result.</p>
</li>
</ol>
<h1>2. Suggested solution(s)</h1>
<p>We want to have a function that is similar to the wrongly defined one, but produces its contents as an array, and is lossless. There are two obvious ways to do this:</p>
<ol>
<li>
<p>Correct the specification of   <strong><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview-diff.html#func-array-flatten"><code>array:flatten</code></a></strong> so that its result is an array and it represents the empty sequences and empty arrays as the same members of its result.</p>
</li>
<li>
<p>Add to the Specification a new function: <strong><code>array:leaves</code></strong> that produces an array as its result and that is lossless.
<strong>array:leaves</strong> returns an array whose members are exactly all the leaves of the input array, by the order of their appearance. By definition leaves are all, and at any depth, members that are not an array except when they are the empty array. Thus () (the empty sequence) and [] (the empty array) are leaves by definition.</p>
</li>
</ol>
<p><strong><em>Solution 2. will not cause any compatibility issues</em></strong>.</p>
<h1>3. Examples</h1>
<p>The expression <strong><code>array:leaves([1, (), [4, 6], 5, 3])</code></strong> returns <strong><code>[1, (),  4, 6, 5, 3]</code></strong>.</p>
<p>The expression <strong><code>array:leaves([1, 2, 5], [[10, 11], 12], [], 13)</code></strong> returns <strong><code>[1, 2, 5, 10, 11, 12, [], 13]</code></strong>.</p>
</div></details></div>
<div class="toot" id="agenda-02-21"><h2>QT4 CG meeting 023 draft agenda<span class="toot-id"> #agenda-02-21</span></h2><div class="pubdate">17 Feb at 17:49:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/02-21">https://qt4cg.org/meeting/agenda/2023/02-21</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-355"><h2>Pull request #355 created<span class="toot-id"> #created-355</span></h2><div class="pubdate">16 Feb at 21:41:38 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/355">https://github.com/qt4cg/qtspecs/pull/355</a></div><details><summary>Action QT4CG-022-02 - add to imp-def-feature appendix</summary><div class="markup"><p>Adds entries to the implementation-defined-features appendix of the serialization spec, corresponding to the option to generate <code>&lt;meta charset="XXX"&gt;</code> for HTML5.</p>
</div></details></div>
<div class="toot" id="created-354"><h2>Pull request #354 created<span class="toot-id"> #created-354</span></h2><div class="pubdate">16 Feb at 18:30:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/354">https://github.com/qt4cg/qtspecs/pull/354</a></div><details><summary>Combine multiple signatures of XSLT functions to use defaults</summary><div class="markup"><p>This PR addresses issue 69, by modifying those XSLT built-in functions that currently have multiple signatures, to use a single signature with parameter defaults instead.</p>
<p>The changes however don't currently render correctly. The XSLT processing pipeline needs to be changed to pick up the changes that were made to the F+O stylesheets to render parameter defaults correctly. I haven't yet managed to work out where this is done.</p>
</div></details></div>
<div class="toot" id="created-353"><h2>Pull request #353 created<span class="toot-id"> #created-353</span></h2><div class="pubdate">16 Feb at 17:22:48 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/353">https://github.com/qt4cg/qtspecs/pull/353</a></div><details><summary>Issue109 xsl note</summary><div class="markup"><p>Addresses issue #109 and issue #87. Unfortunately the PR also includes the unrelated commits for issue 22.</p>
</div></details></div>
<div class="toot" id="created-352"><h2>Issue #352 created<span class="toot-id"> #created-352</span></h2><div class="pubdate">16 Feb at 14:58:30 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/352">https://github.com/qt4cg/qtspecs/issues/352</a></div><details><summary>The @array attribute of xsl:for-each-group is no more</summary><div class="markup"><p>There is a note in XSLT §14.2 concerning the @array attribute of xsl:for-each-group, but this attribute has been dropped.</p>
</div></details></div>
<div class="toot" id="closed-351"><h2>Issue #351 closed<span class="toot-id"> #closed-351</span></h2><div class="pubdate">16 Feb at 08:48:37 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/351">https://github.com/qt4cg/qtspecs/pull/351</a></div><p>Another attempt to build off the merge-base branch</p></div>
<div class="toot" id="created-351"><h2>Pull request #351 created<span class="toot-id"> #created-351</span></h2><div class="pubdate">16 Feb at 08:48:31 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/351">https://github.com/qt4cg/qtspecs/pull/351</a></div><p>Another attempt to build off the merge-base branch</p></div>
<div class="toot" id="closed-341"><h2>Issue #341 closed<span class="toot-id"> #closed-341</span></h2><div class="pubdate">16 Feb at 00:17:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/341">https://github.com/qt4cg/qtspecs/issues/341</a></div><p>[XPath] Error-free selection operator for maps or arrays, or finite-domain functions</p></div>
<div class="toot" id="created-350"><h2>Issue #350 created<span class="toot-id"> #created-350</span></h2><div class="pubdate">16 Feb at 00:11:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/350">https://github.com/qt4cg/qtspecs/issues/350</a></div><details><summary>[XPath] CompPath (Composite-objects path) Expressions</summary><div class="markup"><h1>CompPath (Composite-objects path) Expressions</h1>
<p>As initially discussed in issue #341, we were exploring different ways to provide an XPath-like language to traverse in depth composite objects such as maps and arrays and select their members at any depth.
While working on this, the idea of an XPath-like language for composite items started to emerge and here we present this idea in a more or less crystalized form.</p>
<h2>1. Root Component</h2>
<p>Any CompPath expression must start off a composite item (of type map or array, or of other future composite item type (maybe set? )  ).
This can be a literal composite item or a reference to a variable whose value is a composite item.</p>
<p>Examples:</p>
<pre><code class="language-xq">
(: Literal composite items: :)
[1, 2, 3]

[1, [2,  3]]?2

{"x":1, "y" : map{ "z": 2}}

{"x":1, "y" : map{ "z": 2}} ?y

(: Variables containing composite items: :)
let $comp1 := [1, [2, 3]],
 $comp2 :=$comp1 ?2,
 $comp3 := {"x":1, "y" : map{ "z": 2}},
 $comp4 := $comp3 ?y
</code></pre>
<p>In the above examples all literal expressions and all variables (<strong><code>$comp1, $comp2, $comp3, $comp4</code></strong>) may serve as the root component for a CompPath expression.</p>
<h2>2. The component-path operator (\)</h2>
<p>The component-path operator "\" is used to build expressions for locating members at any depth within component trees. Its left-hand side expression must return a result that is a composite item or else this result is represented as such by wrapping it into an array.</p>
<p>The operator returns an array, the values of whose members are composite items themselves or any such value may be a non-composite "leaf" in the root-component tree).</p>
<p>Each operation E1\E2 is evaluated as follows: Expression E1 is evaluated, and the result is wrapped in an array A1. If any member of A1 is not a composite item, a type error is raised.
Each member of A1 serves in turn  to provide an inner "composite-focus" (the member as the "composite-context-item" or <strong><code>.</code></strong>, its index in A1 as the "composite-context-position" or <strong><code>index()</code></strong>, the set of keys of the composite-context-item as the "composite-keyset" or <strong><code>keys()</code></strong> and the size of this member as the "composite-context-size" (specified as one of: <strong><code>size()</code></strong>, or <strong><code>array-size()</code></strong> or <strong><code>key-size()</code></strong>) ) for the evaluation of E2. The result of each evaluation of  E2, if it isn't a single composite item, is wrapped in a single array. The arrays resulting from all the evaluations of E2 are wrapped  in a single array and this single array is the result of the evaluation.</p>
<p>E2 is typically a function over the <em>context-focus</em>  and its results will be the set of the next step composite-context-items (used as the left-hand-side of the next in chain composite-step-expression (see below)), or these results would be the final results of evaluation if this is the last-in chain composite-step-expression.</p>
<h2>3. Composite-Steps</h2>
<p>A <strong>composite-step</strong> is a part of a composite-path-expression that generates an array and filters its members by zero or more predicates. A <strong>composite-step-expression</strong> is either a <em>CompositeAxisStep</em> or a <em>CompositePostfixExpression</em>.</p>
<h2>4. Composite-Axes</h2>
<p>The following axes are defined for traversing a composite-item tree:</p>
<ul>
<li>The <strong><code>child-member::</code></strong> axis contains the members of the composite-context-item.</li>
<li>The  <strong><code>value-member::</code></strong>  axis contains the members of the composite-context-item that are not composite themselves.</li>
<li>The  <strong><code>node-member::</code></strong>  axis contains the members of the composite-context-item that are nodes.</li>
<li>The <strong><code>descendant-member::</code></strong> axis is defined as the transitive closure of the <strong><code>child-member::</code></strong> axis; it contains the descendent-members of the composite-context-item (the child members of the composite-context-item, and their child-members, ... and so on).</li>
<li>The <strong><code>self::</code></strong> axis contains just the composite-context-item.</li>
<li>The <strong><code>descendant-member-or-self::</code></strong> contains the composite-context-item and all of its descendent-members.</li>
<li>The <strong><code>following-sibling-member::</code></strong> axis contains the members of the immediate container of the composite-context-item that follow it. For any two members <strong><em>mem1</em></strong> and <strong><em>mem2</em></strong> of a composite item <strong><em>Comp</em></strong>, by definition <strong><em>mem2</em></strong> follows <strong><em>mem1</em></strong> if and only if <strong><em>Comp</em></strong> is an array and the index of <strong><em>mem2</em></strong> in <strong><em>Comp</em></strong> is greater than that of <strong><em>mem1</em></strong>, or if <strong><em>Comp</em></strong> is a map, then the key of <strong><em>mem2</em></strong> is greater than that of <strong><em>mem1</em></strong>.</li>
<li>The <strong><code>preceding-sibling-member::</code></strong> axis contains the members of the immediate container of the composite-context-item that precede it. For any two members <strong><em>mem1</em></strong> and <strong><em>mem2</em></strong> of a composite item <strong><em>Comp</em></strong>, by definition <strong><em>mem1</em></strong> precedes <strong><em>mem2</em></strong> if and only if <strong><em>Comp</em></strong> is an array and the index of <strong><em>mem2</em></strong> in <strong><em>Comp</em></strong> is greater than that of <strong><em>mem1</em></strong>, or if <strong><em>Comp</em></strong> is a map, then the key of <strong><em>mem2</em></strong> is greater than that of <strong><em>mem1</em></strong>.</li>
</ul>
<p>For example, <strong><code>following-sibling-member::5</code></strong> means all members of the composite-context-item with index &gt; 5,
and <strong><code>preceding-sibling-member::5</code></strong> means all members of the composite-context-item with index &lt; 5</p>
<p><strong>Note</strong>: If the immediate container of the composite-context-item is a map whose key-values cannot be ordered, then specifying either of the <strong><code>following-sibling-member::</code></strong> or <strong><code>preceding-sibling-member::</code></strong> axes on this composite-context-item must raise a type error. (Obviously, these two axes are meaningful only for composite items, whose members are ordered, such as the array).</p>
<p>If the composite-axis name is omitted from a composite-axis step, the default axis is <strong><code>child-member::</code></strong></p>
<h2>5. Composite Axis Steps</h2>
<p>A composite axis step completely resembles the ordinary axis step in XPath. It consists of three parts:</p>
<ol>
<li>The composite axis  (<strong><code>child-member::</code></strong>, <strong><code>descendant-member::</code></strong>, <strong><code>value-member::</code></strong>, <strong><code>node-member::</code></strong>, <strong><code>following-sibling-member::</code></strong>, <strong><code>preceding-sibling-member::</code></strong>, <strong><code>self::</code></strong>, or the <strong><code>descendant-member-or-self::</code></strong> axis)</li>
<li>The member test</li>
<li>The composite-predicates</li>
</ol>
<h2>6. Member Tests</h2>
<p>A member test is a condition on the key-name, index, or kind (<em>composite</em>, <em>map</em>, <em>array</em> or <em>value</em>, <em>node</em>, or (any) <em>member</em>). A member test determines which members contained by a copmosite-axis are selected by a composite-step.</p>
<p>As such, a member test is either an <em>identifier-test</em> (key-name or index) or a <em>kind-test</em> (<em>composite</em>, <em>map</em>, <em>array</em>,  <em>value</em>, or <em>member</em>)).</p>
<p>Examples of member identifiers:</p>
<ul>
<li>
<p>A string specifies a name of a key, whose value will be selected. For example: <strong><code>\child-member::X</code></strong> selects from the composite-context-item the value corresponding to its key which has the name "X".</p>
</li>
<li>
<p><strong><code>\child-member::3</code></strong> selects from the composite-context-item the value of its 3rd member, if it is an array or the value corresponding to its key <strong><code>3</code></strong>, if it is a map.</p>
</li>
<li>
<p><strong><code>following-sibling-member::3</code></strong> selects from the composite-content-item (which is most-likely an array) all of its members having index greater than 3.</p>
</li>
<li>
<p><strong><code>preceding-sibling-member::3</code></strong> selects from the composite-content-item (which is most-likely an array) all of its members having index less than 3.</p>
</li>
<li>
<p><strong><code>\descendant-member-or-self::X</code></strong> selects from the composite-context-item (that must be a map) and from all its descendant-members, the values corresponding to their key named "X", if these descendents have a key named "X".</p>
</li>
<li>
<p>Similarly <strong><code>\5</code></strong> is equivalent to <strong><code>\child-member::5</code></strong> and selects from the composite-context-item that is an array the value of its 5th member. This will also select the value corresponding to the key <strong><code>5</code></strong> from the composite-context-item if it is a map, because on the <strong><code>child-member::</code></strong> axis both maps and arrays may be selected.</p>
</li>
<li>
<p><strong><code>\X</code></strong> is equivalent to <strong><code>\child-member::X</code></strong> and selects from the composite-context-item (that must be a map), the value corresponding to its key which has the name "X".</p>
<p>There is also the pseudo-operator <code>\\</code> . This is an abbreviation for:</p>
<p><strong><code>\descendant-member-or-self::member()\</code></strong></p>
<p>Thus, <strong><code>\\X</code></strong> means: "(Deep) Select all members of the root-component that are the corresponding values of keys equal to 'X' "</p>
</li>
<li>
<p>We may use a <strong><em>kind test</em></strong> as part of the previous example, if we want to select only a specific kind of members of the composite-context-item.
<strong><code>\array()</code></strong>  In this example, although we are on the <strong><code>child-member::</code></strong> axis, we want to select only members of the composite-context-item that are arrays.</p>
</li>
<li>
<p><strong><code>\map()</code></strong>  In this example, although we are on the <strong><code>child-member::</code></strong> axis, we want to select only members of the composite-context-item that are maps.</p>
</li>
<li>
<p><strong><code>\value()</code></strong>  In this example we want to select only members of the composite-context-item that are not composite items themselves.</p>
</li>
<li>
<p><strong><code>\node()</code></strong>  In this example we want to select only members of the composite-context-item that are nodes.</p>
</li>
<li>
<p><strong><code>\member()</code></strong>  In this example we want to select all members of the composite-context-item, regardless whether they are maps, arrays, or values.</p>
</li>
</ul>
<h3>6.1 Wildcards</h3>
<p>The <strong><code>*</code></strong> wildcard can be used instead of a member identifier. Its meaning is to select all existing members of the composite-context-item, that is possibly selected by a specific axis and limited by a specific member kind-test.</p>
<p><strong>Examples</strong>:</p>
<ul>
<li><strong><code>\*</code></strong>  (: (Shallow) Selects all members of the composite-context-item :)</li>
<li><strong><code>\map()\*</code></strong>  (: Selects from the composite-context-item all values that correspond to a key of any map-member of the composite-context item :)</li>
<li><strong><code>\array()\*</code></strong>  (: Selects from the composite-context-item all members of all its members that are arrays :)</li>
<li><strong><code>\\*</code></strong>  (: (Deep) Select all members of the composite tree rooted by the root-component :)</li>
</ul>
<h2>7. Predicates</h2>
<p>As defined above, a <strong>composite-step</strong> has three parts: <em>composite-axis</em> (can be omitted and then a default axis is used), <em>member test</em>, and an optional <em>list of composite-predicates</em>.</p>
<p>A <strong><em>composite-predicate</em></strong> in a composite-step is an expression used as a <em>filter</em> applied on the members of the composite-context-item that are already selected by the axis and member tests of the axis step, and not filtered out by any preceding composite-predicates in the <em>composite-predicates-list</em>. The composite-predicate may be any XPath expression and is written within double square brackets.</p>
<p><strong>Examples</strong>:</p>
<ul>
<li><strong><code>\*[[3]]</code></strong>  (: Selects any member of the composite-context-item, that is an array and has a 3rd member or any member of the composite-context-item, that is a map and has a key <strong>3</strong> :)
This is a shorthand for: <strong><code>\*[[array-size() ge 3 or 3 = keys()]]</code></strong></li>
<li><strong><code>\array()[[3]]</code></strong> (: Selects those array members of the composite-context-item that have a 3rd member :)
This is a shorthand for: <strong><code>\*[[size() ge 3]]</code></strong></li>
<li><strong><code>\*[[size() eq 7]]</code></strong>  (: Selects those members whose array-size() or key-size() is exactly 7:)
This is a shorthand for: <strong><code>\composite::*[[self::map() and key-size() eq 7 or self::array() and array-size() eq 7]]</code></strong></li>
<li><strong><code>\*[[X]]</code></strong>  (: Selects any member of the composite-context-item, that is a map and has a key <strong>X</strong>  :)</li>
<li><strong><code>\map()[[X]]</code></strong> (: Selects any map member of the composite-context-item, that has a key <strong>X</strong>  :)
The above two expressions are a shorthand for: <strong><code>\*[['X' = keys()]]</code></strong></li>
<li><strong><code>\value()[[. gt 0]]</code></strong> (: Selects any value (non-composite member) of the composite-context-item, that is a positive number :)</li>
</ul>
<h2>8. Mixing CompPath and XPath expressions</h2>
<p>CompPath and XPath expressions can be used as parts of a single expression:</p>
<ul>
<li>
<p>A CompPath expression may be appended at the end of any XPath expression that produces a composite-object .</p>
</li>
<li>
<p>An XPath expression may be appended at the end of any CompPath expression. When doing this,</p>
<p><strong><code>CompPathExpr / XPathExpr</code></strong></p>
<p>is equivalent to:</p>
<p><strong><code>CompPathExpr\node::* / XPathExpr</code></strong></p>
<p>And this:</p>
<p><strong><code>CompPathExpr ! XPathExpr</code></strong>  (:  Note: also causes ordering and deduplication of the nodes! :)</p>
<p>is equivalent to:</p>
<p><strong><code>CompPathExpr\value::* !  XPathExpr</code></strong>  (: Note: No ordering or deduplication, can be applied on any item, not just on nodes :)</p>
</li>
<li>
<p>A CompPath expression may be substituted for the expected argument of any XPath expression, for example:
<strong><code>count(MyCompPathExpr)</code></strong></p>
</li>
<li>
<p>Any XPath expression that produces a composite item can be used as the composite-root for any CompPath expression</p>
</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-xq">let $myBooks := 
&lt;books&gt;
 &lt;book name="Tom Sawyer"&gt;
   &lt;author&gt;Mark Twain&lt;/author&gt;
 &lt;/book&gt;
 &lt;book name="Wuthering Heights"&gt;
   &lt;author&gt;Emily Brontë&lt;/author&gt;
 &lt;/book&gt;
 &lt;book name="Jane Eyre"&gt;
   &lt;author&gt;Charlotte Brontë&lt;/author&gt;
 &lt;/book&gt;
 &lt;book name="Adventures of Huckleberry Finn"&gt;
   &lt;author&gt;Mark Twain&lt;/author&gt;
 &lt;/book&gt;
&lt;/books&gt;,
$map1 := map {"science-works": map{"Einstein": "Special Theory of relativity",
                                  "Darwin" : "On the Origin of Species"
                                 },
             "literature" : map{"19the Century": $myBooks}
            }
return
  $map1\literature\\*/book[author eq 'Mark Twain']
</code></pre>
<p>Evaluating this mixed CompPath and XPath expression produces the correct result:</p>
<pre><code class="language-xq">&lt;book name="Tom Sawyer"&gt;
  &lt;author&gt;Mark Twain&lt;/author&gt;
&lt;/book&gt;
&lt;book name="Adventures of Huckleberry Finn"&gt;
  &lt;author&gt;Mark Twain&lt;/author&gt;
&lt;/book&gt;
</code></pre>
</div></details></div>
<div class="toot" id="closed-349"><h2>Issue #349 closed<span class="toot-id"> #closed-349</span></h2><div class="pubdate">15 Feb at 18:04:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/349">https://github.com/qt4cg/qtspecs/pull/349</a></div><p>Revert PR change; it doesn't work in this context</p></div></div><p>See 174
            more statuses in yearly archives.</p></article></main></body></html>