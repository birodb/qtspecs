<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a></p><div class="toots">
<div class="toot" id="closed-342"><h2>Issue #342 closed<span class="toot-id"> #closed-342</span></h2><div class="pubdate">14 Feb at 17:24:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/342">https://github.com/qt4cg/qtspecs/pull/342</a></div><p>Issue318 meta elements</p></div>
<div class="toot" id="minutes-02-14"><h2>QT4 CG meeting 022 draft minutes<span class="toot-id"> #minutes-02-14</span></h2><div class="pubdate">14 Feb at 17:12:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/02-14">https://qt4cg.org/meeting/minutes/2023/02-14</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-338"><h2>Issue #338 closed<span class="toot-id"> #closed-338</span></h2><div class="pubdate">09 Feb at 17:30:02 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/338">https://github.com/qt4cg/qtspecs/pull/338</a></div><p>Add ednote per action QT4CG-016-02</p></div>
<div class="toot" id="created-344"><h2>Pull request #344 created<span class="toot-id"> #created-344</span></h2><div class="pubdate">09 Feb at 17:06:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/344">https://github.com/qt4cg/qtspecs/pull/344</a></div><details><summary>Issue 22: allow "for"/"let" keyword to be repeated in XPath</summary><div class="markup"><p>Addresses the proposal in issue 22 to allow repetition of the "let" or "for" keyword in a ForExpr or LetExpr. (It does not, however, allow "for" and "let" to be mixed).</p>
</div></details></div>
<div class="toot" id="created-343"><h2>Issue #343 created<span class="toot-id"> #created-343</span></h2><div class="pubdate">09 Feb at 12:47:25 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/343">https://github.com/qt4cg/qtspecs/issues/343</a></div><details><summary>XQFO: $collation argument</summary><div class="markup"><p>In the function set of the XQFO current specification, the type of the <code>$collation</code> parameter is sometimes <code>xs:string</code> and sometimes <code>xs:string?</code>, depending on the position of the parameter. Examples:</p>
<h4>Mandatory</h4>
<pre><code class="language-xquery">fn:distinct-values($values as&nbsp;xs:anyAtomicType*, $collation as fn:default-collation())&nbsp;as&nbsp;xs:anyAtomicType*
fn:index-of($input | as&nbsp;xs:anyAtomicType*, $search | as&nbsp;xs:anyAtomicType, $collation as&nbsp;xs:string)&nbsp;as&nbsp;xs:integer*
</code></pre>
<h4>Optional</h4>
<pre><code class="language-xquery">fn:sort($input as&nbsp;item()*, $collation as&nbsp;xs:string?, $key as&nbsp;function(item()) as xs:anyAtomicType*
fn:lowest($input as item()*, $collation as xs:string?, $key as&nbsp;function(item()) as xs:anyAtomicType*)&nbsp;as&nbsp;item()*
</code></pre>
<p>I think we should always allow an empty sequence.</p>
</div></details></div>
<div class="toot" id="created-342"><h2>Pull request #342 created<span class="toot-id"> #created-342</span></h2><div class="pubdate">09 Feb at 12:27:01 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/342">https://github.com/qt4cg/qtspecs/pull/342</a></div><details><summary>Issue318 meta elements</summary><div class="markup"><p>Revises the rules for serializing meta elements to take account of new HTML5 syntax.</p>
<p>Resolves issue #318</p>
</div></details></div>
<div class="toot" id="closed-330"><h2>Issue #330 closed<span class="toot-id"> #closed-330</span></h2><div class="pubdate">08 Feb at 08:35:16 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/330">https://github.com/qt4cg/qtspecs/pull/330</a></div><p>Update fn:parse-html to apply review feedback.</p></div>
<div class="toot" id="created-341"><h2>Issue #341 created<span class="toot-id"> #created-341</span></h2><div class="pubdate">08 Feb at 01:50:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/341">https://github.com/qt4cg/qtspecs/issues/341</a></div><details><summary>[XPath] Error-free selection operator for maps or arrays, or finite-domain functions</summary><div class="markup"><p>In March 2021 Jarno Elovirta raised on the <strong><em>#general channel</em></strong> of the XML.com Slack the problem that the existing map or array lookup operator "<strong>?</strong>" prevents a free traversal of a nested mapp/array object. For example, this expression results in error:</p>
<pre><code class="language-xq">[
  map {"k0": 1}, 
  map{"k0": [1, 2, 3]}
]  ?* ?("k0")  ?*
</code></pre>
<p><strong>[XPTY0004] Input of lookup operator must be map or array: 1.</strong></p>
<hr>
<p>There are three possible types of reaction to this problem:</p>
<ol>
<li>
<p>Do nothing</p>
</li>
<li>
<p>Relax the semantics of the map/array lookup operator "<strong>?</strong>" so that it can be applied on items of non-map/non-array type and in such case produce the empty sequence.</p>
</li>
<li>
<p>Introduce a similar operator to "<strong>?</strong>" that will behave as it, but instead of producing an error when applied on items of non-map/non-array type it produces the empty sequence.</p>
</li>
</ol>
<p>Obviously, we are not advocating the 1st choice above, or otherwise we wouldn't be raising any issue 😄</p>
<p>Choice 2 could be implemented, but this would have a few drawbacks:</p>
<ul>
<li>it would bring a certain degree of backwards incompatibility</li>
<li>"silently returning nothing" is really difficult to debug or even notice unexpected results, as pointed out by @michaelhkay</li>
</ul>
<p><strong>This proposal is to choose alternative 3. above</strong>.</p>
<p>Why is it better than the 2nd one?</p>
<ul>
<li>No incompatibility can be introduced, as this is a new operator.</li>
<li>The user has intentionally chosen this operator over the "?" operator, and this means that the user is well aware of the new, sometimes tricky to observe/explain/debug behavior, but the user doesn't mind these effects and is ready to deal with them.</li>
</ul>
<h2>Definition</h2>
<p>By definition the operator <strong>"-&gt;"</strong> with left-hand-side any expression <strong><em>E</em></strong> and right-hand-side a literal string  <strong><em>X</em></strong>:</p>
<p>&nbsp;&nbsp;&nbsp;<strong><code>E -&gt; X</code></strong></p>
<p>is lexically expanded to:</p>
<p>&nbsp;&nbsp;&nbsp;<strong><code>E[. instance of map(*) or . instance of array(*)]?X </code></strong></p>
<h2>Example</h2>
<p>With the original expression provided by Jarno Elovirta, but now using the <strong>"-&gt;"</strong> operator:</p>
<pre><code class="language-xq">[
  map {"k0": 1}, 
  map{"k0": [1, 2, 3]}
]  -&gt;* -&gt;("k0")  -&gt;*
</code></pre>
<p>its evaluation produces the expected result (all the values within just one of the leaves of the tree), and no error:</p>
<p><strong><code>1, 2, 3</code></strong></p>
<p>That is, <strong><code>1 -&gt;*</code></strong>  produces the empty sequence and no error.</p>
<p><strong>Note</strong>:</p>
<p>Of course, the above example can be rewritten to this equivalent XPath 3.0 expression and will get the wanted result, but literally no one, myself included, will ever write this:</p>
<pre><code class="language-xq">[
 map {"k0": 1}, 
 map{"k0": [1, 2, 3]}
] [. instance of map(*) or . instance of array(*)]      ?*
           [. instance of map(*) or . instance of array(*)]      ?k0
                                [. instance of map(*) or . instance of array(*)]   ?*
</code></pre>
<p><img src="https://user-images.githubusercontent.com/10605892/217432167-5f7fbff0-3d8d-48a3-a27d-5f62cb77c3dc.png" alt="image"></p>
<h2>Thus <strong><em><code>this is all about making it possible/feasible and empowering our users!</code></em></strong></h2>
</div></details></div>
<div class="toot" id="created-340"><h2>Issue #340 created<span class="toot-id"> #created-340</span></h2><div class="pubdate">07 Feb at 22:02:07 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/340">https://github.com/qt4cg/qtspecs/issues/340</a></div><details><summary>fn:format-number: Specifying decimal format</summary><div class="markup"><p>It would be nice if the decimal format for <code>fn:format-number</code> could also be supplied via an options argument:</p>
<pre><code>format-number(
  value := 123.45,
  picture := '#.##0,00',
  format := map { 'decimal-separator': ',', 'grouping-separator': '.' }
)
</code></pre>
<p>If both <code>$decimal-format-name</code> and <code>$format</code> are supplied, an error would probably need to be raised.</p>
<p>The current writing of the query above is:</p>
<pre><code>declare decimal-format de decimal-separator = ',' grouping-separator = '.';

format-number(
  value := 123.45,
  picture := '#.##0,00',
  decimal-format-name': 'de'
)
</code></pre>
</div></details></div>
<div class="toot" id="minutes-02-07"><h2>QT4 CG meeting 021 draft minutes<span class="toot-id"> #minutes-02-07</span></h2><div class="pubdate">07 Feb at 17:20:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/02-07">https://qt4cg.org/meeting/minutes/2023/02-07</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-339"><h2>Issue #339 created<span class="toot-id"> #created-339</span></h2><div class="pubdate">07 Feb at 13:46:57 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/339">https://github.com/qt4cg/qtspecs/issues/339</a></div><details><summary>The constraints on document-uri are too...constraining</summary><div class="markup"><p>The XPath data model imposes the following constraints on the document-uri property:</p>
<blockquote>
<p>If the <code>document-uri</code> is not the empty sequence, then the following constraint must hold: the node returned by evaluating <code>fn:doc()</code> with the document-uri as its argument must return the document node that provided the value of the <code>document-uri</code> property.</p>
<p>In other words, for any Document Node <code>$arg</code>, either <code>fn:document-uri($arg)</code> must return the empty sequence or <code>fn:doc(fn:document-uri($arg))</code> must return <code>$arg</code>.</p>
</blockquote>
<p>This contraint turns out to be inconvenient whenever the larger environment doesn’t enforce a 1:1 mapping between URIs and documents.</p>
<p>For example, in a browser context, a JavaScript function that returns different versions of the same document over time cannot identify those documents with the same document-uri.</p>
<p>In XProc, a <code>p:add-attribute</code> step that returns a copy of its input document with one additional attribute, cannot identify the output document with the same document-uri as the input document.</p>
<p>Given that the document URI is often necessary to evaluate relative URI references within a document, the constraints imposed in the data model are too strict.</p>
</div></details></div>
<div class="toot" id="created-338"><h2>Pull request #338 created<span class="toot-id"> #created-338</span></h2><div class="pubdate">07 Feb at 13:33:27 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/338">https://github.com/qt4cg/qtspecs/pull/338</a></div><details><summary>Add ednote per action QT4CG-016-02</summary><div class="markup"><p>This is a purely editorial change. Unless someone objects over the next few days, I'm just going to merge it in.</p>
</div></details></div>
<div class="toot" id="agenda-02-07"><h2>QT4 CG meeting 021 draft agenda<span class="toot-id"> #agenda-02-07</span></h2><div class="pubdate">04 Feb at 15:09:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/02-07">https://qt4cg.org/meeting/agenda/2023/02-07</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-337"><h2>Issue #337 created<span class="toot-id"> #created-337</span></h2><div class="pubdate">02 Feb at 00:52:31 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/337">https://github.com/qt4cg/qtspecs/issues/337</a></div><details><summary>Local union and enum types: and the definition of generalised atomic types</summary><div class="markup"><p>We need to review the proposed specs for local union and enum types, and decide whether or not to proceed with them.</p>
<p>I note that the definitions of <strong>generalized atomic type</strong> and <strong>pure union type</strong> say they must be "schema-defined", which appears to exclude locally-defined union and enum types.</p>
<p>I wonder if the definition of local enum types should be aligned more closely with an XSD type derived from xs:string by restricting with an enum facet. Now that we allow down-casting in the coercion rules, the objections to this seem to disappear.</p>
<p><code>cast</code> and <code>castable</code> should also probably pay more attention to these types.</p>
</div></details></div>
<div class="toot" id="created-336"><h2>Pull request #336 created<span class="toot-id"> #created-336</span></h2><div class="pubdate">01 Feb at 12:48:05 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/336">https://github.com/qt4cg/qtspecs/pull/336</a></div><details><summary>Action QT4CG-019-01 (type of $pattern in fn:tokenize())</summary><div class="markup"><p>Also, update the fos:history record for a number of functions.</p>
</div></details></div>
<div class="toot" id="closed-308"><h2>Issue #308 closed<span class="toot-id"> #closed-308</span></h2><div class="pubdate">01 Feb at 12:13:58 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/308">https://github.com/qt4cg/qtspecs/pull/308</a></div><p>Improve the legends in the diagrams</p></div>
<div class="toot" id="closed-335"><h2>Issue #335 closed<span class="toot-id"> #closed-335</span></h2><div class="pubdate">01 Feb at 12:13:57 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/335">https://github.com/qt4cg/qtspecs/pull/335</a></div><p>Rework type hierarchy diagrams as styled lists</p></div>
<div class="toot" id="created-335"><h2>Pull request #335 created<span class="toot-id"> #created-335</span></h2><div class="pubdate">01 Feb at 12:13:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/335">https://github.com/qt4cg/qtspecs/pull/335</a></div><details><summary>Rework type hierarchy diagrams as styled lists</summary><div class="markup"><p>Close #308</p>
<p>This proposal was accepted at meeting 020 on 31 January 2023.</p>
<p>The PR won't format correctly because there are style changes, so I'm just going to merge this. I have fixed the diagrams in both the data model specification and f&amp;o.</p>
</div></details></div>
<div class="toot" id="closed-324"><h2>Issue #324 closed<span class="toot-id"> #closed-324</span></h2><div class="pubdate">01 Feb at 10:17:52 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/324">https://github.com/qt4cg/qtspecs/pull/324</a></div><p>Proposed syntax and semantics for string templates</p></div>
<div class="toot" id="closed-326"><h2>Issue #326 closed<span class="toot-id"> #closed-326</span></h2><div class="pubdate">01 Feb at 10:17:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/326">https://github.com/qt4cg/qtspecs/pull/326</a></div><p>Issue 205: make support for higher-order functions mandatory</p></div>
<div class="toot" id="closed-319"><h2>Issue #319 closed<span class="toot-id"> #closed-319</span></h2><div class="pubdate">01 Feb at 10:17:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/319">https://github.com/qt4cg/qtspecs/pull/319</a></div><p>Issue 221: op:same-key becomes fn:atomic-equal</p></div>
<div class="toot" id="created-334"><h2>Issue #334 created<span class="toot-id"> #created-334</span></h2><div class="pubdate">01 Feb at 09:17:02 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/334">https://github.com/qt4cg/qtspecs/issues/334</a></div><details><summary>Transient properties: a new approach to deep selection and update in maps and arrays</summary><div class="markup"><p>After exploring many alternatives, I have come to the conclusion that we can't solve the problem of deep navigation and transformation of JSON structures without a data model change.</p>
<p>Most of the problems boil down to this: JSON trees do not have parent pointers, therefore after navigating down to a leaf node of the tree, we cannot get any information from higher up the tree. The solution to this (the "zipper" model) is to retain transient information about how a particular node in the tree was reached, so that we can retrace our steps and revisit nodes that were passed en route.</p>
<p>The change I propose is quite minor, but powerful: Any XDM value can be augmented with a set of transient properties represented as a set of key-value pairs. These properties are ignored (and typically dropped) by all operations on a value, except where otherwise specified. For the purpose of exposition, I'll use the syntax <code>$value¶name</code> to refer to the transient <code>name</code> property of <code>$value</code>.</p>
<p>We'll change the semantics of <code>map:get()</code> and <code>array:get()</code>, and the associated lookup operators, so that the resulting values have transient properties indicating how they were selected. For example, given</p>
<p><code>let $name := $person?firstName</code></p>
<p>the resulting value (perhaps the string "Michael") will be augmented with transient properties</p>
<ul>
<li>¶parent - the map from which the value was selected (retaining its own transient properties if any)</li>
<li>¶key - the key used to make the selection, here "firstName"</li>
</ul>
<p>and derived properties:</p>
<ul>
<li>¶ancestors - the transitive closure of ¶parent</li>
<li>¶root - the last ¶ancestor</li>
<li>¶path - a string representation of the path used to select the value</li>
</ul>
<p>We can also define other "downward selection" operations such as <code>map:find</code>, and <code>array:foot</code> to retain these transient properties. So for example <code>map:find($json, 'firstname')[.='Michael']¶parent?surname</code> now finds the surnames of anyone named 'Michael', at any depth of the tree.</p>
<p>If we turn back to the use cases in my 2016 paper on transforming JSON</p>
<p>https://www.saxonica.com/papers/xmlprague-2016mhk.pdf</p>
<p>The first use case (bulk update) relied on matching items expressed in XML as</p>
<p><code>match="map[array[@key='tags']/string='ice']/number[@key='price']/text()"</code></p>
<p>which couldn't be done in JSON because of the inability to match based on ancestor context. With the new transient properties we can match this as</p>
<p><code>match="type(xs:integer)[¶key = 'price'][¶parent?tags?* = 'ice']"</code></p>
<p>In the second use case (hierarchic inversion), we can again get properties of parent or ancestor maps</p>
<p><code>$students ! map:put("course", ¶parent?name)</code></p>
<p>I think we can also use this to define deep update operations. But I'll leave that investigation until later.</p>
<p>Note: transient properties potentially have many other applications, for example we might use them to solve our problems with <code>document-uri()</code>. But exploring that would be a distraction here. The nice thing about transient properties is that they give a lot of potential for augmenting existing functionality with full backwards compatibility, because we can define existing operations to return results with additional transient properties that all existing operations will ignore. If we were so minded, for example, we could have different functions/operators return "quiet NaN" and "signalling NaN" by adding a transient property to the NaN value returned.</p>
</div></details></div>
<div class="toot" id="created-333"><h2>Issue #333 created<span class="toot-id"> #created-333</span></h2><div class="pubdate">01 Feb at 00:34:41 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/333">https://github.com/qt4cg/qtspecs/issues/333</a></div><details><summary>Equality of function items</summary><div class="markup"><p>The question of equality of function items arises in the discussion of determinism of functions and memo functions in XSLT - see F&amp;O 3.1 section 1.7.4, and came up again today in the context of fn:deep-equal.</p>
<p>1.7.4 makes a brave attempt to describe situations under which two functions are "identical", though leaving implementations room for flexibility. I think we can build on this and improve it, by describing more situations in which the result is predictable.</p>
<p>The data model describes the properties of a function item, and we can say that two function items are equivalent if all their properties are the same.</p>
<p>The properties that cause problems are the "implementation" and the "closure", and in both cases I think we can find ways of doing a comparison.</p>
<p>For the implementation, we can define this by reference to the way in which the implementation property is set. For function items constructed by reference to static functions (e.g. <code>my:func#3</code> or <code>function-lookup(my:func, 3)</code>) then they have the same implementation if and only if they are constructed by reference to the same static function. Similarly for function items constructed by evaluating an inline function expression. Other ways of constructing a function item, such as partial application, essentially create a new function with the same implementation as an existing function and a different closure.</p>
<p>For the closure (ignoring for the moment functions that include parts of the dynamic context in their closure), this is essentially just a set of variable bindings and it's not too difficult to say that functions are identical if these sets of variable bindings are identical.</p>
</div></details></div>
<div class="toot" id="created-332"><h2>Issue #332 created<span class="toot-id"> #created-332</span></h2><div class="pubdate">31 Jan at 18:51:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/332">https://github.com/qt4cg/qtspecs/issues/332</a></div><details><summary>Add a namespace uris option to fn:path</summary><div class="markup"><p>The output of <code>fn;path</code> using namespaces is very verbose as it is specified to use the <code>Q{uri}name</code> syntax. It would be useful if it was extended to take a namespace prefix to uri map.</p>
<ol>
<li>Add a second <code>$namespaces</code> parameter that has the type <code>map(union(xs:NCName, enum('')), xs:anyURI)</code> (the same as fn:in-scope-namespaces) -- this will have a default value of <code>map{}</code> to preserve the existing behaviour.</li>
<li>If the namespace uri is in the map, use the given prefix. If that prefix is "" then just use the local name.</li>
<li>If the namespace uri is not in the map, use the <code>Q{uri}name</code> syntax.</li>
</ol>
<p>This allows for things like <code>fn:path($e, namespaces := fn:in-scope-namespaces())</code>.</p>
</div></details></div>
<div class="toot" id="created-331"><h2>Issue #331 created<span class="toot-id"> #created-331</span></h2><div class="pubdate">31 Jan at 18:43:14 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/331">https://github.com/qt4cg/qtspecs/issues/331</a></div><details><summary>Extend fn:path to support arrays and maps.</summary><div class="markup"><p>Currently, <code>fn:path</code> is defined for nodes. This means it is not possible to use it with arrays or maps (e.g. to determine the path to a JSON item when a comparison fails).</p>
<p>As such, I recommend:</p>
<ol>
<li>changing the type to <code>item()</code></li>
<li>If the value is a node use the current logic.</li>
<li>If the value is in an array, use <code>?n</code> where n is the nth item of the array where the item is located.</li>
<li>If the value is in a map, use <code>?name</code> or <code>?"name"</code> where name is the key name of the map where the item is located.</li>
<li>If the value is an atomic item, or the root of a map/array structure, use <code>.</code>.</li>
</ol>
<p>Example: <code>.?4?user?name</code></p>
</div></details></div>
<div class="toot" id="minutes-01-31"><h2>QT4 CG meeting 020 draft minutes<span class="toot-id"> #minutes-01-31</span></h2><div class="pubdate">31 Jan at 17:12:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/01-31">https://qt4cg.org/meeting/minutes/2023/01-31</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-330"><h2>Pull request #330 created<span class="toot-id"> #created-330</span></h2><div class="pubdate">31 Jan at 12:56:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/330">https://github.com/qt4cg/qtspecs/pull/330</a></div><details><summary>Update fn:parse-html to apply review feedback.</summary><div class="markup"><p>This PR applies the following review comments:</p>
<ul>
<li>[x] QT4CG-016-03: RD to add a note clarifying “known character encoding”</li>
<li>[x] QT4CG-016-04: RD to add a note clarifying the “<em>”/”</em>” html/version combination</li>
<li>[x] QT4CG-016-05: RD to add a “todo” noting the dependency on keyword arguments</li>
<li>[x] QT4CG-016-06: RD to reword the introduction to mapping to clarify who’s doing the mapping</li>
<li>[ ] QT4CG-016-08: RD to clarify how namespace comparisons are performed.</li>
<li>[x] QT4CG-016-09: RD to add a note stating that the local name should always be lowercase</li>
<li>[x] QT4CG-016-10: RD to consider how to clarify parsed entity parsing.</li>
</ul>
</div></details></div>
<div class="toot" id="created-329"><h2>Issue #329 created<span class="toot-id"> #created-329</span></h2><div class="pubdate">30 Jan at 11:45:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/329">https://github.com/qt4cg/qtspecs/issues/329</a></div><details><summary>Keyword parameters: Error codes</summary><div class="markup"><p>I’ve read the current specification twice, and I have checked the existing qt4 tests, but I’m still confused by the exact meaning of the new error codes for keyword arguments, <code>XPST0141</code> and <code>XPST0142</code>. Things are getting particularly tricky if we consider partial function applications.</p>
<p>My proposal would be to simplify the current approach and:</p>
<ol>
<li>use the existing error code <code>XPST0017</code> for all cases in which a function cannot be chosen as the available arguments (both positional and keyword-based) don’t match the function definition, and</li>
<li>only raise a new error code (<code>XPST0141</code>, possibly) if a keyword argument has been specified more than once (as this can be done without checking the function definitions).</li>
</ol>
</div></details></div>
<div class="toot" id="created-328"><h2>Issue #328 created<span class="toot-id"> #created-328</span></h2><div class="pubdate">30 Jan at 10:05:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/328">https://github.com/qt4cg/qtspecs/issues/328</a></div><details><summary>Switch Cases: Lift single-item restriction on operands</summary><div class="markup"><h2>Motivation</h2>
<p><a href="https://www.w3.org/TR/xquery-31/#id-switch">XQuery switch cases</a> have a peculiar restriction: The operand of a single case must yield an empty sequence or a single item. There seem to be no (obvious) reasons why this restriction exists, so I believe we should lift it and allow arbitrary sequences.</p>
<p>A similar extension is planned for Java 12 (<a href="http://openjdk.java.net/jeps/325">JEP 325: Switch Expressions</a>). The required changes in XQuery are simpler, though, as the 3.1 grammar already supports arbitrary expressions as operands.</p>
<h2>Examples</h2>
<pre><code class="language-xquery">switch($value)
  case 1
  case 2
  case 3
  case 4
  case 5
    return 'small'
  default
    return 'big'
</code></pre>
<p>Proposed syntax:</p>
<pre><code class="language-xquery">switch($value)
  case 1 to 5
    return 'small'
  default
    return 'big'
</code></pre>
<h2>Required Changes</h2>
<p>The <a href="https://www.w3.org/TR/xquery-31/#id-switch">current matching rules</a> could be rephrased as follows:</p>
<ol>
<li>The SwitchCaseOperand is evaluated.</li>
<li>The resulting value is atomized.</li>
<li>The case matches if the value is empty and if the value of the switch expression is empty as well.</li>
<li>Otherwise, the atomized value of the switch operand expression is compared with each item of the atomized value of the SwitchCaseOperand using <code>fn:deep-equal</code>, with the default collation from the static context.</li>
</ol>
<h2>References</h2>
<ul>
<li>Original Proposal: https://github.com/expath/xpath-ng/pull/12</li>
<li>Discussion on Slack: https://xmlcom.slack.com/archives/C011NLXE4DU/p1675006336963479</li>
</ul>
</div></details></div>
<div class="toot" id="agenda-01-31"><h2>QT4 CG meeting 020 draft agenda<span class="toot-id"> #agenda-01-31</span></h2><div class="pubdate">30 Jan at 08:47:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/01-31">https://qt4cg.org/meeting/agenda/2023/01-31</a></div><p>Draft agenda published.</p></div></div><p>See 137
            more statuses in yearly archives.</p></article></main></body></html>