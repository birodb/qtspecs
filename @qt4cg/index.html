<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="minutes-05-23"><h2>QT4 CG meeting 035 draft minutes<span class="toot-id"> #minutes-05-23</span></h2><div class="pubdate">23 May at 17:20:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/05-23">https://qt4cg.org/meeting/minutes/2023/05-23</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-396"><h2>Issue #396 closed<span class="toot-id"> #closed-396</span></h2><div class="pubdate">23 May at 16:15:20 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/396">https://github.com/qt4cg/qtspecs/pull/396</a></div><p>333: Deep-equal, no failure when comparing functions</p></div>
<div class="toot" id="created-520"><h2>Issue #520 created<span class="toot-id"> #created-520</span></h2><div class="pubdate">23 May at 11:58:37 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/520">https://github.com/qt4cg/qtspecs/issues/520</a></div><details><summary>Function identity</summary><div class="markup"><p>To make deep-equal error-free for all arguments (issue #333), and to support the introduction of sets (issue #34), we need to be able to test whether two functions are "the same function". This is a proposed pragmatic solution.</p>
<p>We change the data model for functions so that functions, like nodes, have an identity that is acquired when the function is created; two functions are identical if and only if they have the same identity.</p>
<p>In general any expression that returns a new function allocates it an identity that is different from all other existing functions (as with nodes). However:</p>
<ul>
<li>Repeated evaluation of a function reference such as count#1 returns the same function each time, provided that the target function is context-free.</li>
<li>Optimizers are allowed to rewrite expressions (for example by loop-lifting, etc) so that expressions that would in principle return distinct functions actually return the same function, provided the optimizer can determine that the two functions are equivalent in all respects other than their identity. For example if the expression <code>contains(?, 'xxx')</code> appears in a loop, the expression can be lifted out of the loop so there is no requirement that it returns different functions each time (as there is with nodes)</li>
</ul>
<p>Benefits of this approach:</p>
<ul>
<li>identical($x, $x) is always true (function identity survives binding to variables)</li>
<li>functions obtained by repeated evaluation of the same expression in the same context are likely to return identical results in cases that are simple enough for an optimizer to analyse</li>
<li>the results are likely to be reasonably intuitive</li>
<li>optimisers aren't constrained by rules on identity to restrict the rewrites they can attempt</li>
</ul>
<p>This does mean that expressions that return functions become a little impure - but only in the same way that expressions that create nodes are a little impure. The impurity is well understood and tolerated.</p>
<p>Maps and arrays do not have identity as a property separate from their content.</p>
</div></details></div>
<div class="toot" id="created-519"><h2>Pull request #519 created<span class="toot-id"> #created-519</span></h2><div class="pubdate">23 May at 10:50:52 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/519">https://github.com/qt4cg/qtspecs/pull/519</a></div><details><summary>237: Revise tokenisation appendix</summary><div class="markup"><p>This PR is an extensive revision to the rules for tokenisation that corrects a number of errors:</p>
<ul>
<li>The problem mentioned in issue 237, namely the lack of clarity in the "longest token rule". This PR fixes this by clarifying what this rule means and where it applies. In particular it tackles the issue of "complex terminals" such as element constructor expressions and string templates where a symbol that is a single token at one level (in the sense that whitespace is constrained) also contains enclosed expressions.</li>
<li>Some productions/tokens were misclassified or omitted from the relevant lists of tokens in the appendix. This has been fixed in part by using general rules in the grammar2spec stylesheet to generate lists of tokens, rather than relying on annotations in the grammar file.</li>
</ul>
<p>The PR includes changes to the grammar2spec stylesheet.</p>
</div></details></div>
<div class="toot" id="created-518"><h2>Issue #518 created<span class="toot-id"> #created-518</span></h2><div class="pubdate">22 May at 16:45:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/518">https://github.com/qt4cg/qtspecs/issues/518</a></div><details><summary>transitive-closure() function</summary><div class="markup"><p>I've just found myself writing, yet again, a transitive closure function, and I feel we could add this to the spec.</p>
<p>I'm afraid it's another case where we really need set operations and therefore a universal equality operator. For the moment I'll just define it over nodes, which shelves the problem.</p>
<p><code>fn:transitive-closure($start as node()*, $step as function($node as node()) as node()*) as node()*</code></p>
<p>returns the set of all nodes reachable from a node in $start by zero or more applications of the $step function, in document order with duplicates removed.</p>
<p>Can probably define it formally something like</p>
<pre><code>let $next-iteration := $start =!&gt; $step()
return if (empty($next-iteration except $start))
           then $start
           else transitive-closure($start | $next-iteration, $step)
</code></pre>
</div></details></div>
<div class="toot" id="created-517"><h2>Issue #517 created<span class="toot-id"> #created-517</span></h2><div class="pubdate">21 May at 01:43:18 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/517">https://github.com/qt4cg/qtspecs/issues/517</a></div><details><summary>FO: fn:multi-compose : Evaluate a chain of functions in order</summary><div class="markup"><h1><strong>FO: fn:multi-compose : Evaluate a chain of functions</strong></h1>
<p>As per Wikipedia:</p>
<p>" In&nbsp;<a href="https://en.wikipedia.org/wiki/Mathematics">mathematics</a>,&nbsp;<strong>function composition</strong>&nbsp;is an operation&nbsp; ∘ &nbsp;that takes two&nbsp;<a href="https://en.wikipedia.org/wiki/Function_(mathematics)">functions</a>&nbsp;<em>f</em>&nbsp;and&nbsp;<em>g</em>, and produces a function&nbsp;</p>
<p><em>h</em>&nbsp;=&nbsp;<em>g</em>&nbsp; ∘  <em>f</em>&nbsp;such that&nbsp;<em>h</em>(<em>x</em>) =&nbsp;<em>g</em>(<em>f</em>(<em>x</em>)).</p>
<p>In this operation, the function&nbsp;<em>g</em>&nbsp;is&nbsp;<a href="https://en.wikipedia.org/wiki/Function_application">applied</a>&nbsp;to the result of applying the function&nbsp;<em>f</em>&nbsp;to&nbsp;<em>x</em>. That is, the functions&nbsp;</p>
<p><em>f</em> :&nbsp;<em>X</em>&nbsp;→&nbsp;<em>Y</em>&nbsp;and&nbsp;<em>g</em> :&nbsp;<em>Y</em>&nbsp;→&nbsp;<em>Z</em>&nbsp;</p>
<p>are&nbsp;<strong>composed</strong>&nbsp;to yield a function that maps&nbsp;<em>x</em>&nbsp;in&nbsp;<a href="https://en.wikipedia.org/wiki/Domain_of_a_function">domain</a>&nbsp;<em>X</em>&nbsp;to&nbsp;<em>g</em>(<em>f</em>(<em>x</em>))&nbsp;in&nbsp;<a href="https://en.wikipedia.org/wiki/Codomain">codomain</a>&nbsp;<em>Z</em>.</p>
<p>Intuitively, if&nbsp;<em>z</em>&nbsp;is a function of&nbsp;<em>y</em>, and&nbsp;<em>y</em>&nbsp;is a function of&nbsp;<em>x</em>, then&nbsp;<em>z</em>&nbsp;is a function of&nbsp;<em>x</em>.</p>
<p>The resulting&nbsp;<em>composite</em>&nbsp;function is denoted&nbsp;<em>g</em> ∘ <em>f</em>&nbsp;:&nbsp;<em>X</em>&nbsp;→&nbsp;<em>Z</em>, defined by:</p>
<p>&nbsp;(<em>g</em> ∘ <em>f</em> )(<em>x</em>) =&nbsp;<em>g</em>(<em>f</em>(<em>x</em>))&nbsp;for all&nbsp;<em>x</em>&nbsp;in&nbsp;<em>X</em>
"</p>
<hr>
<p>In this Proposal we generalize function composition to the case when a sequence of functions are composed together, so that the last one is applied on an argument $x, then  the last-but-one is applied on the result of this application, and so on … until finally the first function in the sequence is applied on the result produced so far.</p>
<p>This is an effective way of chaining a sequence of functions together, and we don’t need to invent or use any special operators or syntax, but we just pass this sequence of functions as argument to <strong><em>fn:multi-compose</em></strong>.</p>
<p><strong>fn:multi-compose := function($funs as function(*)*, $x)</strong></p>
<p><strong>Here is an XPath 3.0 implementation of fn:multi-compose</strong>:</p>
<pre><code class="language-xq">let $apply := function($f, $x) {fn:apply($f, [$x])},
    $multi-compose := function($funs as function(*)*, $x)
                  {
                    fold-right($funs, $x, $apply)
                  },
    (: The functions $incr and $times are needed just to show this example :) 
    $incr := function($x) {op("+")(?, $x)},
    $times := function($y) {op("*")(?, $y)}                 
                  
 return
   $multi-compose(($times(5), $incr(1)), 2)
</code></pre>
<p>As wanted, the result of evaluating this is</p>
<p>15: (2 +1) * 5</p>
<h2>Remarks</h2>
<ol>
<li>
<p>In this implementation the type of the 2nd (last) argument of <strong><em>$multi-compose</em></strong> and <strong><em>$apply</em></strong> is <code>item()*</code> (any) and as such it is omitted. In case the function to be applied first, needs  more than one argument, all of its arguments must be presented in the function call as a single sequence , and are passed (in order) as the members of a single array, as already implemented by the standard <strong><a href="https://www.w3.org/TR/xpath-functions-31/#func-apply">fn:apply</a></strong>.</p>
</li>
<li>
<p>It is a dynamic error if any of the function applications produces a result which does not belong to the Domain of the function immediately preceding it in the function sequence.</p>
</li>
</ol>
</div></details></div>
<div class="toot" id="closed-181"><h2>Issue #181 closed<span class="toot-id"> #closed-181</span></h2><div class="pubdate">20 May at 18:32:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/181">https://github.com/qt4cg/qtspecs/issues/181</a></div><p>HOF Sequence Functions with Positional Arguments</p></div>
<div class="toot" id="created-516"><h2>Issue #516 created<span class="toot-id"> #created-516</span></h2><div class="pubdate">20 May at 18:12:06 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/516">https://github.com/qt4cg/qtspecs/issues/516</a></div><details><summary>Add position argument to filter/for-each callbacks</summary><div class="markup"><p>The coercion rules now allow a supplied function item to have lower arity than the signature of the declared type; the effect is that the information supplied in the additional arguments is ignored.</p>
<p>One of the intended use cases for this was to allow existing higher-order functions to be extended while retaining backwards compatibility. For example, in <code>fn:filter</code>, we can change the required type of the predicate function from <code>function(item()) as xs:boolean</code> to <code>function(item(), xs:positiveInteger) as xs:boolean</code>, with the second argument supplying the position of the item being tested. A function that isn't interested in the position can just ignore it, so existing calls will continue to work.</p>
<p>I propose that we add a position argument to the callbacks for:</p>
<pre><code>fn:filter
fn:for-each
fn:for-each-pair
fn:partition
fn:items-after
fn:items-before
fn:items-starting-where
fn:items-ending-where
array:filter
array:for-each
array:for-each-pair
</code></pre>
<p>Other candidates include</p>
<pre><code>fn:all
fn:some
fn:index-where
array:index-where
</code></pre>
<p>but I suggest we leave these unless someone can think of a use case.</p>
</div></details></div>
<div class="toot" id="agenda-05-23"><h2>QT4 CG meeting 035 draft agenda<span class="toot-id"> #agenda-05-23</span></h2><div class="pubdate">20 May at 10:15:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/05-23">https://qt4cg.org/meeting/agenda/2023/05-23</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="closed-471"><h2>Issue #471 closed<span class="toot-id"> #closed-471</span></h2><div class="pubdate">20 May at 10:04:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/471">https://github.com/qt4cg/qtspecs/issues/471</a></div><p>Unify formatting (function calls, code blocks, quotes) in the specification</p></div>
<div class="toot" id="closed-511"><h2>Issue #511 closed<span class="toot-id"> #closed-511</span></h2><div class="pubdate">20 May at 10:04:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/511">https://github.com/qt4cg/qtspecs/pull/511</a></div><p>471: &lt;code&gt; elements, simple/typographic quotes</p></div>
<div class="toot" id="created-515"><h2>Pull request #515 created<span class="toot-id"> #created-515</span></h2><div class="pubdate">20 May at 09:57:04 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/515">https://github.com/qt4cg/qtspecs/pull/515</a></div><p>504: Merge map:keys and map:keys-where</p></div>
<div class="toot" id="created-514"><h2>Issue #514 created<span class="toot-id"> #created-514</span></h2><div class="pubdate">20 May at 08:44:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/514">https://github.com/qt4cg/qtspecs/issues/514</a></div><details><summary>Lambda expression: Annotations</summary><div class="markup"><p><strong>Edit 2023-05-21:</strong> Feedback was incorporated.</p>
<p>In the current grammar rules, there are subtle differences in the <code>InlineFunctionExpr</code> and <code>LambdaExpr</code> rules that we should dissolve.</p>
<p>Annotations are not supported in lambda expressions, which I believe is an unnecessary restriction:</p>
<pre><code class="language-xquery">(: currently legal :)
let $delete-texts := %updating function($nodes) { delete nodes $nodes//text() }
return $delete-texts(//city)

(: currently illegal :)
let $delete-texts := %updating ($nodes) -&gt; { delete nodes $nodes//text() }
return $delete-texts(//city)
</code></pre>
<p>It should suffice to extend one rule in the grammar:</p>
<pre><code>(: old :)
LambdaExpr  ::=  LambdaParams "-&gt;" EnclosedExpr
(: new :)
LambdaExpr  ::=  Annotation* LambdaParams "-&gt;" EnclosedExpr
</code></pre>
<hr>
<p>We could also type declarations (as @michaelhkay has indicated below, though, this might not be as simple to realize as I hoped):</p>
<pre><code class="language-xquery">(: currently legal :)
let $find-john := function($node as node()) as xs:boolean { contains($node, 'john') }
return $find-john($node)

(: currently illegal :)
let $find-john := ($node as node()) as xs:boolean -&gt; { contains($node, 'john') }
return $find-john($node)
</code></pre>
<p>The type declarations cannot be allowed if parentheses are omitted (unless we make them mandatory):</p>
<pre><code class="language-xquery">(: without parens :)
$i -&gt; { ... }

(: parens :)
($i as xs:int) as xs:int -&gt; { ... }
</code></pre>
<p>These are the current grammar rules:</p>
<pre><code>FunctionItemExpr    ::=  NamedFunctionRef | InlineFunctionExpr | LambdaExpr
InlineFunctionExpr  ::=  Annotation* "function" FunctionSignature FunctionBody
FunctionSignature   ::=  "(" ParamList? ")" TypeDeclaration?
ParamList           ::=  Param ("," Param)*
Param               ::=  "$" EQName TypeDeclaration?
FunctionBody        ::=  EnclosedExpr
LambdaExpr          ::=  LambdaParams "-&gt;" EnclosedExpr
LambdaParams        ::=  LambdaParam | "(" | (LambdaParam ("," LambdaParam)*)? | ")"
LambdaParam         ::=  "$" VarName
</code></pre>
<p>As the <code>InlineFunctionExpr</code> and <code>LambdaExpr</code> both generate anonymous functions, we shouldn’t make a difference, and this is what I would recommend:</p>
<pre><code>FunctionItemExpr    ::=  NamedFunctionRef | InlineFunctionExpr
InlineFunctionExpr  ::=  Annotation* (InlineFunction | LambdaFunction) FunctionBody
InlineFunction      ::=  "function" FunctionSignature
LambdaFunction      ::=  (Param | FunctionSignature)) "-&gt;"
FunctionSignature   ::=  "(" ParamList? ")" TypeDeclaration?
ParamList           ::=  TypedParam ("," TypedParam)*
TypedParam          ::=  Param TypeDeclaration?
Param               ::=  "$" VarName
</code></pre>
<p>Disclaimer: I could have raised this earlier, but I didn’t want to prolong the ongoing discussion on the open pull requests.</p>
</div></details></div>
<div class="toot" id="created-513"><h2>Issue #513 created<span class="toot-id"> #created-513</span></h2><div class="pubdate">20 May at 08:00:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/513">https://github.com/qt4cg/qtspecs/issues/513</a></div><details><summary>Arrow operator: Inline functions without parens</summary><div class="markup"><p>See also https://github.com/qt4cg/qtspecs/issues/435#issuecomment-1508228624: If an inline function expression is used as the right-hand operand of the arrow operators, parentheses must be used:</p>
<pre><code class="language-xquery">(: now :)
$seq =&gt; (function($x) { ... })()
(: desirable :)
$seq =&gt; function($x) { ... }()
</code></pre>
<p>This could be changed by adding the <code>InlineFunctionExpr</code> to the <code>ArrowDynamicFunction</code> rule:</p>
<blockquote>
<p>[115]  SequenceArrowTarget  ::=  "=&gt;" ((ArrowStaticFunction ArgumentList) | (ArrowDynamicFunction PositionalArgumentList))
[151]  ArrowStaticFunction  ::=  EQName
[152]  ArrowDynamicFunction  ::=  VarRef | ParenthesizedExpr | <code>InlineFunctionExpr</code>
[142]  ArgumentList  ::=  "(" ((PositionalArguments ("," KeywordArguments)?) | KeywordArguments)? ")"
[143]  PositionalArgumentList  ::=  "(" PositionalArguments? ")"</p>
</blockquote>
<p>It will be best to tackle this after we’ve resolved #503, and we’ll have to check if the simplification doesn’t cause ambiguities.</p>
</div></details></div>
<div class="toot" id="closed-53"><h2>Issue #53 closed<span class="toot-id"> #closed-53</span></h2><div class="pubdate">19 May at 20:01:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/53">https://github.com/qt4cg/qtspecs/issues/53</a></div><p>Allow function keyword inline functions without parameters</p></div>
<div class="toot" id="closed-436"><h2>Issue #436 closed<span class="toot-id"> #closed-436</span></h2><div class="pubdate">19 May at 20:00:53 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/436">https://github.com/qt4cg/qtspecs/issues/436</a></div><p>Allow inline function expressions in arrow operator call chains</p></div>
<div class="toot" id="closed-435"><h2>Issue #435 closed<span class="toot-id"> #closed-435</span></h2><div class="pubdate">19 May at 20:00:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/435">https://github.com/qt4cg/qtspecs/issues/435</a></div><p>Remove the inlined function expression variant of the thin arrow operator</p></div>
<div class="toot" id="created-512"><h2>Pull request #512 created<span class="toot-id"> #created-512</span></h2><div class="pubdate">19 May at 14:47:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/512">https://github.com/qt4cg/qtspecs/pull/512</a></div><details><summary>256: Context for default function parameter expressions</summary><div class="markup"><p>This is a renewed attempt to tackle issue 256, which concerns how to define the static and dynamic context for default value expressions for optional function parameters in XQuery and XSLT. The resolution is to define the static and dynamic context for these expressions in detail.</p>
<p>To make this work, some refinement of the static and dynamic context definitions is needed:</p>
<ul>
<li>default collation is moved from the static context to the dynamic context, with a note that it is always known statically except in the case when defining the default for a function parameter.</li>
<li>static base URI (in the static context) and executable base URI (in the dynamic context) are now formally separated; previously we fudged this by saying they could be different, but without recognizing separate context components</li>
<li>the base URI for resolving relative collation URIs is now implementation defined. This allows implementors to use either the compile-time or run-time base URI, or some other URI defined using a processor API.</li>
</ul>
</div></details></div>
<div class="toot" id="created-511"><h2>Pull request #511 created<span class="toot-id"> #created-511</span></h2><div class="pubdate">19 May at 13:10:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/511">https://github.com/qt4cg/qtspecs/pull/511</a></div><details><summary>471: &lt;code&gt; elements, simple/typographic quotes</summary><div class="markup"><p>That was a work-intensive one, as expected, but I’m optimistic that the PR improves the overall situation.
I’ll be happy to see subsequent PRs if I missed something (e.g., I didn’t touch <code>ebnf.xml</code>).</p>
<p>Closes #471</p>
</div></details></div>
<div class="toot" id="closed-509"><h2>Issue #509 closed<span class="toot-id"> #closed-509</span></h2><div class="pubdate">19 May at 09:08:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/509">https://github.com/qt4cg/qtspecs/pull/509</a></div><p>471 (2): Remove more fn: prefixes</p></div>
<div class="toot" id="closed-510"><h2>Issue #510 closed<span class="toot-id"> #closed-510</span></h2><div class="pubdate">19 May at 09:08:28 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/510">https://github.com/qt4cg/qtspecs/pull/510</a></div><p>471 (3): Render false/true/NaN/INF/-INF/+INF as code</p></div>
<div class="toot" id="closed-375"><h2>Issue #375 closed<span class="toot-id"> #closed-375</span></h2><div class="pubdate">19 May at 08:48:02 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/375">https://github.com/qt4cg/qtspecs/pull/375</a></div><p>256: Context for default parameter values</p></div>
<div class="toot" id="closed-507"><h2>Issue #507 closed<span class="toot-id"> #closed-507</span></h2><div class="pubdate">19 May at 08:06:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/507">https://github.com/qt4cg/qtspecs/pull/507</a></div><p>125: Rename array:partition as fn:partition</p></div>
<div class="toot" id="closed-505"><h2>Issue #505 closed<span class="toot-id"> #closed-505</span></h2><div class="pubdate">18 May at 17:25:58 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/505">https://github.com/qt4cg/qtspecs/pull/505</a></div><p>418: Correct and expand an XSLT example</p></div>
<div class="toot" id="closed-447"><h2>Issue #447 closed<span class="toot-id"> #closed-447</span></h2><div class="pubdate">18 May at 17:24:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/447">https://github.com/qt4cg/qtspecs/pull/447</a></div><p>435, 53, 436: lambda expressions, thin arrows</p></div>
<div class="toot" id="closed-410"><h2>Issue #410 closed<span class="toot-id"> #closed-410</span></h2><div class="pubdate">18 May at 16:57:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/410">https://github.com/qt4cg/qtspecs/issues/410</a></div><p>Converting doubles to decimals, fractional digits</p></div>
<div class="toot" id="closed-455"><h2>Issue #455 closed<span class="toot-id"> #closed-455</span></h2><div class="pubdate">18 May at 16:57:52 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/455">https://github.com/qt4cg/qtspecs/pull/455</a></div><p>410: Converting doubles to decimals, fractional digits</p></div>
<div class="toot" id="closed-483"><h2>Issue #483 closed<span class="toot-id"> #closed-483</span></h2><div class="pubdate">18 May at 16:53:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/483">https://github.com/qt4cg/qtspecs/pull/483</a></div><p>452: window: make 'start' and 'when' optional</p></div>
<div class="toot" id="created-510"><h2>Pull request #510 created<span class="toot-id"> #created-510</span></h2><div class="pubdate">18 May at 16:14:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/510">https://github.com/qt4cg/qtspecs/pull/510</a></div><details><summary>471 (3): Render false/true/NaN/INF/-INF/+INF as code</summary><div class="markup"><p><code>NaN</code>, <code>INF</code>, <code>-INF</code> and <code>+INF</code> was easy, boolean values were trickier:</p>
<ul>
<li>I used <code>&lt;code&gt;</code> for “The result/value/option/property is true/false”, “is set to true/false” and similar.</li>
<li>I didn’t tag “This is true/false”, “The condition is true/false”  and similar.</li>
</ul>
<p>I hope there won’t be too many conflicts if this is directly merged after #509.</p>
</div></details></div>
<div class="toot" id="created-509"><h2>Pull request #509 created<span class="toot-id"> #created-509</span></h2><div class="pubdate">18 May at 12:38:02 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/509">https://github.com/qt4cg/qtspecs/pull/509</a></div><details><summary>471 (2): Remove more fn: prefixes</summary><div class="markup"><p>I’ve removed additional <code>fn:</code> prefixes from examples and <code>eg</code> code blocks. I have kept prefixes in the rules and formal code snippets untouched.</p>
<p>In the initial comment of #471, I have listed the remaining cleanups for which I want to prepare PRs.
I’ll wait until this and possibly some other PRs have been merged.</p>
</div></details></div></div><p>See 907
            more statuses in yearly archives.</p></article></main></body></html>