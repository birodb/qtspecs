<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="agenda-05-30"><h2>QT4 CG meeting 036 draft agenda<span class="toot-id"> #agenda-05-30</span></h2><div class="pubdate">29 May at 07:53:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/05-30">https://qt4cg.org/meeting/agenda/2023/05-30</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-528"><h2>Issue #528 created<span class="toot-id"> #created-528</span></h2><div class="pubdate">28 May at 20:08:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/528">https://github.com/qt4cg/qtspecs/issues/528</a></div><details><summary>Review of the fn:json() function</summary><div class="markup"><p>I've been writing tests for the fn:json function, whose spec I haven't read for quite a while, so it's an opportunity (a) to request WG review of the spec, and (b) for some minor comments.</p>
<ol>
<li>I think a better name for the function might be <code>fn:to-json</code>. Any other suggestions?</li>
<li>Where we specify that a JSON object should be output with particular properties, I think we should be consistent about whether or not we prescribe the order. Writing tests is a lot easier if the order is always prescribed!</li>
<li>Document nodes: it would be better to output both the document URI and the base URI where available.</li>
<li>Under "The children of the element are processed as follows" there are four rules. In the case where an element has just one element node child, I think rule 4 should apply rather than rule 3.</li>
<li>Under Processing-Instruction nodes: typo "A JSON object with a two properties".</li>
<li>The section starting "Strings are escaped as follows" should be promoted up a level.</li>
<li>Representing functions: I propose a different set of rules. (a) for a function that is a reference to a built-in or user-defined function definition, output "Q{uri}local#arity". (b) for an anonymous function, output "#anonymous-function". The rationale is that the JSON output here isn't going to be useful except as a placeholder to indicate that a function item is present.</li>
<li>We might want to be more prescriptive about how numbers are formatted (or to provide user options)</li>
<li>Like many XML-to-JSON libraries, there's the problem that two instances of the same element type might be output very differently depending on which children are present. For example the representation of a book with two authors might be very different from a book with one author. I would suggest that rather than the boolean <code>element-map</code> option, we allow the options to include a list of element names for which <code>object</code> representation rather than <code>array</code> representation is to be used.</li>
</ol>
</div></details></div>
<div class="toot" id="created-527"><h2>Pull request #527 created<span class="toot-id"> #created-527</span></h2><div class="pubdate">28 May at 10:24:27 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/527">https://github.com/qt4cg/qtspecs/pull/527</a></div><details><summary>Editorial: more corrections to F+O examples</summary><div class="markup"><p>Fixes errors in the fn:replace examples, updates elsewhere to reflect changes to the syntax of lambda expressions and focus functions.</p>
</div></details></div>
<div class="toot" id="created-526"><h2>Issue #526 created<span class="toot-id"> #created-526</span></h2><div class="pubdate">26 May at 21:22:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/526">https://github.com/qt4cg/qtspecs/issues/526</a></div><details><summary>load-xquery-module() needs changes to account for functions with an arity range</summary><div class="markup"><p>The spec of <code>load-xquery-module()</code> assumes that each function declaration in a query module has a single integer arity; this doesn't allow for default parameters which mean it now has an arity range.</p>
<p>Because the returned map contains function items, which always have a fixed arity, I think it needs to contain one entry for each arity in the arity range. This involves evaluating the defaults for any parameters that have a default value defined; if the default value is context dependent, this is going to have to use the context of the <code>load-xquery-module()</code> function call, which isn't very meaningful, but I can't see what else to do.</p>
<p>An alternative is to only include one function item in the result, corresponding to the maximum arity.</p>
<p>If we introduce sequence-variadic functions, the arity range becomes infinite, which makes both of these ideas problematic. But presumably sequence-variadic functions will be callable with all the values supplied in a single array?</p>
</div></details></div>
<div class="toot" id="created-525"><h2>Pull request #525 created<span class="toot-id"> #created-525</span></h2><div class="pubdate">26 May at 09:27:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/525">https://github.com/qt4cg/qtspecs/pull/525</a></div><details><summary>520: add function identity and use it in deep-equal</summary><div class="markup"><p>I believe this PR resolves issues</p>
<p>issue #520 - function identity
issue #333 - equality of function items
issue #381 - deep-equal comparison without errors</p>
<p>The PR introduces a concept of function identity in the data model, and for all expressions that create functions, explains what the identity of the returned function is.</p>
<p>The concept of function identity is used initially in two places: in fn:deep-equal(), when the operands include function items; and in the F+O prose defining the concept of determinism, which in turn is relied on by the definition of memo functions in XSLT.</p>
<p>I had hoped to go further and address issue #119, generalising what kinds of values are allowed as keys in maps, but as explained in a comment on that issue, I hit obstacles.</p>
</div></details></div>
<div class="toot" id="created-524"><h2>Pull request #524 created<span class="toot-id"> #created-524</span></h2><div class="pubdate">25 May at 10:09:47 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/524">https://github.com/qt4cg/qtspecs/pull/524</a></div><details><summary>503: reinstate focus functions</summary><div class="markup"><p>This PR reinstates "focus functions", using the syntax <code>function{EXPR}</code> rather than <code>-&gt;{EXPR}</code>. If accepted, this resolves issue #503.</p>
</div></details></div>
<div class="toot" id="created-523"><h2>Issue #523 created<span class="toot-id"> #created-523</span></h2><div class="pubdate">24 May at 23:28:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/523">https://github.com/qt4cg/qtspecs/issues/523</a></div><details><summary>Dealing with component name conflicts with library packages</summary><div class="markup"><h2>Override with visibility='hidden'</h2>
<pre><code class="language-xml">&lt;override&gt;
   &lt;template name='foo' visibility='hidden'/&gt;
&lt;/override&gt;
</code></pre>
<p>This change allows the using package to override a component without running into a potential naming conflict with another component in the using package or in another used package. Because the visibility is hidden, the component is not invokable from the using package.</p>
<h2>Accept with alias</h2>
<pre><code class="language-xml">&lt;accept component='template' names='foo' aliases='fu'/&gt;
</code></pre>
<p>This change allows the using package to accept components but with a different name.</p>
</div></details></div>
<div class="toot" id="closed-522"><h2>Issue #522 closed<span class="toot-id"> #closed-522</span></h2><div class="pubdate">24 May at 07:48:58 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/522">https://github.com/qt4cg/qtspecs/pull/522</a></div><p>function-catalog.xml: Original line endings reverted (modified by GitHub’s 'direct edit' feature)</p></div>
<div class="toot" id="created-522"><h2>Pull request #522 created<span class="toot-id"> #created-522</span></h2><div class="pubdate">24 May at 07:48:39 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/522">https://github.com/qt4cg/qtspecs/pull/522</a></div><details><summary>function-catalog.xml: Original line endings reverted (modified by GitHub’s 'direct edit' feature)</summary><div class="markup"><p>I learned it’s NOT advisable to use GitHub’s features to directly edit files in the browser. The newlines of <code>function-catalog.xml</code> of the original file seem to be changed.</p>
<p>This PR is restoring the original newlines.
Sorry for that.</p>
</div></details></div>
<div class="toot" id="created-521"><h2>Pull request #521 created<span class="toot-id"> #created-521</span></h2><div class="pubdate">23 May at 18:50:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/521">https://github.com/qt4cg/qtspecs/pull/521</a></div><p>518: Add transitive-closure() function</p></div>
<div class="toot" id="minutes-05-23"><h2>QT4 CG meeting 035 draft minutes<span class="toot-id"> #minutes-05-23</span></h2><div class="pubdate">23 May at 17:20:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/05-23">https://qt4cg.org/meeting/minutes/2023/05-23</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-504"><h2>Issue #504 closed<span class="toot-id"> #closed-504</span></h2><div class="pubdate">23 May at 16:18:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/504">https://github.com/qt4cg/qtspecs/issues/504</a></div><p>Merge map:keys and map:keys-where</p></div>
<div class="toot" id="closed-515"><h2>Issue #515 closed<span class="toot-id"> #closed-515</span></h2><div class="pubdate">23 May at 16:18:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/515">https://github.com/qt4cg/qtspecs/pull/515</a></div><p>504: Merge map:keys and map:keys-where</p></div>
<div class="toot" id="closed-396"><h2>Issue #396 closed<span class="toot-id"> #closed-396</span></h2><div class="pubdate">23 May at 16:15:20 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/396">https://github.com/qt4cg/qtspecs/pull/396</a></div><p>333: Deep-equal, no failure when comparing functions</p></div>
<div class="toot" id="created-520"><h2>Issue #520 created<span class="toot-id"> #created-520</span></h2><div class="pubdate">23 May at 11:58:37 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/520">https://github.com/qt4cg/qtspecs/issues/520</a></div><details><summary>Function identity</summary><div class="markup"><p>To make deep-equal error-free for all arguments (issue #333), and to support the introduction of sets (issue #34), we need to be able to test whether two functions are "the same function". This is a proposed pragmatic solution.</p>
<p>We change the data model for functions so that functions, like nodes, have an identity that is acquired when the function is created; two functions are identical if and only if they have the same identity.</p>
<p>In general any expression that returns a new function allocates it an identity that is different from all other existing functions (as with nodes). However:</p>
<ul>
<li>Repeated evaluation of a function reference such as count#1 returns the same function each time, provided that the target function is context-free.</li>
<li>Optimizers are allowed to rewrite expressions (for example by loop-lifting, etc) so that expressions that would in principle return distinct functions actually return the same function, provided the optimizer can determine that the two functions are equivalent in all respects other than their identity. For example if the expression <code>contains(?, 'xxx')</code> appears in a loop, the expression can be lifted out of the loop so there is no requirement that it returns different functions each time (as there is with nodes)</li>
</ul>
<p>Benefits of this approach:</p>
<ul>
<li>identical($x, $x) is always true (function identity survives binding to variables)</li>
<li>functions obtained by repeated evaluation of the same expression in the same context are likely to return identical results in cases that are simple enough for an optimizer to analyse</li>
<li>the results are likely to be reasonably intuitive</li>
<li>optimisers aren't constrained by rules on identity to restrict the rewrites they can attempt</li>
</ul>
<p>This does mean that expressions that return functions become a little impure - but only in the same way that expressions that create nodes are a little impure. The impurity is well understood and tolerated.</p>
<p>Maps and arrays do not have identity as a property separate from their content.</p>
</div></details></div>
<div class="toot" id="created-519"><h2>Pull request #519 created<span class="toot-id"> #created-519</span></h2><div class="pubdate">23 May at 10:50:52 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/519">https://github.com/qt4cg/qtspecs/pull/519</a></div><details><summary>237: Revise tokenisation appendix</summary><div class="markup"><p>This PR is an extensive revision to the rules for tokenisation that corrects a number of errors:</p>
<ul>
<li>The problem mentioned in issue 237, namely the lack of clarity in the "longest token rule". This PR fixes this by clarifying what this rule means and where it applies. In particular it tackles the issue of "complex terminals" such as element constructor expressions and string templates where a symbol that is a single token at one level (in the sense that whitespace is constrained) also contains enclosed expressions.</li>
<li>Some productions/tokens were misclassified or omitted from the relevant lists of tokens in the appendix. This has been fixed in part by using general rules in the grammar2spec stylesheet to generate lists of tokens, rather than relying on annotations in the grammar file.</li>
</ul>
<p>The PR includes changes to the grammar2spec stylesheet.</p>
</div></details></div>
<div class="toot" id="created-518"><h2>Issue #518 created<span class="toot-id"> #created-518</span></h2><div class="pubdate">22 May at 16:45:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/518">https://github.com/qt4cg/qtspecs/issues/518</a></div><details><summary>transitive-closure() function</summary><div class="markup"><p>I've just found myself writing, yet again, a transitive closure function, and I feel we could add this to the spec.</p>
<p>I'm afraid it's another case where we really need set operations and therefore a universal equality operator. For the moment I'll just define it over nodes, which shelves the problem.</p>
<p><code>fn:transitive-closure($start as node()*, $step as function($node as node()) as node()*) as node()*</code></p>
<p>returns the set of all nodes reachable from a node in $start by zero or more applications of the $step function, in document order with duplicates removed.</p>
<p>Can probably define it formally something like</p>
<pre><code>let $next-iteration := $start =!&gt; $step()
return if (empty($next-iteration except $start))
           then $start
           else transitive-closure($start | $next-iteration, $step)
</code></pre>
</div></details></div>
<div class="toot" id="created-517"><h2>Issue #517 created<span class="toot-id"> #created-517</span></h2><div class="pubdate">21 May at 01:43:18 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/517">https://github.com/qt4cg/qtspecs/issues/517</a></div><details><summary>FO: fn:multi-compose : Evaluate a chain of functions in order</summary><div class="markup"><h1><strong>FO: fn:multi-compose : Evaluate a chain of functions</strong></h1>
<p>As per Wikipedia:</p>
<p>" In&nbsp;<a href="https://en.wikipedia.org/wiki/Mathematics">mathematics</a>,&nbsp;<strong>function composition</strong>&nbsp;is an operation&nbsp; ∘ &nbsp;that takes two&nbsp;<a href="https://en.wikipedia.org/wiki/Function_(mathematics)">functions</a>&nbsp;<em>f</em>&nbsp;and&nbsp;<em>g</em>, and produces a function&nbsp;</p>
<p><em>h</em>&nbsp;=&nbsp;<em>g</em>&nbsp; ∘  <em>f</em>&nbsp;such that&nbsp;<em>h</em>(<em>x</em>) =&nbsp;<em>g</em>(<em>f</em>(<em>x</em>)).</p>
<p>In this operation, the function&nbsp;<em>g</em>&nbsp;is&nbsp;<a href="https://en.wikipedia.org/wiki/Function_application">applied</a>&nbsp;to the result of applying the function&nbsp;<em>f</em>&nbsp;to&nbsp;<em>x</em>. That is, the functions&nbsp;</p>
<p><em>f</em> :&nbsp;<em>X</em>&nbsp;→&nbsp;<em>Y</em>&nbsp;and&nbsp;<em>g</em> :&nbsp;<em>Y</em>&nbsp;→&nbsp;<em>Z</em>&nbsp;</p>
<p>are&nbsp;<strong>composed</strong>&nbsp;to yield a function that maps&nbsp;<em>x</em>&nbsp;in&nbsp;<a href="https://en.wikipedia.org/wiki/Domain_of_a_function">domain</a>&nbsp;<em>X</em>&nbsp;to&nbsp;<em>g</em>(<em>f</em>(<em>x</em>))&nbsp;in&nbsp;<a href="https://en.wikipedia.org/wiki/Codomain">codomain</a>&nbsp;<em>Z</em>.</p>
<p>Intuitively, if&nbsp;<em>z</em>&nbsp;is a function of&nbsp;<em>y</em>, and&nbsp;<em>y</em>&nbsp;is a function of&nbsp;<em>x</em>, then&nbsp;<em>z</em>&nbsp;is a function of&nbsp;<em>x</em>.</p>
<p>The resulting&nbsp;<em>composite</em>&nbsp;function is denoted&nbsp;<em>g</em> ∘ <em>f</em>&nbsp;:&nbsp;<em>X</em>&nbsp;→&nbsp;<em>Z</em>, defined by:</p>
<p>&nbsp;(<em>g</em> ∘ <em>f</em> )(<em>x</em>) =&nbsp;<em>g</em>(<em>f</em>(<em>x</em>))&nbsp;for all&nbsp;<em>x</em>&nbsp;in&nbsp;<em>X</em>
"</p>
<hr>
<p>In this Proposal we generalize function composition to the case when a sequence of functions are composed together, so that the last one is applied on an argument $x, then  the last-but-one is applied on the result of this application, and so on … until finally the first function in the sequence is applied on the result produced so far.</p>
<p>This is an effective way of chaining a sequence of functions together, and we don’t need to invent or use any special operators or syntax, but we just pass this sequence of functions as argument to <strong><em>fn:multi-compose</em></strong>.</p>
<p><strong>fn:multi-compose := function($funs as function(*)*, $x)</strong></p>
<p><strong>Here is an XPath 3.0 implementation of fn:multi-compose</strong>:</p>
<pre><code class="language-xq">let $apply := function($f, $x) {fn:apply($f, [$x])},
    $multi-compose := function($funs as function(*)*, $x)
                  {
                    fold-right($funs, $x, $apply)
                  },
    (: The functions $incr and $times are needed just to show this example :) 
    $incr := function($x) {op("+")(?, $x)},
    $times := function($y) {op("*")(?, $y)}                 
                  
 return
   $multi-compose(($times(5), $incr(1)), 2)
</code></pre>
<p>As wanted, the result of evaluating this is</p>
<p>15: (2 +1) * 5</p>
<h2>Remarks</h2>
<ol>
<li>
<p>In this implementation the type of the 2nd (last) argument of <strong><em>$multi-compose</em></strong> and <strong><em>$apply</em></strong> is <code>item()*</code> (any) and as such it is omitted. In case the function to be applied first, needs  more than one argument, all of its arguments must be presented in the function call as a single sequence , and are passed (in order) as the members of a single array, as already implemented by the standard <strong><a href="https://www.w3.org/TR/xpath-functions-31/#func-apply">fn:apply</a></strong>.</p>
</li>
<li>
<p>It is a dynamic error if any of the function applications produces a result which does not belong to the Domain of the function immediately preceding it in the function sequence.</p>
</li>
</ol>
</div></details></div>
<div class="toot" id="closed-181"><h2>Issue #181 closed<span class="toot-id"> #closed-181</span></h2><div class="pubdate">20 May at 18:32:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/181">https://github.com/qt4cg/qtspecs/issues/181</a></div><p>HOF Sequence Functions with Positional Arguments</p></div>
<div class="toot" id="created-516"><h2>Issue #516 created<span class="toot-id"> #created-516</span></h2><div class="pubdate">20 May at 18:12:06 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/516">https://github.com/qt4cg/qtspecs/issues/516</a></div><details><summary>Add position argument to filter/for-each callbacks</summary><div class="markup"><p>The coercion rules now allow a supplied function item to have lower arity than the signature of the declared type; the effect is that the information supplied in the additional arguments is ignored.</p>
<p>One of the intended use cases for this was to allow existing higher-order functions to be extended while retaining backwards compatibility. For example, in <code>fn:filter</code>, we can change the required type of the predicate function from <code>function(item()) as xs:boolean</code> to <code>function(item(), xs:positiveInteger) as xs:boolean</code>, with the second argument supplying the position of the item being tested. A function that isn't interested in the position can just ignore it, so existing calls will continue to work.</p>
<p>I propose that we add a position argument to the callbacks for:</p>
<pre><code>fn:filter
fn:for-each
fn:for-each-pair
fn:partition
fn:items-after
fn:items-before
fn:items-starting-where
fn:items-ending-where
array:filter
array:for-each
array:for-each-pair
</code></pre>
<p>Other candidates include</p>
<pre><code>fn:all
fn:some
fn:index-where
array:index-where
</code></pre>
<p>but I suggest we leave these unless someone can think of a use case.</p>
</div></details></div>
<div class="toot" id="agenda-05-23"><h2>QT4 CG meeting 035 draft agenda<span class="toot-id"> #agenda-05-23</span></h2><div class="pubdate">20 May at 10:15:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/05-23">https://qt4cg.org/meeting/agenda/2023/05-23</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="closed-471"><h2>Issue #471 closed<span class="toot-id"> #closed-471</span></h2><div class="pubdate">20 May at 10:04:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/471">https://github.com/qt4cg/qtspecs/issues/471</a></div><p>Unify formatting (function calls, code blocks, quotes) in the specification</p></div>
<div class="toot" id="closed-511"><h2>Issue #511 closed<span class="toot-id"> #closed-511</span></h2><div class="pubdate">20 May at 10:04:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/511">https://github.com/qt4cg/qtspecs/pull/511</a></div><p>471: &lt;code&gt; elements, simple/typographic quotes</p></div>
<div class="toot" id="created-515"><h2>Pull request #515 created<span class="toot-id"> #created-515</span></h2><div class="pubdate">20 May at 09:57:04 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/515">https://github.com/qt4cg/qtspecs/pull/515</a></div><p>504: Merge map:keys and map:keys-where</p></div>
<div class="toot" id="created-514"><h2>Issue #514 created<span class="toot-id"> #created-514</span></h2><div class="pubdate">20 May at 08:44:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/514">https://github.com/qt4cg/qtspecs/issues/514</a></div><details><summary>Lambda expression: Annotations</summary><div class="markup"><p><strong>Edit 2023-05-21:</strong> Feedback was incorporated.</p>
<p>In the current grammar rules, there are subtle differences in the <code>InlineFunctionExpr</code> and <code>LambdaExpr</code> rules that we should dissolve.</p>
<p>Annotations are not supported in lambda expressions, which I believe is an unnecessary restriction:</p>
<pre><code class="language-xquery">(: currently legal :)
let $delete-texts := %updating function($nodes) { delete nodes $nodes//text() }
return $delete-texts(//city)

(: currently illegal :)
let $delete-texts := %updating ($nodes) -&gt; { delete nodes $nodes//text() }
return $delete-texts(//city)
</code></pre>
<p>It should suffice to extend one rule in the grammar:</p>
<pre><code>(: old :)
LambdaExpr  ::=  LambdaParams "-&gt;" EnclosedExpr
(: new :)
LambdaExpr  ::=  Annotation* LambdaParams "-&gt;" EnclosedExpr
</code></pre>
<hr>
<p>We could also type declarations (as @michaelhkay has indicated below, though, this might not be as simple to realize as I hoped):</p>
<pre><code class="language-xquery">(: currently legal :)
let $find-john := function($node as node()) as xs:boolean { contains($node, 'john') }
return $find-john($node)

(: currently illegal :)
let $find-john := ($node as node()) as xs:boolean -&gt; { contains($node, 'john') }
return $find-john($node)
</code></pre>
<p>The type declarations cannot be allowed if parentheses are omitted (unless we make them mandatory):</p>
<pre><code class="language-xquery">(: without parens :)
$i -&gt; { ... }

(: parens :)
($i as xs:int) as xs:int -&gt; { ... }
</code></pre>
<p>These are the current grammar rules:</p>
<pre><code>FunctionItemExpr    ::=  NamedFunctionRef | InlineFunctionExpr | LambdaExpr
InlineFunctionExpr  ::=  Annotation* "function" FunctionSignature FunctionBody
FunctionSignature   ::=  "(" ParamList? ")" TypeDeclaration?
ParamList           ::=  Param ("," Param)*
Param               ::=  "$" EQName TypeDeclaration?
FunctionBody        ::=  EnclosedExpr
LambdaExpr          ::=  LambdaParams "-&gt;" EnclosedExpr
LambdaParams        ::=  LambdaParam | "(" | (LambdaParam ("," LambdaParam)*)? | ")"
LambdaParam         ::=  "$" VarName
</code></pre>
<p>As the <code>InlineFunctionExpr</code> and <code>LambdaExpr</code> both generate anonymous functions, we shouldn’t make a difference, and this is what I would recommend:</p>
<pre><code>FunctionItemExpr    ::=  NamedFunctionRef | InlineFunctionExpr
InlineFunctionExpr  ::=  Annotation* (InlineFunction | LambdaFunction) FunctionBody
InlineFunction      ::=  "function" FunctionSignature
LambdaFunction      ::=  (Param | FunctionSignature)) "-&gt;"
FunctionSignature   ::=  "(" ParamList? ")" TypeDeclaration?
ParamList           ::=  TypedParam ("," TypedParam)*
TypedParam          ::=  Param TypeDeclaration?
Param               ::=  "$" VarName
</code></pre>
<p>Disclaimer: I could have raised this earlier, but I didn’t want to prolong the ongoing discussion on the open pull requests.</p>
</div></details></div>
<div class="toot" id="created-513"><h2>Issue #513 created<span class="toot-id"> #created-513</span></h2><div class="pubdate">20 May at 08:00:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/513">https://github.com/qt4cg/qtspecs/issues/513</a></div><details><summary>Arrow operator: Inline functions without parens</summary><div class="markup"><p>See also https://github.com/qt4cg/qtspecs/issues/435#issuecomment-1508228624: If an inline function expression is used as the right-hand operand of the arrow operators, parentheses must be used:</p>
<pre><code class="language-xquery">(: now :)
$seq =&gt; (function($x) { ... })()
(: desirable :)
$seq =&gt; function($x) { ... }()
</code></pre>
<p>This could be changed by adding the <code>InlineFunctionExpr</code> to the <code>ArrowDynamicFunction</code> rule:</p>
<blockquote>
<p>[115]  SequenceArrowTarget  ::=  "=&gt;" ((ArrowStaticFunction ArgumentList) | (ArrowDynamicFunction PositionalArgumentList))
[151]  ArrowStaticFunction  ::=  EQName
[152]  ArrowDynamicFunction  ::=  VarRef | ParenthesizedExpr | <code>InlineFunctionExpr</code>
[142]  ArgumentList  ::=  "(" ((PositionalArguments ("," KeywordArguments)?) | KeywordArguments)? ")"
[143]  PositionalArgumentList  ::=  "(" PositionalArguments? ")"</p>
</blockquote>
<p>It will be best to tackle this after we’ve resolved #503, and we’ll have to check if the simplification doesn’t cause ambiguities.</p>
</div></details></div>
<div class="toot" id="closed-53"><h2>Issue #53 closed<span class="toot-id"> #closed-53</span></h2><div class="pubdate">19 May at 20:01:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/53">https://github.com/qt4cg/qtspecs/issues/53</a></div><p>Allow function keyword inline functions without parameters</p></div>
<div class="toot" id="closed-436"><h2>Issue #436 closed<span class="toot-id"> #closed-436</span></h2><div class="pubdate">19 May at 20:00:53 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/436">https://github.com/qt4cg/qtspecs/issues/436</a></div><p>Allow inline function expressions in arrow operator call chains</p></div>
<div class="toot" id="closed-435"><h2>Issue #435 closed<span class="toot-id"> #closed-435</span></h2><div class="pubdate">19 May at 20:00:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/435">https://github.com/qt4cg/qtspecs/issues/435</a></div><p>Remove the inlined function expression variant of the thin arrow operator</p></div>
<div class="toot" id="created-512"><h2>Pull request #512 created<span class="toot-id"> #created-512</span></h2><div class="pubdate">19 May at 14:47:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/512">https://github.com/qt4cg/qtspecs/pull/512</a></div><details><summary>256: Context for default function parameter expressions</summary><div class="markup"><p>This is a renewed attempt to tackle issue 256, which concerns how to define the static and dynamic context for default value expressions for optional function parameters in XQuery and XSLT. The resolution is to define the static and dynamic context for these expressions in detail.</p>
<p>To make this work, some refinement of the static and dynamic context definitions is needed:</p>
<ul>
<li>default collation is moved from the static context to the dynamic context, with a note that it is always known statically except in the case when defining the default for a function parameter.</li>
<li>static base URI (in the static context) and executable base URI (in the dynamic context) are now formally separated; previously we fudged this by saying they could be different, but without recognizing separate context components</li>
<li>the base URI for resolving relative collation URIs is now implementation defined. This allows implementors to use either the compile-time or run-time base URI, or some other URI defined using a processor API.</li>
</ul>
</div></details></div></div><p>See 919
            more statuses in yearly archives.</p></article></main></body></html>