<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2022/">2022</a></p><div class="toots">
<div class="toot" id="created-296"><h2>Issue #296 created<span class="toot-id"> #created-296</span></h2><div class="pubdate">22 Dec at 10:44:18 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/296">https://github.com/qt4cg/qtspecs/issues/296</a></div><details><summary>Default namespace for elements; especially in the context of HTML</summary><div class="markup"><p>There can be little doubt that the fact that an unprefixed name in XPath fails to select an unprefixed element in the source document is one of the major gotcha's, causing massive bewilderment to all newbie users.</p>
<p>The XPath 2.0 solution of using a default element namespace in the static context is a partial solution; its main drawback is that it doesn't help the newbies who didn't know about the problem or its solution.</p>
<p>The HTML "living standard" introduces a "wilful violation" of the XPath 1.0 spec to address the issue. Given that most elements in an HTML DOM will be in the XHTML namespace, it states:</p>
<blockquote>
<p>If the QName has no prefix and the principal node type of the axis is element, then the default element namespace is used. Otherwise if the QName has no prefix, the namespace URI is null. The default element namespace is a member of the context for the XPath expression. The value of the default element namespace when executing an XPath expression through the DOM3 XPath API is determined in the following way:</p>
</blockquote>
<blockquote>
<p>If the context node is from an HTML DOM, the default element namespace is "http://www.w3.org/1999/xhtml".
Otherwise, the default element namespace URI is null.</p>
</blockquote>
<p>It then adds a note which is blatantly untrue:</p>
<blockquote>
<p>This is equivalent to adding the default element namespace feature of XPath 2.0 to XPath 1.0, and using the HTML namespace as the default element namespace for HTML documents. It is motivated by the desire to have implementations be compatible with legacy HTML content while still supporting the changes that this specification introduces to HTML regarding the namespace used for HTML elements, and by the desire to use XPath 1.0 rather than XPath 2.0.</p>
</blockquote>
<p>Since the XPath 2.0 facility picks up the default namespace from the static context, while the HTML "wilful violation" picks it up dynamically from a property of the context node (namely "being from an HTML DOM") there is no way these can be considered equivalent.</p>
<p>(Note also, there's a significant ambiguity in the "wilful violation" rules: what exactly is the "context node" that determines this behaviour? I think they're suggesting it is the context node at the point of XPath API invocation, not the context node for the specific axis step. This makes it rather unclear how the rule is supposed to apply to XSLT. And: if an XSLT stylesheet creates a temporary tree with nodes in the XHTML namespaces, do we consider those nodes as being "from an HTML DOM"?)</p>
<p>Nevertheless, the intent of the "violation" is worthy, and it would be nice if we can find a solution to this problem that works both for HTML and for other vocabularies.</p>
<p>Our current proposal for fn:parse-html is that HTML elements should go in the XHTML namespace and this means that users familiar with XPath 1.0 implementations in the browser will trip over this problem. A lot.</p>
</div></details></div>
<div class="toot" id="created-295"><h2>Issue #295 created<span class="toot-id"> #created-295</span></h2><div class="pubdate">20 Dec at 23:43:38 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/295">https://github.com/qt4cg/qtspecs/issues/295</a></div><details><summary>Extend support for self-reference in record types</summary><div class="markup"><p>We currently allow a field in a record to have type "..", that is, the same type as the containing record definition.</p>
<p>This isn't good enough for the fn:random-number-generator, where we need something like:</p>
<pre><code>random-number-generator-record:
record(
   number as&nbsp;xs:double,
   next as&nbsp;function() as #random-number-generator-record,
   permute as&nbsp;function(item()*) as item()*,
   *,
)

</code></pre>
<p>There are two ways we could tackle this. We could extend the syntax to allow ".." here, so it becomes
<code>next as&nbsp;function() as ..</code> Or we could allow named item types to refer to themselves:</p>
<pre><code>&lt;xsl:item-type name="random-number-generator-record"
   as="record(
   number as&nbsp;xs:double,
   next as&nbsp;function() as type(random-number-generator-record),
   permute as&nbsp;function(item()*) as item()*,
   *,
)"&gt;

</code></pre>
<p>We haven't really reviewed the proposal for named item types. It's easy enough to declare them in XQuery and XSLT (and not really very difficult to define the rules under which self-referential definitions are allowed). Free-standing XPath is a bit more of a problem.</p>
</div></details></div>
<div class="toot" id="minutes-12-20"><h2>QT4 CG meeting 016 draft minutes<span class="toot-id"> #minutes-12-20</span></h2><div class="pubdate">20 Dec at 17:26:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2022/12-20">https://qt4cg.org/meeting/minutes/2022/12-20</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-294"><h2>Issue #294 created<span class="toot-id"> #created-294</span></h2><div class="pubdate">20 Dec at 15:48:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/294">https://github.com/qt4cg/qtspecs/issues/294</a></div><details><summary>fn:remove removing multiple items</summary><div class="markup"><p><code>map:remove</code> and <code>array:remove</code> take a list of keys/positions to be removed; fn:remove only accepts one. I propose changing <code>fn:remove</code> to bring it into line.</p>
<p>Without this, removing multiple items is tricky because removing one item changes the positions of the others.</p>
<p>Example use case:</p>
<pre><code>let $p := index-where($persons -&gt;{@status='retired'))
return $persons =&gt; remove($p)
</code></pre>
<p>(Of course, this could always be done with a filter. But removing a small number of items from a large sequence might be more efficient than a filter)</p>
</div></details></div>
<div class="toot" id="created-293"><h2>Issue #293 created<span class="toot-id"> #created-293</span></h2><div class="pubdate">19 Dec at 20:14:27 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/293">https://github.com/qt4cg/qtspecs/issues/293</a></div><details><summary>Error in fn:doc-available specification</summary><div class="markup"><p>Observed on the XML.com slack (Oct 6 2022):</p>
<p>A rule in the XQFO 3.1 specification seems to be inconsistent. In the error summary, it’s stated that:</p>
<blockquote>
<p><code>err:FODC0005</code>, Invalid argument to fn:doc or fn:doc-available. Raised (optionally) by <code>fn:doc</code> and <code>fn:doc-available</code> if the argument is not a valid URI reference.</p>
</blockquote>
<p>The rules for <code>fn:doc-available</code> say: “[…] In all other cases this function returns false. This includes the case where an invalid URI is supplied, and also the case where a valid relative URI reference is supplied, and cannot be resolved, for example because the static base URI is absent.”</p>
</div></details></div>
<div class="toot" id="created-292"><h2>Pull request #292 created<span class="toot-id"> #created-292</span></h2><div class="pubdate">19 Dec at 18:43:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/292">https://github.com/qt4cg/qtspecs/pull/292</a></div><details><summary>Merge signatures with optional params</summary><div class="markup"><p>This addresses issue #291, concerned with the validity of function-catalog.xml against its XSD schema, and the validity of the intermediate file xpath-functions-40.xml against the xmlspec DTD (as amended for QT).</p>
<p>It also fixes the trivial error raised in issue #288, and addresses issue #70 by making each function have a single prototype with default values where appropriate. (This is not purely an editorial change, it enables you for example to supply () as the $length argument of fn:substring).</p>
<p>There's more work on issue #257 (editorial improvements to handling of named record types).</p>
<p>This commit is mainly for technical review by NDW. It combines changes to the stylesheets, schema, and content, and may therefore require picking apart before it can be applied.</p>
</div></details></div>
<div class="toot" id="created-291"><h2>Issue #291 created<span class="toot-id"> #created-291</span></h2><div class="pubdate">19 Dec at 11:31:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/291">https://github.com/qt4cg/qtspecs/issues/291</a></div><details><summary>DTD validity of F&amp;O spec</summary><div class="markup"><p>Despite PR #228, I'm still seeing a lot of validation errors when (using Oxygen) I apply DTD validation to build/expanded/xpath-functions-40/xpath-functions-40.xml</p>
<p>Many of these relate to style attributes not being allowed on table, td, and code elements.</p>
<p>The merge-function-specs.xsl explicitly creates elements with these attributes:</p>
<p>See</p>
<ul>
<li><code>&lt;xsl:template match="fos:options"&gt;</code> line 382</li>
<li><code>&lt;xsl:template match="fos:option"&gt;</code> line 408</li>
<li><code>&lt;xsl:template match="processing-instruction('local-function-index')"&gt;</code> line 347</li>
</ul>
<p>It all works because xmlspec-2016.xsl handles these attributes even though the DTD doesn't allow them: see <code>&lt;xsl:template name="style-attributes"&gt;</code> at line 2096.</p>
<p>There seem to be three possible options:</p>
<ul>
<li>Extend the DTD to allow these attributes</li>
<li>Change merge-function-specs.xsl to not generate these attributes, instead perhaps generating a role attribute which gets picked up in the final styling</li>
<li>Sweep the issue under the carpet; avoid validating the intermediate file.</li>
</ul>
<p>The main problem with the third approach is that it allows other errors to go unnoticed, for example putting text directly within an <code>&lt;item&gt;</code> without a containing <code>&lt;p&gt;</code>.</p>
</div></details></div>
<div class="toot" id="created-290"><h2>Pull request #290 created<span class="toot-id"> #created-290</span></h2><div class="pubdate">17 Dec at 19:21:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/290">https://github.com/qt4cg/qtspecs/pull/290</a></div><details><summary>Fix issue #18 (function type hierarchy)</summary><div class="markup"><p>Editorial change to fix a technical error in the data model spec (issue #18). Does not change the specification.</p>
</div></details></div>
<div class="toot" id="created-289"><h2>Pull request #289 created<span class="toot-id"> #created-289</span></h2><div class="pubdate">17 Dec at 18:45:49 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/289">https://github.com/qt4cg/qtspecs/pull/289</a></div><details><summary>Proposal to add fallback behaviour to map:get and array:get</summary><div class="markup"><p>Note: I got a build failure trying to build this, it's doing DTD validation but there are invalidities, unrelated to the changes I made.</p>
</div></details></div>
<div class="toot" id="agenda-12-20"><h2>QT4 CG meeting 016 draft agenda<span class="toot-id"> #agenda-12-20</span></h2><div class="pubdate">16 Dec at 09:41:30 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2022/12-20">https://qt4cg.org/meeting/agenda/2022/12-20</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-288"><h2>Issue #288 created<span class="toot-id"> #created-288</span></h2><div class="pubdate">15 Dec at 14:49:30 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/288">https://github.com/qt4cg/qtspecs/issues/288</a></div><details><summary>Error in fn:path specification</summary><div class="markup"><p>On the XML.com slack, Phil Fearon observes:</p>
<blockquote>
<p>The XPath 3.1 specification has an error in the <a href="https://www.w3.org/TR/xpath-functions-31/#func-path">definition of fn:path</a></p>
<p>The properties section states:</p>
<p>The one-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-31/#dt-deterministic">·deterministic·</a>, <a href="https://www.w3.org/TR/xpath-functions-31/#dt-context-dependent">·context-dependent·</a>, and [·focus-dependent·] (https://www.w3.org/TR/xpath-functions-31/#dt-focus-dependent).
The two-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-31/#dt-deterministic">·deterministic·</a>, <a href="https://www.w3.org/TR/xpath-functions-31/#dt-context-independent">·context-independent·</a>, and <a href="https://www.w3.org/TR/xpath-functions-31/#dt-focus-independent">·focus-independent·</a>.</p>
<p>The term one-argument form should be zero-argument form and consequently, two-argument form should be one-argument form</p>
</blockquote>
</div></details></div>
<div class="toot" id="closed-277"><h2>Issue #277 closed<span class="toot-id"> #closed-277</span></h2><div class="pubdate">14 Dec at 14:13:47 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/277">https://github.com/qt4cg/qtspecs/issues/277</a></div><p>Overriding functions using xsl:import</p></div>
<div class="toot" id="closed-279"><h2>Issue #279 closed<span class="toot-id"> #closed-279</span></h2><div class="pubdate">14 Dec at 14:13:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/279">https://github.com/qt4cg/qtspecs/pull/279</a></div><p>Rewrite XSLT §10.3.4 (function overriding) for clarity</p></div>
<div class="toot" id="closed-287"><h2>Issue #287 closed<span class="toot-id"> #closed-287</span></h2><div class="pubdate">14 Dec at 14:13:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/287">https://github.com/qt4cg/qtspecs/pull/287</a></div><p>PR #279 with merge conflicts resolved</p></div>
<div class="toot" id="created-287"><h2>Pull request #287 created<span class="toot-id"> #created-287</span></h2><div class="pubdate">14 Dec at 13:57:39 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/287">https://github.com/qt4cg/qtspecs/pull/287</a></div><details><summary>PR #279 with merge conflicts resolved</summary><div class="markup"><p>Close #279
Close #277</p>
</div></details></div>
<div class="toot" id="created-286"><h2>Pull request #286 created<span class="toot-id"> #created-286</span></h2><div class="pubdate">13 Dec at 21:06:36 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/286">https://github.com/qt4cg/qtspecs/pull/286</a></div><p>Spec changes to allow child::(a|b|c) - Issue 107</p></div>
<div class="toot" id="closed-258"><h2>Issue #258 closed<span class="toot-id"> #closed-258</span></h2><div class="pubdate">13 Dec at 20:08:52 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/258">https://github.com/qt4cg/qtspecs/pull/258</a></div><p>Issue #114 - add array:index-where() function</p></div>
<div class="toot" id="closed-265"><h2>Issue #265 closed<span class="toot-id"> #closed-265</span></h2><div class="pubdate">13 Dec at 17:58:27 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/265">https://github.com/qt4cg/qtspecs/issues/265</a></div><p>Type hierarchy tables/diagrams</p></div>
<div class="toot" id="closed-268"><h2>Issue #268 closed<span class="toot-id"> #closed-268</span></h2><div class="pubdate">13 Dec at 17:58:26 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/268">https://github.com/qt4cg/qtspecs/pull/268</a></div><p>New type-hierarchy images / descriptions</p></div>
<div class="toot" id="minutes-12-13"><h2>QT4 CG meeting 015 draft minutes<span class="toot-id"> #minutes-12-13</span></h2><div class="pubdate">13 Dec at 17:23:01 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2022/12-13">https://qt4cg.org/meeting/minutes/2022/12-13</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="agenda-12-13"><h2>QT4 CG meeting 015 draft agenda<span class="toot-id"> #agenda-12-13</span></h2><div class="pubdate">09 Dec at 07:44:30 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2022/12-13">https://qt4cg.org/meeting/agenda/2022/12-13</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-285"><h2>Issue #285 created<span class="toot-id"> #created-285</span></h2><div class="pubdate">08 Dec at 11:34:57 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/285">https://github.com/qt4cg/qtspecs/issues/285</a></div><details><summary>Stability of collections</summary><div class="markup"><p>The specification for fn:collection says:</p>
<blockquote>
<p>By default, this function is [·deterministic·]. This means that repeated calls on the function with the same argument will return the same result. However, for performance reasons, implementations may provide a user option to evaluate the function without a guarantee of determinism. The manner in which any such option is provided is [·implementation-defined·]. If the user has not selected such an option, a call to this function must either return a deterministic result or must raise a dynamic error [[err:FODC0003].</p>
</blockquote>
<p>I think this is unrealistic. The cost of making fn:collection deterministic is disproportionate to the benefits. It's very rare in practice for a query or stylesheet to process the same collection more than once, and retaining the information needed to deliver the identical results on these rare occasions is expensive (typically it means holding a long-term lock on the data, or keeping a copy of the entire collection in memory). It also inhibits techniques such as multi-threaded evaluation.</p>
<p>I would like to relax this requirement.</p>
</div></details></div>
<div class="toot" id="created-284"><h2>Pull request #284 created<span class="toot-id"> #created-284</span></h2><div class="pubdate">07 Dec at 11:55:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/284">https://github.com/qt4cg/qtspecs/pull/284</a></div><details><summary>Add grammar for "if (test) then {expr}" with no else</summary><div class="markup"><p>As discussed in issue #234. In reviewing this PR, I suggest we consider it together with the existing proposals for ternary conditionals (x ?? y !! z) and the "otherwise" operator.</p>
</div></details></div>
<div class="toot" id="minutes-12-06"><h2>QT4 CG meeting 014 draft minutes<span class="toot-id"> #minutes-12-06</span></h2><div class="pubdate">06 Dec at 17:21:01 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2022/12-06">https://qt4cg.org/meeting/minutes/2022/12-06</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-283"><h2>Issue #283 created<span class="toot-id"> #created-283</span></h2><div class="pubdate">05 Dec at 11:23:06 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/283">https://github.com/qt4cg/qtspecs/issues/283</a></div><details><summary>Enumeration types</summary><div class="markup"><p>The draft specification includes a proposal to provide enumeration types. The proposal is incomplete, for example it does not include all the rules for conversions and casting. This issue is raised in order to outline where we are, what needs to be done, and to elicit consensus on whether we want to proceed with this.</p>
<p>What's the motivation? Primarily, making function signatures more expressive.</p>
<p><em>Q0: do we really need this?</em></p>
<p>The essence of the proposal is an ItemType that matches an enumerated set of xs:string values:</p>
<p><code>[131] | EnumerationType | ::= | "enum" "("&nbsp;&nbsp;StringLiteral&nbsp;(","&nbsp;&nbsp;StringLiteral)* ")"  </code>
For example, the type enum("red", "green", "blue") matches the string "green".</p>
<p><em>Q1: why restrict it to strings? I think my main reason was that the syntax gets complicated if we try to do it for data types that have no literal representation.</em></p>
<p>Subtyping is based on the value space. An enumeration type E is a subtype of another enumeration type F if the set of strings in E is a subset of those in F. All enumeration types are subtypes of xs:string.</p>
<p>Strings are not "labelled" as belonging to an enumeration type, matching is purely based on the value ("datum"). This doesn't provide very strong typing. If "violet" and "pink" are allowed by both the enumeration types <code>colour</code> and <code>flower</code>, then it's not intrinsically an error to use a variable of type <code>flower</code> where a <code>colour</code> is expected. Equally, a variable of type <code>xs:string</code> can be used where a <code>colour</code> is expected.</p>
<p><em>Q2: should enumerations be more strongly typed?</em></p>
<p>I would expect that an enumeration type can be used as the target of "cast" or "castable", but this is not currently in the spec.</p>
<p>The coercion rules as currently written say that if the expected type is an enumeration type, then the rules are largely the same as for any other subtype of <code>xs:string</code>:  casting from <code>xs:untypedAtomic</code> applies, promotion from <code>xs:anyURI</code> does not apply, 1.0 compatibility mode rules do not apply.</p>
<p>Operators and functions on enumeration types are the same as for <code>xs:string</code>. This means, for example, that there are no special rules for comparison: values are ordered as strings and are compared using the default collation.</p>
</div></details></div>
<div class="toot" id="closed-271"><h2>Issue #271 closed<span class="toot-id"> #closed-271</span></h2><div class="pubdate">05 Dec at 10:26:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/271">https://github.com/qt4cg/qtspecs/pull/271</a></div><p>Amendments to data model spec as per minutes of 2022-11-22</p></div>
<div class="toot" id="agenda-12-06"><h2>QT4 CG meeting 014 draft agenda<span class="toot-id"> #agenda-12-06</span></h2><div class="pubdate">05 Dec at 10:20:13 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2022/12-06">https://qt4cg.org/meeting/agenda/2022/12-06</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="closed-282"><h2>Issue #282 closed<span class="toot-id"> #closed-282</span></h2><div class="pubdate">05 Dec at 09:51:49 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/282">https://github.com/qt4cg/qtspecs/pull/282</a></div><p>Copy of MK actions-2022-11-15 branch by NW</p></div>
<div class="toot" id="created-282"><h2>Pull request #282 created<span class="toot-id"> #created-282</span></h2><div class="pubdate">05 Dec at 09:46:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/282">https://github.com/qt4cg/qtspecs/pull/282</a></div><details><summary>Copy of MK actions-2022-11-15 branch by NW</summary><div class="markup"><p>Resolves merge conflicts in #247</p>
</div></details></div>
<div class="toot" id="created-281"><h2>Issue #281 created<span class="toot-id"> #created-281</span></h2><div class="pubdate">03 Dec at 22:12:41 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/281">https://github.com/qt4cg/qtspecs/issues/281</a></div><details><summary>XPath: Short-circuiting Functions and Lazy Evaluation Hints</summary><div class="markup"><h1>Short-circuiting Functions and Lazy Evaluation Hints</h1>
<h1><br>1. Introduction</h1>
<p>As shown in <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation#Support_in_common_programming_and_scripting_languages">Wikipedia</a>, most contemporary programming languages offer reasonable support for <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation#Definition">short-circuit evaluation</a>
(also known as <em>minimal</em> or <em>McCarthy evaluation</em>), including several standard language short-circuit operators.</p>
<p>Short-circuiting, as we will call the above in this document, is commonly used to achieve:</p>
<ol>
<li><em>Avoiding undesired side effects of evaluating the second argument</em>, such as
excessive evaluation time or throwing an error</li>
</ol>
<p>Usual example, using a&nbsp;<a href="https://en.wikipedia.org/wiki/C_(programming_language)">C-based</a>&nbsp;language:</p>
<pre><code class="language-c">   int denom = 0;
   if (denom != 0 &amp;&amp; num / denom)
   {
   ...//ensures that calculating num/denom never results in divide-by-zero error
   }
</code></pre>
<p>Consider the following example:</p>
<pre><code class="language-c">   int a = 0;
   if (a != 0 &amp;&amp; myfunc(b))
   {
     do_something();
   }
</code></pre>
<p>In this example, short-circuit evaluation guarantees that&nbsp;<code>myfunc(b)</code>&nbsp;is never called. This is because&nbsp;<code>a&nbsp;!= 0</code>&nbsp;evaluates to&nbsp;<em><code>false</code></em>. This feature permits two useful programming constructs.</p>
<ol>
<li>
<p>If the first sub-expression checks whether an expensive computation is needed and the check evaluates to&nbsp;<em>false</em>, one can eliminate expensive computation in the second argument.</p>
</li>
<li>
<p>It permits a construct where the first expression guarantees a condition without which the second expression may cause a&nbsp;<a href="https://en.wikipedia.org/wiki/Run-time_error">run-time error</a>.</p>
</li>
<li>
<p><em>Idiomatic conditional construct</em></p>
</li>
</ol>
<p><a href="https://en.wikipedia.org/wiki/Perl">Perl</a>&nbsp;idioms:</p>
<pre><code>   some_condition or die; # Abort execution if some_condition is false

   some_condition and die; # Abort execution if some_condition is true
</code></pre>
<h1><br>2. Short-circuiting in XPath</h1>
<p>In short (pun intended) there is no such thing mentioned in any officially-published W3C version (&lt;= 3.1) of XPath.</p>
<p>This topic was briefly mentioned in the discussion of <a href="https://github.com/qt4cg/qtspecs/issues/78">another proposal</a>: that of providing the capability to specify strictly the order of evaluation.</p>
<p>Aspects of incorporating hints for <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a> (a topic related to short-cutting) were discussed also in the thread to <a href="https://app.slack.com/client/T011VK9115Z/C01GVC3JLHE/thread/C01GVC3JLHE-1665542903.180989">this question</a> on the Xml.com Slack.</p>
<p>The situation at present is that the XPath processor that is being used decides whether or not to perform shortcutting, even in obvious cases. Thus, varying from one XPath processor to another, the differences in performance evaluation could be dramatic. For example, the following XPath expression is evaluated on BaseX (ver. &gt;= 10.3) for 0 seconds, and the same expression is evaluated by Saxon ver. 11 for about 100 seconds.</p>
<pre><code class="language-xq">
let $fnAnd := function($x)
   {
     function($y)
     {
      if(not($x)) then false()
                  else $y
     }
   }
   return
      $fnAnd(false())(some $b in ( ((1 to 1000000000000000000) !true()) )  satisfies not($b)   )
</code></pre>
<h2><br>3. Analysis</h2>
<p>We can define the term “<em>function with shortcutting</em>” (just for a 2-argument function, but this can be extended for <code>N</code>-argument function where <code>N &gt;= 2</code>) in the  following way:</p>
<p>Given a function <code>$f($x, $y)</code>, we denote in XPath its partial application for a given value of $x (say <code>let $x := $t</code>) as:</p>
<p><code>$f($t, ?)</code></p>
<p>The above is a function of one argument. By definition:</p>
<p><code>$f($x, $y)</code> is equivalent to <code>$f($x, ?) ($y)</code>, for every pair <code>$x</code> and <code>$y</code>.</p>
<p>That is, the partial application of the 2-argument function <code>$f</code> with fixed 1st argument is another function <code>$g</code> which when applied on the 2nd argument (<code>$y</code>) of <code>$f($x, $y)</code> produces the same value as <code>$f($x, $y)</code>:</p>
<p>If <code>$g</code> is defined as <code>$f($x, ?)</code>, then <code>$g($y)</code> produces the same value as <code>$f($x, $y)</code> for every pair <code>$x</code> and <code>$y</code>.</p>
<p>Let us take a specific function:</p>
<pre><code class="language-xq">let $fAnd := function($x as xs:boolean, $y as xs:boolean) as xs:boolean
                     { $x and $y}
</code></pre>
<p>Then one equivalent way of defining <code>$fAnd</code> is:</p>
<pre><code class="language-xq">let $fAnd := function($x as xs:boolean, $y as xs:boolean) as xs:boolean
                     {
                       let $partial := function($x as xs:boolean) as function(xs:boolean) as xs:boolean
                                               {
                                                  if(not($x)) then -&gt;(){false()}
                                                              else -&gt;($t) {$t}
                                               }
                         return $partial($x)($y)
                    }
   return
       $fAnd(false(), true())
</code></pre>
<p>The <strong><em><code>$partial</code></em></strong> function is the result of the partial application <code>$fAnd($x, ?)</code> and by definition this is a function of arity 1, which when applied on the 2nd argument of <code>$fAnd</code>, produces the same result as <code>$fAnd($x, $y)</code></p>
<p>From the code above we see that actually there exists a value of <code>$x</code> (the value <code>false()</code> ) for which <code>$fAnd($x, ?)</code> is not a function of one argument, but a constant function (of <strong>0</strong> arguments) – that produces the value <code>false()</code>.</p>
<p><strong>Definition</strong>:</p>
<p>We say that a function <code>f(x, y)</code> <em><strong>allows shortcutting</strong></em> if there exists at least one value <code>t</code> such that</p>
<p><code>f(t, ?)</code> is a constant.</p>
<h1><br>4. Solution</h1>
<p><strong>How can an XPath processor treat a function with shortcutting?</strong></p>
<p>Obviously, if the XPath processor knows that <code>f(x, y)</code> allows shortcutting, then it becomes possible to delay the evaluation of the 2nd argument <code>y</code> and only perform this evaluation if the arity of the function returned by <code>f(t, ?)</code> is <code>1</code>, and not <code>0</code>.</p>
<p><strong>How can an XPath processor know that a given function allows shortcutting?</strong></p>
<ul>
<li>
<p>One way to obtain this knowledge is to evaluate <code>f(t, ?)</code> and get the arity of the resulting function. XPath 3.1 allows getting the arity of any function item with the function <a href="https://www.w3.org/TR/xpath-functions-31/#func-function-arity">fn:function-arity()</a>.      However, doing this on every function call could be expensive and deteriorate performance.</p>
</li>
<li>
<p>Another way of informing the XPath processor that a given function <code>f(x, y)</code> allows shortcutting is if the language provides <em><strong>hints for lazy evaluation</strong></em>:
<br>let $fAnd := function($x as xs:boolean, <em><strong>lazy</strong></em> $y as xs:boolean) as xs:boolean<br>
<br>Only in the case when there is a <em><strong>lazy</strong></em> hint specified the XPath processor will check the arity of <code>f(x, ?)</code> and will not need to evaluate the <code>y</code> argument if this arity is <code>0</code>.</p>
</li>
</ul>
<p>Let us return to the original example:</p>
<pre><code class="language-xq">let $fAnd := function($x as xs:boolean, $y as xs:boolean) as xs:boolean
                     {
                       let $partial := function($x as xs:boolean) as function(xs:boolean) as xs:boolean
                                               {
                                                  if(not($x)) then -&gt;(){false()}
                                                              else -&gt;($t) {$t}
                                               }
                         return $partial($x)($y)
                    }
   return
       $fAnd(false(), true())
</code></pre>
<p>Executing this with an Xpath 3.1 processor, an error is raised: “<em>1 argument supplied, 0 expected: function() as xs:boolean { false() }.</em>”</p>
<p><img src="https://user-images.githubusercontent.com/10605892/205463393-3b4558ac-66d9-453f-81fc-f83ec0499425.png" alt="image"></p>
<p>But according to the updated “<a href="https://qt4cg.org/pr/279/xquery-40/xpath-40.html#id-coercion-rules">Coercion Rules / Function Coercion</a>” in Xpath 4.0, no error will occur:</p>
<blockquote>
<p>“<em>If&nbsp;<em>F</em>&nbsp;has lower arity than the expected type, then&nbsp;<em>F</em>&nbsp;is wrapped in a new function that declares and ignores the additional argument; the following steps are then applied to this new function.</em></p>
</blockquote>
<blockquote>
<p><em>For example, if the expected type is&nbsp;<code>function(node(), xs:boolean) as  xs:string</code>, and the supplied function is&nbsp;<code>fn:name#1</code>, then the supplied function is effectively replaced by&nbsp;<code>function($n as node(), $b as xs:boolean) as xs:string {fn:name($n)}</code></em>”</p>
</blockquote>
<p>This is exactly the place where the XPath processor will call the lower-arity function without providing to it the ignored, and not needed to be evaluated, additional argument.</p>
<p>Thus, according to this rule, an XPath 4.0 processor will successfully evaluate the above expression and will not issue the error shown above.</p>
<p>Finally, we can put the <em>lazy</em> hint on a function declaration or on a function call, or on both places:</p>
<pre><code class="language-xq">let $fAnd := function($x as xs:boolean, lazy $y as xs:boolean) as  xs:boolean
   {
     let $partial := function($x as xs:boolean) as function(lazy xs:boolean) as xs:boolean
                           {
                              if(not($x)) then -&gt;(){false()}
                                          else -&gt;($t) {$t}
                           }
      return $partial($x)( lazy $y)
   }
   return
       $fAnd(false(), lazy true())
</code></pre>
<p><strong><em>How to write short-circuiting functions?</em></strong></p>
<p>The code above is a good example how one can write a short-circuiting function evaluating which the XPath processor would be aware that a short-circuit is happening but instead of signaling arity error as an XPath 3.1 processor does, will logically ignore the unneeded 2nd argument.</p>
</div></details></div></div><p>See 58
            more statuses in yearly archives.</p></article></main></body></html>